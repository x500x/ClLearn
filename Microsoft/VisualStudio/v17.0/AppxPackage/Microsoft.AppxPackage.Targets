<?xml version="1.0" encoding="utf-8" ?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="15.0">

  <!-- ========================================================================== -->
  <!-- Note: After updating this file, make sure that                             -->
  <!-- %DepotRoot%\xmake\XmakeCommandLine\Microsoft.Build.CommonTypes.xsd         -->
  <!-- is updated to reflect changes.                                             -->
  <!--                                                                            -->
  <!-- To test whether schema changes are OK, copy changed XSD file to            -->
  <!-- %ProgramFiles(x86)%\Microsoft Visual Studio 15.0\Xml\Schemas\1033\MSBuild, -->
  <!-- then open this file in Visual Studio.                                      -->
  <!-- It should not display any schema warnings in error list window.            -->
  <!-- ========================================================================== -->

  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>

  <PropertyGroup>
    <AppxMSBuildToolsPath Condition="'$(AppxMSBuildToolsPath)' == ''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\AppxPackage\</AppxMSBuildToolsPath>
    <PriProjTaskAssembly Condition="'$(PriProjTaskAssembly)' == ''">$(AppxMSBuildToolsPath)\Microsoft.Build.Packaging.Pri.Tasks.dll</PriProjTaskAssembly>
    <AppxMSBuildTaskAssembly Condition="'$(AppxMSBuildTaskAssembly)' == ''">$(AppxMSBuildToolsPath)Microsoft.Build.AppxPackage.dll</AppxMSBuildTaskAssembly>
  </PropertyGroup>

  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreateAppInstallerPublishMeta" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreateAppStoreContainer" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ExpandPayloadDirectories" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ExtractStoreAssociationInformation" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.FilterItemGroup" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.FilterOutUnusedLanguagesResourceFileMaps" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppInstallerFile" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxLayout" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxManifest" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxPackageRecipe" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxSymbolPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateDisposableSigningCertificate" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateFinalAppxLayout" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateLandingPage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateMappingFile" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateProjectArchitecturesFile" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetAppxBundlePlatforms" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetAppxFlatBundlePackages" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetDefaultResourceLanguage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetFrameworkSdkPackages" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetPackageArchitecture" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetSdkFileFullPath" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetSdkPropertyValue" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetUnionWinmdPropertyValues" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetWindowsDesktopSdkDir" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.HydrateAppxLayoutAssetPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.HydrateAppxLayoutPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.HydrateAppxLayoutPrebuiltPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.HydrateAppxLayoutResourcePackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.MakeAppxBundle" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.MakeAppxContentGroupMap" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.MakeAppxFlatBundle" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.MakeAppxPack" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ParsePlatformSpecificBundleArtifactsLists" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ReadAppxLayoutTemplate" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemoveDisposableSigningCertificate" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemoveDuplicateSDKReferences" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemovePayloadDuplicates" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemoveRedundantCopyLocalItems" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemoveRedundantXamlFilesFromSdkPayload" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.SignAppxPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.SignAppxPackages" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.StoreSubmission" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.UpdateAppxManifestForBundle" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxManifest" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxManifestItems" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxOptionalPackageUploadBundle" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAzureCodeSigningVersion" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAzureKeyVaultVersion" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateBundleMapping" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateConfiguration" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidatePipeline" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidatePublisherName" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateSigningCertificate" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateStoreManifest" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.VerifyAppxBundlePlatforms" />

  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.ExpandPriContent" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.CreatePriConfigXmlForSplitting" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.CreatePriConfigXmlForMainPackageFileMap" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.CreatePriConfigXmlForFullIndex" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.CreatePriFilesForPortableLibraries" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.GenerateMainPriConfigurationFile" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.GeneratePriConfigurationFiles" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.GenerateProjectPriFile" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.RemoveDuplicatePriFiles" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.UpdateMainPackageFileMap" />

  <!-- Adjust AppxPackage to be true Boolean flag. -->
  <PropertyGroup>
    <AppxPackage Condition="'$(AppxPackage)' != 'true'">false</AppxPackage>
  </PropertyGroup>

  <!-- Adjust DeployOptionalPackages to be true Boolean flag. -->
  <PropertyGroup>
    <DeployOptionalPackages Condition="'$(DeployOptionalPackages)' != 'true'">false</DeployOptionalPackages>
  </PropertyGroup>

  <!-- Flags controlling certain features -->
  <PropertyGroup>
    <AppxUseHardlinksIfPossible Condition="'$(AppxUseHardlinksIfPossible)' == ''">false</AppxUseHardlinksIfPossible>
    <AppxUseHardlinksForNugetIfPossible Condition="'$(AppxUseHardlinksForNugetIfPossible)' == ''">false</AppxUseHardlinksForNugetIfPossible>
    <AppxSkipUnchangedFiles Condition="'$(AppxSkipUnchangedFiles)' == ''">true</AppxSkipUnchangedFiles>
    <AppxGeneratePriEnabled Condition="'$(AppxGeneratePriEnabled)' == ''">true</AppxGeneratePriEnabled>
    <AppxGetPackagePropertiesEnabled Condition="'$(AppxGetPackagePropertiesEnabled)' == ''">true</AppxGetPackagePropertiesEnabled>
    <AppxPackageIncludePrivateSymbols Condition="'$(AppxPackageIncludePrivateSymbols)' == ''">false</AppxPackageIncludePrivateSymbols>
    <AppxSymbolPackageEnabled Condition="'$(AppxSymbolPackageEnabled)' == ''">true</AppxSymbolPackageEnabled>
    <AppxTestLayoutEnabled Condition="'$(AppxTestLayoutEnabled)' == ''">true</AppxTestLayoutEnabled>
    <AppxPackageValidationEnabled Condition="'$(AppxPackageValidationEnabled)' == ''">true</AppxPackageValidationEnabled>
    <AppxHarvestWinmdRegistration Condition="'$(AppxHarvestWinmdRegistration)' == ''">true</AppxHarvestWinmdRegistration>
    <AppxPrependPriInitialPath Condition="'$(AppxPrependPriInitialPath)' == ''">true</AppxPrependPriInitialPath>
    <EnableSigningChecks Condition=" '$(EnableSigningChecks)' == '' ">true</EnableSigningChecks>
    <AppxStrictManifestValidationEnabled Condition="'$(AppxStrictManifestValidationEnabled)' == ''">true</AppxStrictManifestValidationEnabled>
    <AppxFilterOutUnusedLanguagesResourceFileMaps Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' == ''">true</AppxFilterOutUnusedLanguagesResourceFileMaps>
    <AppxGeneratePrisForPortableLibrariesEnabled Condition="'$(AppxGeneratePrisForPortableLibrariesEnabled)' == ''">true</AppxGeneratePrisForPortableLibrariesEnabled>
    <AppxGeneratePackageRecipeEnabled Condition="'$(AppxGeneratePackageRecipeEnabled)' == ''">true</AppxGeneratePackageRecipeEnabled>
    <BuildOptionalProjects Condition="'$(BuildOptionalProjects)' == ''" >true</BuildOptionalProjects>
    <PackageOptionalProjectsInIdeBuilds Condition="'$(PackageOptionalProjectsInIdeBuilds)' == ''" >false</PackageOptionalProjectsInIdeBuilds>
    <AppxStreamableMainPackage Condition="'$(AppxStreamableMainPackage)' == ''">true</AppxStreamableMainPackage>
    <AppxStreamableResourcePackages Condition="'$(AppxStreamableResourcePackages)' == ''">false</AppxStreamableResourcePackages>
    <AppxExcludeXbfFromSdkPayloadWhenXamlIsPresent Condition="'$(AppxExcludeXbfFromSdkPayloadWhenXamlIsPresent)' != 'false'">true</AppxExcludeXbfFromSdkPayloadWhenXamlIsPresent>
    <AppxExcludeXamlFromLibraryLayoutsWhenXbfIsPresent Condition="'$(AppxExcludeXamlFromLibraryLayoutsWhenXbfIsPresent)' != 'false'">true</AppxExcludeXamlFromLibraryLayoutsWhenXbfIsPresent>
    <AppxRemoveRedundantCopyLocalItems Condition="'$(AppxRemoveRedundantCopyLocalItems)' != 'false'">true</AppxRemoveRedundantCopyLocalItems>
    <GenerateLibraryLayout Condition="'$(GenerateLibraryLayout)' == '' AND ('$(OutputType)' != 'AppContainerExe' AND '$(OutputType)' != 'Exe' AND '$(OutputType)' != 'WinExe')">true</GenerateLibraryLayout>
    <UseSdkBuildToolsPackage Condition="'$(UseSdkBuildToolsPackage)' == '' AND '$(WindowsSDKBuildToolsVersion)' != ''">true</UseSdkBuildToolsPackage>
    <GenerateTemporaryStoreCertificate Condition="'$(GenerateTemporaryStoreCertificate)' == ''">false</GenerateTemporaryStoreCertificate>
    <AzureCodeSigningEnabled Condition="'$(AzureCodeSigningEnabled)' == ''">false</AzureCodeSigningEnabled>
    <AzureKeyVaultEnabled Condition="'$(AzureKeyVaultEnabled)' == ''">false</AzureKeyVaultEnabled>
  </PropertyGroup>

  <PropertyGroup>
    <SdkIsRS1OrLater>false</SdkIsRS1OrLater>
    <SdkIsRS1OrLater Condition="'$(TargetPlatformVersion)' &gt;= '10.0.11000.0'">true</SdkIsRS1OrLater>
    <SdkIsRS4OrLater>false</SdkIsRS4OrLater>
    <SdkIsRS4OrLater Condition="'$(TargetPlatformVersion)' &gt;= '10.0.17000.0'">true</SdkIsRS4OrLater>
    <SdkIs22H2OrLater>false</SdkIs22H2OrLater>
    <SdkIs22H2OrLater Condition="'$(TargetPlatformVersion)' &gt;= '10.0.22621.0'">true</SdkIs22H2OrLater>
  </PropertyGroup>

  <PropertyGroup Condition="'$(UseSdkBuildToolsPackage)' == 'true'">
    <BuildToolsIs22H2OrLater>false</BuildToolsIs22H2OrLater>
    <BuildToolsIs22H2OrLater Condition="'$(WindowsSDKBuildToolsVersion)' &gt;= '10.0.22621.0'">true</BuildToolsIs22H2OrLater>
  </PropertyGroup>

  <!-- Several tasks rely on loading native dlls which are not available as arm64 in pre-22H2 versions of the SDK and build tools package.
       So if we're running as arm64 and targeting one of these older versions we have to force them to use x64 instead. -->
  <PropertyGroup Condition="'$(UseX64ToolsOnArm64OS)' == '' and '$([System.Runtime.InteropServices.RuntimeInformation]::ProcessArchitecture)' == 'arm64'">
    <UseX64ToolsOnArm64OS>true</UseX64ToolsOnArm64OS>
    <UseX64ToolsOnArm64OS Condition="'$(UseSdkBuildToolsPackage)' != 'true' and '$(SdkIs22H2OrLater)' == 'true'">false</UseX64ToolsOnArm64OS>
    <UseX64ToolsOnArm64OS Condition="'$(UseSdkBuildToolsPackage)' == 'true' and '$(BuildToolsIs22H2OrLater)' == 'true'">false</UseX64ToolsOnArm64OS>
  </PropertyGroup>

  <UsingTask Condition="'$(UseX64ToolsOnArm64OS)' == 'true'" TaskName="Microsoft.Build.AppxPackage.ValidateAppxManifest" AssemblyFile="$(AppxMSBuildTaskAssembly)" Override="true" Architecture="x64"/>
  <UsingTask Condition="'$(UseX64ToolsOnArm64OS)' == 'true'" TaskName="Microsoft.Build.AppxPackage.GenerateAppInstallerFile" AssemblyFile="$(AppxMSBuildTaskAssembly)" Override="true" Architecture="x64"/>
  <UsingTask Condition="'$(UseX64ToolsOnArm64OS)' == 'true'" TaskName="Microsoft.Windows.UI.Xaml.Build.Tasks.CompileXaml" AssemblyFile="$([MSBuild]::Unescape($(WindowsKitsPath)))\bin\$(TargetPlatformVersion)\XamlCompiler\Microsoft.Windows.UI.Xaml.Build.Tasks.dll" Override="true" Architecture="x64"/>

  <PropertyGroup>
    <AppxWinMdCacheEnabled Condition="'$(AppxWinMdCacheEnabled)' == ''">true</AppxWinMdCacheEnabled>
    <AppxWinMdCacheDir Condition="'$(AppxWinMdCacheDir)' == ''">$(IntermediateOutputPath).winmd_cache</AppxWinMdCacheDir>
  </PropertyGroup>

  <PropertyGroup>
    <_TargetPlatformIsWindowsPhone Condition="'$(TargetPlatformIdentifier)' == 'Windows Phone'">true</_TargetPlatformIsWindowsPhone>
    <_TargetPlatformIsWindowsPhone Condition="'$(TargetPlatformIdentifier)' == 'WindowsPhoneApp'">true</_TargetPlatformIsWindowsPhone>
    <_TargetPlatformIsWindowsPhone Condition="'$(_TargetPlatformIsWindowsPhone)' == ''">false</_TargetPlatformIsWindowsPhone>
  </PropertyGroup>

  <PropertyGroup>
    <AppxPackageSigningEnabled Condition="'$(AppxPackageSigningEnabled)' != 'true' and
                                          '$(PackageCertificateThumbprint)' == '' and
                                          '$(PackageCertificateKeyFile)' == ''">false</AppxPackageSigningEnabled>
    <AppxPackageSigningEnabled Condition="'$(AppxPackageSigningEnabled)' != 'false'">true</AppxPackageSigningEnabled>
  </PropertyGroup>

  <PropertyGroup Condition="'$(AzureCodeSigningDlibVersion)' != ''">
    <AzureCodeSigningEnabled>true</AzureCodeSigningEnabled>
    <SkipPublisherNameValidation>true</SkipPublisherNameValidation>
  </PropertyGroup>

  <PropertyGroup Condition="'$(AzureKeyVaultUrl)' != '' and '$(AzureKeyVaultCertificateId)' != ''">
    <AzureKeyVaultEnabled>true</AzureKeyVaultEnabled>
    <AzureKeyVaultDlibFilePath>$(VsInstallRoot)\Common7\IDE\CommonExtensions\Microsoft\TailoredProjectServices\AzureKeyVault\AzureKeyVault.Dlib.dll</AzureKeyVaultDlibFilePath>
    <SkipPublisherNameValidation>true</SkipPublisherNameValidation>
  </PropertyGroup>

  <!-- Various properties not intended for overriding. -->
  <PropertyGroup>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and  '$(SDKIdentifier)' != ''">6.3.1</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and '$(TargetPlatformVersion)' == '8.2'">6.3.0</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and '$(TargetPlatformVersion)' == '8.1' and '$(_TargetPlatformIsWindowsPhone)' == 'true'">6.3.1</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and '$(TargetPlatformVersion)' == '8.1' and '$(TargetPlatformIdentifier)' == 'Windows'">6.3.0</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == ''">6.2.1</AppxOSMinVersion>
  </PropertyGroup>

  <PropertyGroup>
    <AppxOSMaxVersionTested Condition="'$(AppxOSMaxVersionTested)' == '' and '$(SDKIdentifier)' != ''">6.4.0</AppxOSMaxVersionTested>
    <AppxOSMaxVersionTested Condition="'$(AppxOSMaxVersionTested)' == '' and '$(TargetPlatformVersion)' == '8.2'">6.4.0</AppxOSMaxVersionTested>
    <AppxOSMaxVersionTested Condition="'$(AppxOSMaxVersionTested)' == ''">$(AppxOSMinVersion)</AppxOSMaxVersionTested>
  </PropertyGroup>

  <PropertyGroup>
    <NuGetTargetFramework Condition="'$(NuGetTargetFramework)'==''">$(TargetPlatformIdentifier),Version=v$(TargetPlatformMinVersion)</NuGetTargetFramework>
    <ResolveAssemblyConflicts>true</ResolveAssemblyConflicts>

    <!--
      If we are on .NET 9 or greater (ie. if this is a UWP app with .NET 9 support), we need to drop unsupported
      runtime identifier. .NET 8 made a breaking changes with respect to RIDs for projects, which means we can't
      use 'win10' anymore, but rather we should just use 'win-' as the prefix. Additionally, several RIDs are not
      supported anymore for latest .NET, such as 'arm'. Note: while technically it is possible to also target .NET
      8 for UWP apps, here we only check for .NET 9, so that we can also indicate 'win-x86' as one of the RIDs. This
      RID is only supported starting from .NET 9. Additionally, UWP only officially supports .NET 9 and above when
      using latest .NET, so .NET 8 is not a scenario we're concerned about here.
      
      We are first checking the target platform identifier to avoid calling 'VersionGreaterThanOrEquals' for UWP
      projects using .NET Native and not latest .NET, to minimize the impact on existing projects not using .NET 9.
      We saw some small perf DDRITs regressions before when we introduced new MSBuild function calls in .targets that
      were shared with existing UWP projects, so we only want to use this when we have excluded that project type.
      UWP projects using .NET Native will always have 'UAP' as target platform identifier.
    -->
    <RuntimeIdentifiers Condition="'$(RuntimeIdentifiers)' == ''
                                   AND '$(TargetPlatformIdentifier)' == 'Windows'
                                   AND $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '9.0'))">win-x86;win-x64;win-arm64</RuntimeIdentifiers>
    <RuntimeIdentifiers Condition="'$(RuntimeIdentifiers)' == ''">win10-arm;win10-arm-aot;win10-arm64-aot;win10-x86;win10-x86-aot;win10-x64;win10-x64-aot</RuntimeIdentifiers>
  </PropertyGroup>

  <PropertyGroup Condition="'$(TargetPlatformMinVersion)'!=''">
    <AssetTargetFallback Condition="'$(TargetPlatformMinVersion)' > '10.0.15063.0'">$(AssetTargetFallback);net461</AssetTargetFallback>
  </PropertyGroup>

  <!-- If producing a reference winmd we want to use .net native -->
  <PropertyGroup>
    <ProjectNProfileEnabled Condition="'$(ProjectNProfileEnabled)' == ''">$(ProduceReferenceWinmd)</ProjectNProfileEnabled>
  </PropertyGroup>

  <PropertyGroup>
    <AppxPackageDirName Condition="'$(AppxPackageDirName)' == ''">AppPackages</AppxPackageDirName>
    <AppxPackageDirWasSpecified Condition="'$(AppxPackageDir)' != ''">true</AppxPackageDirWasSpecified>
    <AppxPackageDirInProjectDir>$(ProjectDir)$(AppxPackageDirName)\</AppxPackageDirInProjectDir>

    <PlatformSpecificBundleArtifactsListDirName Condition="'$(PlatformSpecificBundleArtifactsListDirName)' == ''">BundleArtifacts</PlatformSpecificBundleArtifactsListDirName>
    <PlatformSpecificBundleArtifactsListDirWasSpecified Condition="'$(PlatformSpecificBundleArtifactsListDir)' != ''">true</PlatformSpecificBundleArtifactsListDirWasSpecified>
    <PlatformSpecificBundleArtifactsListDirInProjectDir>$(ProjectDir)$(PlatformSpecificBundleArtifactsListDirName)\</PlatformSpecificBundleArtifactsListDirInProjectDir>
    <PlatformSpecificUploadBundleArtifactsListDirInProjectDir>$(ProjectDir)$(PlatformSpecificBundleArtifactsListDirName)Upload\</PlatformSpecificUploadBundleArtifactsListDirInProjectDir>
  </PropertyGroup>

  <!-- Various overridable properties. -->
  <PropertyGroup>
    <AppxPackageDir Condition="'$(AppxPackageDir)' == '' and '$(OutDirWasSpecified)' == 'true'">$(OutDir)$(AppxPackageDirName)\</AppxPackageDir>
    <AppxPackageDir Condition="'$(AppxPackageDir)' == ''">$(AppxPackageDirInProjectDir)</AppxPackageDir>
    <AppxManifestFileName Condition="'$(AppxManifestFileName)' == ''">AppxManifest.xml</AppxManifestFileName>
    <AppxBundleManifestFileName Condition="'$(AppxBundleManifestFileName)' == ''">AppxBundleManifest.xml</AppxBundleManifestFileName>
    <AppxPackageArtifactsDir Condition="'$(AppxPackageArtifactsDir)' == ''"></AppxPackageArtifactsDir>
    <AppxUploadPackageArtifactsDir Condition="'$(AppxUploadPackageArtifactsDir)' == ''">Upload\</AppxUploadPackageArtifactsDir>
    <ExternalPackagesDir Condition="'$(ExternalPackagesDir)' == ''">ExternalPackages\</ExternalPackagesDir>
    <FinalAppxManifestName Condition="'$(FinalAppxManifestName)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(AppxManifestFileName)</FinalAppxManifestName>
    <FinalAppxUploadManifestName Condition="'$(FinalAppxUploadManifestName)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxManifestFileName)</FinalAppxUploadManifestName>
    <FinalAppxBundleManifestName Condition="'$(FinalAppxBundleManifestName)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)AppxMetadata\$(AppxBundleManifestFileName)</FinalAppxBundleManifestName>
    <AppxValidateAppxManifest Condition="'$(AppxValidateAppxManifest)' == ''">true</AppxValidateAppxManifest>
    <AppxValidateAppxManifest Condition="'$(AppxValidateAppxManifest)' != 'true'">false</AppxValidateAppxManifest>
    <StoreManifestName Condition="'$(StoreManifestName)' == ''">StoreManifest.xml</StoreManifestName>
    <!-- AppxValidateStoreManifest isn't defined here, because the default depends on the TargetPlatform/Version -->
    <MakePriExeFullPath Condition="'$(MakePriExeFullPath)' == ''"></MakePriExeFullPath>
    <MakeAppxExeFullPath Condition="'$(MakeAppxExeFullPath)' == ''"></MakeAppxExeFullPath>
    <SignAppxPackageExeFullPath Condition="'$(SignAppxPackageExeFullPath)' == ''"></SignAppxPackageExeFullPath>
    <TempCertificateFilePath Condition="$(TempCertificateFilePath) == ''">$(IntermediateOutputPath)StoreKey_Temp.pfx</TempCertificateFilePath>
    <ResgenToolPath Condition="'$(ResgenToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</ResgenToolPath>
    <PdbCmfx64ExeFullPath Condition="'$(PdbCmfx64ExeFullPath)' == ''">$(AppxMSBuildToolsPath)\x64\mspdbcmf.exe</PdbCmfx64ExeFullPath>
    <PdbCmfx86ExeFullPath Condition="'$(PdbCmfx86ExeFullPath)' == ''">$(AppxMSBuildToolsPath)\x86\mspdbcmf.exe</PdbCmfx86ExeFullPath>
    <AppxSymbolIntermediateDir Condition="'$(AppxSymbolIntermediateDir)' == ''">$(IntermediateOutputPath)Symbols</AppxSymbolIntermediateDir>
    <AppxUploadSymbolIntermediateDir Condition="'$(AppxUploadSymbolIntermediateDir)' == ''">$(IntermediateOutputPath)Upload.Symbols</AppxUploadSymbolIntermediateDir>
    <AppxPriInitialPath Condition="'$(AppxPrependPriInitialPath)' != 'true'"></AppxPriInitialPath>
    <AppxPriInitialPath Condition="'$(AppxPrependPriInitialPath)' == 'true' and '$(AppxPackage)' == 'true' and '$(AppxPriInitialPath)' == ''"></AppxPriInitialPath>
    <AppxPriInitialPath Condition="'$(AppxPrependPriInitialPath)' == 'true' and '$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' == ''">$(TargetName)</AppxPriInitialPath>
    <ProjectPriFileName Condition="'$(AppxPackage)' == 'true' and '$(ProjectPriFileName)' == ''">resources.pri</ProjectPriFileName>
    <ProjectPriFileName Condition="'$(AppxPackage)' != 'true' and '$(ProjectPriFileName)' == '' and '$(AppxPriInitialPath)' == ''">$(TargetName).pri</ProjectPriFileName>
    <ProjectPriFileName Condition="'$(AppxPackage)' != 'true' and '$(ProjectPriFileName)' == '' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath).pri</ProjectPriFileName>
    <ProjectPriFullPath Condition="'$(ProjectPriFullPath)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectPriFileName)</ProjectPriFullPath>
    <ProjectPriUploadFullPath Condition="'$(ProjectPriUploadFullPath)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectPriFileName)</ProjectPriUploadFullPath>
    <AppxPackageRecipe Condition="'$(AppxPackageRecipe)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectName).build.appxrecipe</AppxPackageRecipe>
    <AppxUploadPackageRecipe Condition="'$(AppxUploadPackageRecipe)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectName).build.appxrecipe</AppxUploadPackageRecipe>
    <FinalAppxPackageRecipe Condition="'$(FinalAppxPackageRecipe)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectName).appxrecipe</FinalAppxPackageRecipe>
    <FinalAppxUploadPackageRecipe Condition="'$(FinalAppxUploadPackageRecipe)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectName).appxrecipe</FinalAppxUploadPackageRecipe>
    <AllowLocalNetworkLoopback Condition="'$(AllowLocalNetworkLoopback)' == ''">true</AllowLocalNetworkLoopback>
    <AppxDefaultHashAlgorithmId Condition="'$(AppxDefaultHashAlgorithmId)' == ''">sha256</AppxDefaultHashAlgorithmId>
    <AppxPackageFileMap Condition="'$(AppxPackageFileMap)' == ''">$(IntermediateOutputPath)package.map.txt</AppxPackageFileMap>
    <AppxUploadPackageFileMap Condition="'$(AppxUploadPackageFileMap)' == ''">$(IntermediateOutputPath)upload.package.map.txt</AppxUploadPackageFileMap>
    <LayoutDir Condition="'$(LayoutDir)'==''">$(TargetDir)AppX</LayoutDir>
    <ManagedWinmdInprocImplementation Condition="'$(ManagedWinmdInprocImplementation)' == ''">CLRHost.dll</ManagedWinmdInprocImplementation>
    <UseIncrementalAppxRegistration Condition="'$(UseIncrementalAppxRegistration)' == ''">true</UseIncrementalAppxRegistration>
    <AppxPackagingInfoFile Condition="'$(AppxPackagingInfoFile)' == ''">$(IntermediateOutputPath)_pkginfo.txt</AppxPackagingInfoFile>
    <AppxOSMinVersionReplaceManifestVersion Condition="'$(AppxOSMinVersionReplaceManifestVersion)' == ''">true</AppxOSMinVersionReplaceManifestVersion>
    <AppxOSMaxVersionTestedReplaceManifestVersion Condition="'$(AppxOSMaxVersionTestedReplaceManifestVersion)' == ''">true</AppxOSMaxVersionTestedReplaceManifestVersion>
    <InstallerFileWritesLogPath Condition="'$(InstallerFileWritesLogPath)' == ''">$(IntermediateOutputPath)_installerinfo.log</InstallerFileWritesLogPath>
    <PackagingFileWritesLogPath Condition="'$(PackagingFileWritesLogPath)' == ''">$(IntermediateOutputPath)PackagingFileWrites.log</PackagingFileWritesLogPath>
    <PackagingDirectoryWritesLogPath Condition="'$(PackagingDirectoryWritesLogPath)' == ''">$(IntermediateOutputPath)PackagingDirectoryWrites.log</PackagingDirectoryWritesLogPath>
    <AppxCopyLocalFilesOutputGroupIncludeXmlFiles Condition="'$(AppxCopyLocalFilesOutputGroupIncludeXmlFiles)' != 'true'">false</AppxCopyLocalFilesOutputGroupIncludeXmlFiles>
    <AppxPriConfigXmlPackagingSnippetPath Condition="'$(AppxPriConfigXmlPackagingSnippetPath)' == ''"></AppxPriConfigXmlPackagingSnippetPath>
    <AppxPriConfigXmlDefaultSnippetPath Condition="'$(AppxPriConfigXmlDefaultSnippetPath)' == ''"></AppxPriConfigXmlDefaultSnippetPath>
    <TargetPlatformSdkRootOverride Condition="'$(TargetPlatformSdkRootOverride)' == ''"></TargetPlatformSdkRootOverride>
    <TargetPlatformResourceVersion Condition="'$(TargetPlatformResourceVersion)' == ''">$(TargetPlatformVersion)</TargetPlatformResourceVersion>
    <AppxMappingFileDir Condition="'$(AppxMappingFileDir)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)</AppxMappingFileDir>
    <AppxUploadMappingFileDir Condition="'$(AppxUploadMappingFileDir)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)</AppxUploadMappingFileDir>

    <WinMetadataDir Condition="'$(WinMetadataDir)' == ''">WinMetadata</WinMetadataDir>
    <EntryPointDir Condition="'$(EntryPointDir)' == ''">entrypoint</EntryPointDir>

    <AppxManifestTargetPath Condition="'$(AppxManifestTargetPath)' == ''">$(AppxManifestFileName)</AppxManifestTargetPath>
    <DeploymentRecipeTargetPath Condition="'$(DeploymentRecipeTargetPath)' == ''">vs.appxrecipe</DeploymentRecipeTargetPath>

    <AppxBundle Condition="'$(TargetPlatformVersion)' == '8.0'">Never</AppxBundle>
    <AppxBundleDefaultValueUsed Condition="'$(AppxBundle)' == ''">true</AppxBundleDefaultValueUsed>
    <AppxBundleDefaultValueUsed Condition="'$(AppxBundleDefaultValueUsed)' == ''">false</AppxBundleDefaultValueUsed>
    <AppxBundle Condition="'$(AppxBundle)' == ''">Auto</AppxBundle>
    <AppxBundlePlatforms Condition="'$(AppxBundlePlatforms)' == ''"></AppxBundlePlatforms>
    <AppxBundleProducingPlatform Condition="'$(AppxBundleProducingPlatform)' == ''"></AppxBundleProducingPlatform>
    <AppxBundleResourcePacksProducingPlatform Condition="'$(AppxBundleResourcePacksProducingPlatform)' == ''"></AppxBundleResourcePacksProducingPlatform>
    <AppxLayoutFolderName Condition="'$(AppxLayoutFolderName)' == ''">PackageLayout</AppxLayoutFolderName>
    <IntermediateUploadOutputPath Condition="'$(IntermediateUploadOutputPath)' == ''">$(IntermediateOutputPath)Upload\</IntermediateUploadOutputPath>
    <AppxUploadPackagingInfoFile Condition="'$(AppxUploadPackagingInfoFile)' == ''">$(IntermediateUploadOutputPath)_upkginfo.txt</AppxUploadPackagingInfoFile>
    <AppxLayoutDir Condition="'$(AppxLayoutDir)' == ''">$(IntermediateOutputPath)$(AppxLayoutFolderName)\</AppxLayoutDir>
    <AppxUploadLayoutFolderName Condition="'$(AppxUploadLayoutFolderName)' == ''">PackageUploadLayout</AppxUploadLayoutFolderName>
    <AppxUploadLayoutDir Condition="'$(AppxUploadLayoutDir)' == ''">$(IntermediateOutputPath)$(AppxUploadLayoutFolderName)</AppxUploadLayoutDir>
    <AppxBundleSplitResourcesPriPrefix Condition="'$(AppxBundleSplitResourcesPriPrefix)' == ''">split</AppxBundleSplitResourcesPriPrefix>
    <AppxBundlePriConfigXmlForSplittingFileName Condition="'$(AppxBundlePriConfigXmlForSplittingFileName)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).priconfig.xml</AppxBundlePriConfigXmlForSplittingFileName>
    <AppxUploadBundlePriConfigXmlForSplittingFileName Condition="'$(AppxUploadBundlePriConfigXmlForSplittingFileName)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).priconfig.xml</AppxUploadBundlePriConfigXmlForSplittingFileName>
    <AppxBundleAutoResourcePackageQualifiers Condition="'$(AppxBundleAutoResourcePackageQualifiers)' == ''">Language|Scale|DXFeatureLevel</AppxBundleAutoResourcePackageQualifiers>
    <AppxBundleSplitResourcesPriPath Condition="'$(AppxBundleSplitResourcesPriPath)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).pri</AppxBundleSplitResourcesPriPath>
    <AppxBundleSplitResourcesGeneratedFilesListPath Condition="'$(AppxBundleSplitResourcesGeneratedFilesListPath)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).generatedFiles.txt</AppxBundleSplitResourcesGeneratedFilesListPath>
    <AppxBundleSplitResourcesQualifiersPath Condition="'$(AppxBundleSplitResourcesQualifiersPath)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).qualifiers.txt</AppxBundleSplitResourcesQualifiersPath>
    <AppxUploadBundleSplitResourcesPriPath Condition="'$(AppxUploadBundleSplitResourcesPriPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).pri</AppxUploadBundleSplitResourcesPriPath>
    <AppxUploadBundleSplitResourcesGeneratedFilesListPath Condition="'$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).generatedFiles.txt</AppxUploadBundleSplitResourcesGeneratedFilesListPath>
    <AppxUploadBundleSplitResourcesQualifiersPath Condition="'$(AppxUploadBundleSplitResourcesQualifiersPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).qualifiers.txt</AppxUploadBundleSplitResourcesQualifiersPath>
    <AppxBundlePriConfigXmlForMainPackageFileMapFileName Condition="'$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)' == ''">$(IntermediateOutputPath)filemap.priconfig.xml</AppxBundlePriConfigXmlForMainPackageFileMapFileName>
    <AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName Condition="'$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)' == ''">$(IntermediateUploadOutputPath)filemap.priconfig.xml</AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName>
    <AppxBundleMainPackageFileMapIntermediatePrefix Condition="'$(AppxBundleMainPackageFileMapIntermediatePrefix)' == ''">filemap</AppxBundleMainPackageFileMapIntermediatePrefix>
    <AppxBundleMainPackageFileMapSuffix Condition="'$(AppxBundleMainPackageFileMapSuffix)' == ''">.map</AppxBundleMainPackageFileMapSuffix>
    <AppxBundleMainPackageFileMapIntermediatePath Condition="'$(AppxBundleMainPackageFileMapIntermediatePath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxBundleMainPackageFileMapIntermediatePath>
    <AppxBundleMainPackageFileMapIntermediatePriPath Condition="'$(AppxBundleMainPackageFileMapIntermediatePriPath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).pri</AppxBundleMainPackageFileMapIntermediatePriPath>
    <AppxBundleMainPackageFileMapGeneratedFilesListPath Condition="'$(AppxBundleMainPackageFileMapGeneratedFilesListPath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).generatedFiles.txt</AppxBundleMainPackageFileMapGeneratedFilesListPath>
    <AppxBundleMainPackageFileMapPrefix Condition="'$(AppxBundleMainPackageFileMapPrefix)' == ''">main</AppxBundleMainPackageFileMapPrefix>
    <AppxBundleMainPackageFileMapPath Condition="'$(AppxBundleMainPackageFileMapPath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapPrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxBundleMainPackageFileMapPath>
    <AppxUploadBundleMainPackageFileMapIntermediatePath Condition="'$(AppxUploadBundleMainPackageFileMapIntermediatePath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxUploadBundleMainPackageFileMapIntermediatePath>
    <AppxUploadBundleMainPackageFileMapIntermediatePriPath Condition="'$(AppxUploadBundleMainPackageFileMapIntermediatePriPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).pri</AppxUploadBundleMainPackageFileMapIntermediatePriPath>
    <AppxUploadBundleMainPackageFileMapGeneratedFilesListPath Condition="'$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).generatedFiles.txt</AppxUploadBundleMainPackageFileMapGeneratedFilesListPath>
    <AppxUploadBundleMainPackageFileMapPath Condition="'$(AppxUploadBundleMainPackageFileMapPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapPrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxUploadBundleMainPackageFileMapPath>
    <AppxBundleFolderSuffix Condition="'$(AppxBundleFolderSuffix)' == ''">_Bundle</AppxBundleFolderSuffix>

    <AppxLayoutFileName Condition="'$(AppxLayoutFileName)' == ''">App.packagelayout</AppxLayoutFileName>
    <UseAppxLayout Condition="'$(UseAppxLayout)' == ''">false</UseAppxLayout>
    <AppxLayoutIsTemplate Condition="'$(AppxLayoutIsTemplate)' == ''">false</AppxLayoutIsTemplate>

    <AppInstallerTemplateFileName Condition="'$(AppInstallerTemplateFileName)' == ''">Package.appinstaller</AppInstallerTemplateFileName>

    <PlatformAppxLayoutFileName>PackageLayout_{0}.xml</PlatformAppxLayoutFileName>
    <PlatformAppxLayoutFile Condition="'$(PlatformAppxLayoutFile)' == ''">$(PlatformSpecificBundleArtifactsListDirInProjectDir)$(PlatformAppxLayoutFileName)</PlatformAppxLayoutFile>
    <PlatformAppxLayoutUploadFile Condition="'$(PlatformAppxLayoutUploadFile)' == ''">$(PlatformSpecificUploadBundleArtifactsListDirInProjectDir)$(PlatformAppxLayoutFileName)</PlatformAppxLayoutUploadFile>

    <FinalAppxLayoutFileName>PackageLayout.xml</FinalAppxLayoutFileName>
    <FinalAppxLayoutFile Condition="'$(FinalAppxLayoutFile)' == ''">$(PlatformSpecificBundleArtifactsListDirInProjectDir)$(FinalAppxLayoutFileName)</FinalAppxLayoutFile>
    <FinalAppxLayoutUploadFile Condition="'$(FinalAppxLayoutUploadFile)' == ''">$(PlatformSpecificUploadBundleArtifactsListDirInProjectDir)$(FinalAppxLayoutFileName)</FinalAppxLayoutUploadFile>

    <PlatformSpecificBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDir)' == '' and '$(OutDirWasSpecified)' == 'true'">$(OutDir)$(PlatformSpecificBundleArtifactsListDirName)\</PlatformSpecificBundleArtifactsListDir>
    <PlatformSpecificBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDir)' == ''">$(PlatformSpecificBundleArtifactsListDirInProjectDir)</PlatformSpecificBundleArtifactsListDir>

    <!-- Continue to honor the UapDefaultAssetScale property for compat reasons.  But going forward advertise the property "AppxDefaultResourceQualifierUAP_{ValueName} as the desired override property. -->
    <UapDefaultAssetScale Condition="'$(UapDefaultAssetScale)' == ''">200</UapDefaultAssetScale>
    <AppxDefaultResourceQualifierUAP_Scale Condition="'$(AppxDefaultResourceQualifierUAP_Scale)' == ''">$(UapDefaultAssetScale)</AppxDefaultResourceQualifierUAP_Scale>

    <AppxDefaultResourceQualifierUAP_Language Condition="'$(AppxDefaultResourceQualifierUAP_Language)' == ''">{DefaultResourceLanguage}</AppxDefaultResourceQualifierUAP_Language>
    <AppxDefaultResourceQualifierUAP_Contrast Condition="'$(AppxDefaultResourceQualifierUAP_Contrast)' == ''">standard</AppxDefaultResourceQualifierUAP_Contrast>
    <AppxDefaultResourceQualifierUAP_HomeRegion Condition="'$(AppxDefaultResourceQualifierUAP_HomeRegion)' == ''">001</AppxDefaultResourceQualifierUAP_HomeRegion>
    <AppxDefaultResourceQualifierUAP_TargetSize Condition="'$(AppxDefaultResourceQualifierUAP_TargetSize)' == ''">256</AppxDefaultResourceQualifierUAP_TargetSize>
    <AppxDefaultResourceQualifierUAP_LayoutDirection Condition="'$(AppxDefaultResourceQualifierUAP_LayoutDirection)' == ''">LTR</AppxDefaultResourceQualifierUAP_LayoutDirection>
    <AppxDefaultResourceQualifierUAP_DxFeatureLevel Condition="'$(AppxDefaultResourceQualifierUAP_DxFeatureLevel)' == ''">DX9</AppxDefaultResourceQualifierUAP_DxFeatureLevel>
    <AppxDefaultResourceQualifierUAP_Platform Condition="'$(AppxDefaultResourceQualifierUAP_Platform)' == ''">UAP</AppxDefaultResourceQualifierUAP_Platform>

    <DisableAppxManifestItemPackageContentValidation Condition="'$(DisableAppxManifestItemPackageContentValidation)' == ''">false</DisableAppxManifestItemPackageContentValidation>
    <RemoveNonLayoutFiles Condition="'$(RemoveNonLayoutFiles)' == ''">true</RemoveNonLayoutFiles>
    <IncludeLayoutFilesInPackage Condition="'$(IncludeLayoutFilesInPackage)' == ''">false</IncludeLayoutFilesInPackage>
    <AppxSubfolderWithFilesToBeEmbedded Condition="'$(AppxSubfolderWithFilesToBeEmbedded)' == ''">embed</AppxSubfolderWithFilesToBeEmbedded>

    <AppxLogTelemetryFromSideloadingScript Condition="'$(AppxLogTelemetryFromSideloadingScript)' == ''">true</AppxLogTelemetryFromSideloadingScript>

    <AppxExcludeArmFrameworkSdkPackagesFromLayout Condition="'$(AppxExcludeArmFrameworkSdkPackagesFromLayout)' == ''">false</AppxExcludeArmFrameworkSdkPackagesFromLayout>
    <AppxExcludeX86FrameworkSdkPackagesFromLayout Condition="'$(AppxExcludeX86FrameworkSdkPackagesFromLayout)' == ''">false</AppxExcludeX86FrameworkSdkPackagesFromLayout>
  </PropertyGroup>

  <PropertyGroup>
    <AppxDefaultResourceQualifiers_Windows_80>Language={DefaultResourceLanguage}</AppxDefaultResourceQualifiers_Windows_80>
    <AppxDefaultResourceQualifiers_Windows_81>Language={DefaultResourceLanguage}|Contrast=standard|Scale=100|HomeRegion=001|TargetSize=256|LayoutDirection=LTR|DXFeatureLevel=DX9|Configuration=|AlternateForm=</AppxDefaultResourceQualifiers_Windows_81>
    <AppxDefaultResourceQualifiers_Windows_Phone>Language={DefaultResourceLanguage}|Contrast=standard|Scale=240|HomeRegion=001|TargetSize=256|LayoutDirection=LTR|DXFeatureLevel=DX9|Theme=Dark|AlternateForm=</AppxDefaultResourceQualifiers_Windows_Phone>
    <AppxDefaultResourceQualifiers_Windows_82>Language={DefaultResourceLanguage}|Contrast=standard|Scale=100|HomeRegion=001|TargetSize=256|LayoutDirection=LTR|DXFeatureLevel=DX9|Configuration=|AlternateForm=</AppxDefaultResourceQualifiers_Windows_82>
    <AppxDefaultResourceQualifiers_UAP>Language=$(AppxDefaultResourceQualifierUAP_Language)|Contrast=$(AppxDefaultResourceQualifierUAP_Contrast)|Scale=$(AppxDefaultResourceQualifierUAP_Scale)|HomeRegion=$(AppxDefaultResourceQualifierUAP_HomeRegion)|TargetSize=$(AppxDefaultResourceQualifierUAP_TargetSize)|LayoutDirection=$(AppxDefaultResourceQualifierUAP_LayoutDirection)|DXFeatureLevel=$(AppxDefaultResourceQualifierUAP_DxFeatureLevel)|Configuration=$(AppxDefaultResourceQualifierUAP_Configuration)|AlternateForm=$(AppxDefaultResourceQualifierUAP_AlternateForm)|Platform=$(AppxDefaultResourceQualifierUAP_Platform)</AppxDefaultResourceQualifiers_UAP>
  </PropertyGroup>

  <PropertyGroup Condition="'$(AppxDefaultResourceQualifiers)' == ''">
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.0'">$(AppxDefaultResourceQualifiers_Windows_80)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.1'">$(AppxDefaultResourceQualifiers_Windows_81)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.2'">$(AppxDefaultResourceQualifiers_Windows_82)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Portable'">$(AppxDefaultResourceQualifiers_Windows_81)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(SDKIdentifier)' != ''">$(AppxDefaultResourceQualifiers_UAP)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">$(AppxDefaultResourceQualifiers_Windows_Phone)</AppxDefaultResourceQualifiers>
  </PropertyGroup>

  <PropertyGroup Condition="'$(AppxOmitSchemaFromResourcePacks)' == ''">
    <AppxOmitSchemaFromResourcePacks Condition="'$(TargetPlatformIdentifier)' == 'UAP'">true</AppxOmitSchemaFromResourcePacks>
    <AppxOmitSchemaFromResourcePacks Condition="'$(TargetPlatformIdentifier)' != 'UAP'">false</AppxOmitSchemaFromResourcePacks>
  </PropertyGroup>

  <!-- If value is still not set, it is a platform yet unknown to us. -->
  <!-- Default to same value as for latest version of Windows.        -->
  <PropertyGroup Condition="'$(AppxDefaultResourceQualifiers)' == ''">
    <AppxDefaultResourceQualifiers>$(AppxDefaultResourceQualifiers_UAP)</AppxDefaultResourceQualifiers>
  </PropertyGroup>

  <ItemGroup>
    <AppxHashUri Include="http://www.w3.org/2001/04/xmlenc#sha256">
      <Id>SHA256</Id>
    </AppxHashUri>
    <AppxHashUri Include="http://www.w3.org/2001/04/xmlenc#sha384">
      <Id>SHA384</Id>
    </AppxHashUri>
    <AppxHashUri Include="http://www.w3.org/2001/04/xmlenc#sha512">
      <Id>SHA512</Id>
    </AppxHashUri>
  </ItemGroup>

  <PropertyGroup>
    <StandardBuildPipeline>1.0</StandardBuildPipeline>
    <UapBuildPipeline>2.0</UapBuildPipeline>
    <AppxPackagePipelineVersion>$(StandardBuildPipeline)</AppxPackagePipelineVersion>
    <AppxPackagePipelineVersion Condition="'$(SDKIdentifier)' != ''">$(UapBuildPipeline)</AppxPackagePipelineVersion>
  </PropertyGroup>

  <PropertyGroup>
    <AppxLayoutEnabled Condition="'$(AppxLayoutEnabled)' != 'false' and
                                  '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and
                                  '$(SdkIsRS4OrLater)' == 'true'">true</AppxLayoutEnabled>
    <AppxLayoutEnabled Condition="'$(AppxLayoutEnabled)' != 'true'">false</AppxLayoutEnabled>
  </PropertyGroup>

  <PropertyGroup>
    <AppxPackageEncryptionEnabled Condition="'$(AppxPackageEncryptionEnabled)' == '' or '$(SdkIsRS1OrLater)' != 'true'">false</AppxPackageEncryptionEnabled>
  </PropertyGroup>

  <!-- Backwards compatablity with PreDev16 work. Use properties below for a more clear workflow and better named variables. -->
  <PropertyGroup>
    <UapAppxPackageBuildModeStoreUploadLegacy>StoreUpload</UapAppxPackageBuildModeStoreUploadLegacy>
    <UapAppxPackageBuildModeCI>CI</UapAppxPackageBuildModeCI>
  </PropertyGroup>

  <PropertyGroup>
    <UapAppxPackageBuildModeSideloadOnly>SideloadOnly</UapAppxPackageBuildModeSideloadOnly>
    <UapAppxPackageBuildModeStoreAndSideload>StoreAndSideload</UapAppxPackageBuildModeStoreAndSideload>
    <UapAppxPackageBuildModeStoreOnly>StoreOnly</UapAppxPackageBuildModeStoreOnly>
  </PropertyGroup>

  <PropertyGroup>
    <UapAppxPackageBuildModeIsValid>false</UapAppxPackageBuildModeIsValid>
  </PropertyGroup>

  <!--If UapAppxPackageBuildMode is set to UapAppxPackageBuildModeStoreUploadLegacy or the new flag UapAppxPackageBuildModeStoreAndSideload, prep all the appropriate flags to produce an appxupload & sideload package-->
  <PropertyGroup Condition="('$(UapAppxPackageBuildMode)' == '$(UapAppxPackageBuildModeStoreAndSideload)' or '$(UapAppxPackageBuildMode)' == '$(UapAppxPackageBuildModeStoreUploadLegacy)') and
                            '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and
                            '$(UseDotNetNativeToolchain)' != 'false' and
                            '$(Configuration)' != 'Debug'">
    <UapAppxPackageBuildModeIsValid>true</UapAppxPackageBuildModeIsValid>
    <BuildAppxUploadPackageForUap>true</BuildAppxUploadPackageForUap>
    <BuildAppxSideloadPackageForUap>true</BuildAppxSideloadPackageForUap>
    <AppxPackageIsForStore>true</AppxPackageIsForStore>
  </PropertyGroup>

  <!--If UapAppxPackageBuildMode is set to UapAppxPackageBuildModeSideloadOnly, prep all the appropriate flags to produce an appx sideload package-->
  <PropertyGroup Condition="'$(UapAppxPackageBuildMode)' == '$(UapAppxPackageBuildModeSideloadOnly)' and
                            '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
    <UapAppxPackageBuildModeIsValid>true</UapAppxPackageBuildModeIsValid>
    <BuildAppxUploadPackageForUap>false</BuildAppxUploadPackageForUap>
    <BuildAppxSideloadPackageForUap>true</BuildAppxSideloadPackageForUap>
    <AppxPackageIsForStore>false</AppxPackageIsForStore>
  </PropertyGroup>

  <!--If UapAppxPackageBuildMode is set to UapAppxPackageBuildModeStore or UapAppxPackageBuildModeCI, prep all the appropriate flags to produce an APPX for store upload only-->
  <PropertyGroup Condition="('$(UapAppxPackageBuildMode)' == '$(UapAppxPackageBuildModeStoreOnly)' or '$(UapAppxPackageBuildMode)' == '$(UapAppxPackageBuildModeCI)') and
                            '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
    <UapAppxPackageBuildModeIsValid>true</UapAppxPackageBuildModeIsValid>

    <BuildAppxUploadPackageForUap>false</BuildAppxUploadPackageForUap>
    <BuildAppxUploadPackageForUap Condition="'$(UseDotNetNativeToolchain)' != 'false' and '$(Configuration)' != 'Debug'">true</BuildAppxUploadPackageForUap>

    <AppxPackageIsForStore>false</AppxPackageIsForStore>
    <AppxPackageIsForStore Condition="'$(UseDotNetNativeToolchain)' != 'false' and '$(Configuration)' != 'Debug'">true</AppxPackageIsForStore>

    <BuildAppxSideloadPackageForUap>false</BuildAppxSideloadPackageForUap>
  </PropertyGroup>

  <!-- Combined checks to see if we should run the store-publishing steps added for the UAP flow. -->
  <PropertyGroup>
    <BuildAppxUploadPackageForUap Condition="'$(BuildAppxUploadPackageForUap)' == '' and
                                             '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and
                                             '$(UseDotNetNativeToolchain)' != 'false' and
                                             '$(Configuration)' != 'Debug' and
                                             '$(AppxPackageIsForStore)' == 'true'">true</BuildAppxUploadPackageForUap>
    <BuildAppxUploadPackageForUap Condition="'$(BuildAppxUploadPackageForUap)' == ''">false</BuildAppxUploadPackageForUap>
  </PropertyGroup>

  <!-- Combined checks to see if we should run the sideload steps added -->
  <PropertyGroup>
    <BuildAppxSideloadPackageForUap Condition="'$(BuildAppxSideloadPackageForUap)' == '' and
                                             '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">true</BuildAppxSideloadPackageForUap>
    <BuildAppxSideloadPackageForUap Condition="'$(BuildAppxSideloadPackageForUap)' == ''">false</BuildAppxSideloadPackageForUap>
  </PropertyGroup>

  <!-- If packaging for the store, force package encryption to be skipped -->
  <PropertyGroup>
    <AppxPackageEncryptionEnabled Condition="'$(AppxPackageIsForStore)' == 'true'">false</AppxPackageEncryptionEnabled>
  </PropertyGroup>

  <!-- Calculate whether to allow debug framework references in app manifest.    -->
  <!-- Allow overriding this from command line or user config file if necessary. -->

  <PropertyGroup Condition="'$(AppxPackageAllowDebugFrameworkReferencesInManifest)' == ''">

    <!-- Allow debug framework references when not packaging for the store. -->
    <AppxPackageAllowDebugFrameworkReferencesInManifest Condition="'$(AppxPackageIsForStore)' != 'true'">true</AppxPackageAllowDebugFrameworkReferencesInManifest>
    <AppxPackageAllowDebugFrameworkReferencesInManifest Condition="'$(AppxPackageAllowDebugFrameworkReferencesInManifest)' == ''">false</AppxPackageAllowDebugFrameworkReferencesInManifest>

  </PropertyGroup>

  <!--
        When building on the command line or in TFS (determined by looking at the $(BuildingInsideVisualStudio) property), if build is invoked on an
        app package-producing project, the package for the project will be produced as part of building the project without specifying any additional
        flags or targets. This is control by an MSBuild property named GenerateAppxPackageOnBuild which is set to true by default.

        If $(BuildingInsideVisualStudio) = false and $(GenerateAppxPackageOnBuild) = true, then build will also produce a package.
    -->

  <PropertyGroup>
    <GenerateAppxPackageOnBuild Condition="'$(AppxPackage)' == 'true' and '$(GenerateAppxPackageOnBuild)' == '' and '$(BuildingInsideVisualStudio)' != 'true'">true</GenerateAppxPackageOnBuild>
  </PropertyGroup>

  <PropertyGroup>
    <_OverriddenDisableXbf>false</_OverriddenDisableXbf>
    <_OverriddenDisableXbf Condition="'$(DisableEmbeddedXbf)' != ''">true</_OverriddenDisableXbf>
  </PropertyGroup>

  <PropertyGroup Condition="'$(_OverriddenDisableXbf)' == 'false'">
    <DisableEmbeddedXbf Condition="'$(GenerateAppxPackageOnBuild)' == 'true'">false</DisableEmbeddedXbf>
    <DisableEmbeddedXbf Condition="'$(GenerateAppxPackageOnBuild)' != 'true'">true</DisableEmbeddedXbf>
    <DisableEmbeddedXbf Condition="'$(Configuration)'!='Debug'">false</DisableEmbeddedXbf>
  </PropertyGroup>

  <PropertyGroup>
    <UseSubFolderForOutputDirDuringMultiPlatformBuild Condition="'$(UseSubFolderForOutputDirDuringMultiPlatformBuild)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">true</UseSubFolderForOutputDirDuringMultiPlatformBuild>
    <UseSubFolderForOutputDirDuringMultiPlatformBuild Condition="'$(UseSubFolderForOutputDirDuringMultiPlatformBuild)' == ''">false</UseSubFolderForOutputDirDuringMultiPlatformBuild>
  </PropertyGroup>

  <!-- Names of the files which are allways present on the machine and should not be part of the payload. -->
  <ItemGroup>
    <AppxSystemBinary Include="CLRHost.dll" />
    <AppxSystemBinary Include="CLRHost.exe" />
    <AppxSystemBinary Include="WWAHost.exe" />
  </ItemGroup>

  <!-- Reserved file names which cannot appear in the package. -->
  <ItemGroup>
    <AppxReservedFileName Include="$(AppxManifestFileName)" />
    <AppxReservedFileName Include="AppxBlockMap.xml" />
    <AppxReservedFileName Include="[Content_Types].xml" />
    <AppxReservedFileName Include="AppxSignature.p7x" />
    <AppxReservedFileName Include="Microsoft.System.Package.Metadata" />
  </ItemGroup>

  <!-- XPath queries used to extract file names from the manifest. -->
  <ItemGroup>
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:InProcessServer/m:Path" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:OutOfProcessServer/m:Path" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:ProxyStub/m:Path" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:GameExplorer/@GameDefinitionContainer" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:Certificates/m:Certificate/@Content" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Applications/m:Application/@Executable" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Applications/m:Application/m:Extensions/m:Extension/@Executable" />
  </ItemGroup>

  <ItemGroup Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:DefaultTile/@Square71x71Logo">
      <DescriptionID>Square71x71Logo</DescriptionID>
      <ExpectedScaleDimensions>400:284x284;200:142x142;100:71x71;150:107x107;125:89x89</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/@Square150x150Logo">
      <DescriptionID>Square150x150Logo</DescriptionID>
      <ExpectedScaleDimensions>400:600x600;200:300x300;100:150x150;150:225x225;125:188x188</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:DefaultTile/@Wide310x150Logo">
      <DescriptionID>Wide310x150Logo</DescriptionID>
      <ExpectedScaleDimensions>400:1240x600;200:620x300;100:310x150;150:465x225;125:388x188</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:DefaultTile/@Square310x310Logo">
      <DescriptionID>Square310x310Logo</DescriptionID>
      <ExpectedScaleDimensions>400:1240x1240;200:620x620;100:310x310;150:465x465;125:388x388</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/@Square44x44Logo">
      <DescriptionID>SmallLogo</DescriptionID>
      <ExpectedScaleDimensions>400:176x176;200:88x88;100:44x44;150:66x66;125:55x55</ExpectedScaleDimensions>
      <ExpectedTargetSizes>16;24;48;256</ExpectedTargetSizes>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Properties/m:Logo">
      <DescriptionID>StoreLogo</DescriptionID>
      <ExpectedScaleDimensions>400:200x200;200:100x100;150:75x75;125:63x63;100:50x50</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:LockScreen/@BadgeLogo">
      <DescriptionID>BadgeLogo</DescriptionID>
      <ExpectedScaleDimensions>400:96x96;200:48x48;150:36x36;125:30x30;100:24x24</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:SplashScreen/@Image">
      <DescriptionID>SplashScreen</DescriptionID>
      <ExpectedScaleDimensions>400:2480x1200;200:1240x600;150:930x450;125:775x375;100:620x300</ExpectedScaleDimensions>
    </AppxManifestImageFileNameQuery>
  </ItemGroup>

  <ItemGroup Condition="'$(BuildingInsideVisualStudio)'=='true'">
    <AvailableItemName Include="AppxSourceContentGroupMap" />
  </ItemGroup>

  <!-- The reverse map needs to be added only in appx bundles and only on F5. -->
  <PropertyGroup Condition="'$(InsertReverseMap)' == ''">
    <InsertReverseMap Condition="'$(AppxBundle)' == 'Always' or '$(AppxBundle)' == 'Auto'">true</InsertReverseMap>
    <InsertReverseMap Condition="'$(InsertReverseMap)' == '' or '$(GenerateAppxPackageOnBuild)' == 'true' or '$(OutputType)' != 'WindowsWebApplication'">false</InsertReverseMap>
  </PropertyGroup>

  <PropertyGroup>
    <_ProjectPriFullPathOriginal>$(ProjectPriFullPath)</_ProjectPriFullPathOriginal>
  </PropertyGroup>

  <PropertyGroup Condition="'$(InsertReverseMap)' == 'true'">
    <_ReverseMapProjectPriDirectory>$([System.IO.Path]::GetDirectoryName('$(ProjectPriFullPath)'))\ReverseMap\</_ReverseMapProjectPriDirectory>
    <_ReverseMapProjectPriFileName>$([System.IO.Path]::GetFileName('$(ProjectPriFullPath)'))</_ReverseMapProjectPriFileName>
    <ProjectPriFullPath>$(_ReverseMapProjectPriDirectory)$(_ReverseMapProjectPriFileName)</ProjectPriFullPath>
  </PropertyGroup>

  <PropertyGroup Condition="'$(InsertReverseMap)' == 'true' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
    <_ReverseMapProjectPriUploadDirectory>$([System.IO.Path]::GetDirectoryName('$(ProjectPriUploadFullPath)'))\ReverseMap\</_ReverseMapProjectPriUploadDirectory>
    <_ReverseMapProjectPriUploadFileName>$([System.IO.Path]::GetFileName('$(ProjectPriUploadFullPath)'))</_ReverseMapProjectPriUploadFileName>
    <ProjectPriUploadFullPath>$(_ReverseMapProjectPriUploadDirectory)$(_ReverseMapProjectPriUploadFileName)</ProjectPriUploadFullPath>
  </PropertyGroup>

  <!-- This property is used to trigger a perf optimization in the CreatePriFilesForPortableLibraries task. -->
  <!-- When true we will skip generating an intermediate pri file in certain cases and instead just specify -->
  <!-- the resource file when generating the project's final pri file.                                      -->
  <PropertyGroup Condition="'$(SkipIntermediatePriGenerationForResourceFiles)' == ''">
    <SkipIntermediatePriGenerationForResourceFiles Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">true</SkipIntermediatePriGenerationForResourceFiles>
    <SkipIntermediatePriGenerationForResourceFiles Condition="'$(SkipIntermediatePriGenerationForResourceFiles)' == ''">false</SkipIntermediatePriGenerationForResourceFiles>
  </PropertyGroup>

  <!-- WinMDExp.exe and AL.exe are tools that we need for building WinMD files and resource files respectively.  They usually  -->
  <!-- ship as part of the .Net SDK, but we point the common targets to our own copies so we don't require that dependency.    -->
  <PropertyGroup>
    <WinMdExpToolPath Condition="'$(WinMdExpToolPath)' == '' and EXISTS( '$(AppxMSBuildToolsPath)WinMDExp.exe' ) ">$(AppxMSBuildToolsPath)</WinMdExpToolPath>
    <AlToolPath Condition="'$(AlToolPath)' == '' and EXISTS( '$(AppxMSBuildToolsPath)Al.exe' ) ">$(AppxMSBuildToolsPath)</AlToolPath>
  </PropertyGroup>

  <!-- Manifest metadata items. -->

  <!-- Those will be transformed into Name/Value or Name/Version pairs as follows:                         -->
  <!--                                                                                                     -->
  <!-- If identity of the item (attribute 'Include') points to existing file and there is                  -->
  <!-- no supplied value or version, file version of given file will be extracted and stored               -->
  <!-- as Version attribute of metadata with name equal to file name and extension.                        -->
  <!--                                                                                                     -->
  <!-- If item has metadata 'Value', then it is directly stored in the manifest as name/value pair.        -->
  <!-- If item has metadata 'Version', then it is directly stored in the manifest as name/version pair.    -->
  <!--                                                                                                     -->
  <!-- If metadata 'Name' is supplied, it will be used instead of identity of the item. This is useful     -->
  <!-- if we use binary to extract file version, but want to give it different name in generated manifest. -->

  <ItemGroup Label="AppxManifestMetadata">

    <AppxManifestMetaData Include="SharedGUID" Condition="'$(SharedGUID)' != ''">
      <Value>$(SharedGUID)</Value>
    </AppxManifestMetaData>

    <AppxManifestMetaData Include="CodeSharingProject" Condition=" '$(HasSharedItems)' == 'true' or '$(CodeSharingProject)' != '' ">
      <Value Condition=" '$(CodeSharingProject)' != '' ">$(CodeSharingProject)</Value>
      <Value Condition=" '$(CodeSharingProject)' == '' ">248F659F-DAC5-46E8-AC09-60EC9FC95053</Value>
    </AppxManifestMetaData>

    <AppxManifestMetadata Include="TargetFrameworkMoniker" Condition="'$(TargetFrameworkMoniker)' != ''">
      <Value>$(TargetFrameworkMoniker)</Value>
    </AppxManifestMetadata>

    <AppxManifestMetadata Include="VisualStudio">
      <Version>$(VisualStudioVersion)</Version>
    </AppxManifestMetadata>

    <AppxManifestMetadata Include="VisualStudioEdition" Condition="'$(VisualStudioEdition)' != ''">
      <Value>$(VisualStudioEdition)</Value>
    </AppxManifestMetadata>

    <AppxManifestMetadata Include="$(ComSpec)">
      <Name>OperatingSystem</Name>
    </AppxManifestMetadata>

    <AppxManifestMetadata Include="$(AppxMSBuildToolsPath)Microsoft.Build.AppxPackage.dll" />

    <AppxManifestMetaData Include="ProjectGUID" Condition="'$(ProjectGUID)' != ''">
      <Value>$(ProjectGUID)</Value>
    </AppxManifestMetaData>

  </ItemGroup>

  <Import Project="$(MSBuildProjectDirectory)\Microsoft.AppxPackage.Metadata.Overrides.props" Condition="EXISTS( '$(MSBuildProjectDirectory)\Microsoft.AppxPackage.Metadata.Overrides.props' )"/>

  <!-- Mapping between OS version (6.*) and marketing version string. -->
  <!-- There is no guarantee that NTVersion always consists of first two parts of OSVersion, hence a separate field. -->
  <ItemGroup>
    <PlatformVersionDescription Include="Windows 8.0">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.0</TargetPlatformVersion>
      <OSDescription>Windows 8.0</OSDescription>
      <OSVersion>6.2.1</OSVersion>
      <NTVersion>6.2</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows 8.1">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.1</TargetPlatformVersion>
      <OSDescription>Windows 8.1</OSDescription>
      <OSVersion>6.3.0</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows Phone 8.1">
      <TargetPlatformIdentifier>WindowsPhoneApp</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.1</TargetPlatformVersion>
      <OSDescription>Windows Phone 8.1</OSDescription>
      <OSVersion>6.3.1</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows Phone Silverlight 8.1">
      <TargetPlatformIdentifier>Windows Phone</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.1</TargetPlatformVersion>
      <OSDescription>Windows Phone 8.1</OSDescription>
      <OSVersion>6.3.1</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows 8.2">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.2</TargetPlatformVersion>
      <OSDescription>Windows 8.2</OSDescription>
      <OSVersion>6.3.0</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="UAP 1.0">
      <TargetPlatformIdentifier>UAP</TargetPlatformIdentifier>
      <TargetPlatformVersion>0.8.0.0</TargetPlatformVersion>
      <OSDescription>Windows 10.0</OSDescription>
      <OSVersion>10.0.0</OSVersion>
      <NTVersion>10.0</NTVersion>
    </PlatformVersionDescription>
  </ItemGroup>

  <!-- Packaging output group default values -->
  <PropertyGroup>
    <IncludeBuiltProjectOutputGroup Condition="'$(IncludeBuiltProjectOutputGroup)' == ''">true</IncludeBuiltProjectOutputGroup>
    <IncludeDebugSymbolsProjectOutputGroup Condition="'$(IncludeDebugSymbolsProjectOutputGroup)' == ''">true</IncludeDebugSymbolsProjectOutputGroup>
    <IncludeDocumentationProjectOutputGroup Condition="'$(IncludeDocumentationProjectOutputGroup)' == ''">false</IncludeDocumentationProjectOutputGroup>
    <IncludeSatelliteDllsProjectOutputGroup Condition="'$(IncludeSatelliteDllsProjectOutputGroup)' == ''">false</IncludeSatelliteDllsProjectOutputGroup>
    <IncludeSourceFilesProjectOutputGroup Condition="'$(IncludeSourceFilesProjectOutputGroup)' == ''">false</IncludeSourceFilesProjectOutputGroup>
    <IncludeContentFilesProjectOutputGroup Condition="'$(IncludeContentFilesProjectOutputGroup)' == ''">true</IncludeContentFilesProjectOutputGroup>
    <IncludeSGenFilesOutputGroup Condition="'$(IncludeSGenFilesOutputGroup)' == ''">false</IncludeSGenFilesOutputGroup>
    <IncludeCopyLocalFilesOutputGroup Condition="'$(IncludeCopyLocalFilesOutputGroup)' == ''">true</IncludeCopyLocalFilesOutputGroup>
    <IncludeGetCopyToOutputDirectoryItemsOutputGroup Condition="'$(IncludeGetCopyToOutputDirectoryItemsOutputGroup)' == ''">true</IncludeGetCopyToOutputDirectoryItemsOutputGroup>
    <IncludeOptionalProjectsOutputGroup Condition="'$(IncludeOptionalProjectsOutputGroup)' == ''">true</IncludeOptionalProjectsOutputGroup>
    <IncludeComFilesOutputGroup Condition="'$(IncludeComFilesOutputGroup)' == ''">false</IncludeComFilesOutputGroup>
    <IncludeCustomOutputGroupForPackaging Condition="'$(IncludeCustomOutputGroupForPackaging)' == ''">false</IncludeCustomOutputGroupForPackaging>
    <IncludeCopyWinmdArtifactsOutputGroup Condition="'$(IncludeCopyWinmdArtifactsOutputGroup)' == ''">true</IncludeCopyWinmdArtifactsOutputGroup>
    <IncludeSDKRedistOutputGroup Condition="'$(IncludeSDKRedistOutputGroup)' == ''">true</IncludeSDKRedistOutputGroup>
    <IncludePriFilesOutputGroup Condition="'$(IncludePriFilesOutputGroup)' == ''">true</IncludePriFilesOutputGroup>
    <IncludeGetResolvedSDKReferences Condition="'$(IncludeGetResolvedSDKReferences)' == ''">true</IncludeGetResolvedSDKReferences>
    <IncludeProjectPriFile Condition="'$(IncludeProjectPriFile)' == ''">true</IncludeProjectPriFile>
  </PropertyGroup>

  <!-- Entry points for the project systems. -->
  <PropertyGroup Condition="'$(AppxPackage)' == 'true'">
    <CleanPackageAction>_CleanAppxPackage</CleanPackageAction>
    <PackageAction>_GenerateAppxPackage</PackageAction>
    <RebuildPackageAction>_RebuildAppxPackage</RebuildPackageAction>
  </PropertyGroup>

  <!-- Tie into rebuild sequence, to set flag if we are doing rebuilding. -->
  <Target Name="_BeforeBeforeRebuild" BeforeTargets="BeforeRebuild">
    <PropertyGroup>
      <_Rebuilding>true</_Rebuilding>
    </PropertyGroup>
  </Target>

  <!-- Alter behavior of task ResolveAssemblyReferences to error on architecture mismatch. -->
  <PropertyGroup>
    <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch Condition="'$(ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch)' == ''">Error</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
  </PropertyGroup>

  <!-- ============================================================================================ -->
  <!-- Overriding Publish target from Microsoft.Common.targets to tie into command-line publishing. -->
  <!-- ============================================================================================ -->

  <Target Name="Publish"
          Condition="'$(AppxPackage)' == 'true'"
          DependsOnTargets="Build;$(PackageAction)" />


  <!--
    ***********************************************************************************************
    ***********************************************************************************************
        Actions happening during the build
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup>
    <PrepareForRunDependsOn>
      $(PrepareForRunDependsOn);
      _ValidateConfiguration;
      _ValidateAzureCodeSigningVersion;
      _ValidateAzureKeyVaultVersion;
      _ValidateSigningCertificate;
      _ValidatePublisherName;
      _ValidatePaths;
      _ComputeBuildAppxUploadPackageForUapFlag;
      _GetAppxManifestSchemaItems;
      _FindAndValidateBundleMappingFile;
      _GetSdkToolPaths;
      _GetPriConfigXmlSnippets;
      _ReadAppxLayout;
      _ValidatePresenceOfAppxManifestItems;
      GetPackagingOutputs;
      _GetPackageProperties;
      _AddUnionWinmd;
      _AddFxWinmd;
      _GenerateProjectPriFile;
      _ComputeAppxPackagePayload;
      _GenerateAppxManifest;
      _ValidateStoreManifest;
      _BuildOptionalProjects;
      _GenerateBundleMappingFile;
      _GenerateBundleManifest;
      _GenerateAppxPackageRecipe;
      _GenerateAppxUploadPackageRecipe;
      _ConvertAppxContentGroupMap;
    </PrepareForRunDependsOn>
    <PrepareForRunDependsOn Condition=" '$(GenerateAppxPackageOnBuild)' == 'true'">
      $(PrepareForRunDependsOn);
      $(PackageAction)
    </PrepareForRunDependsOn>
    <PrepareForRunDependsOn>
      $(PrepareForRunDependsOn);
      _AppendToReadTlogFile;
      _AppendToWriteTlogFile;
      _AppendToPackagingWriteLogs
    </PrepareForRunDependsOn>
  </PropertyGroup>

  <Target Name="_ValidatePipeline">
    <ValidatePipeline PipelineVersion="$(AppxPackagePipelineVersion)" VsTelemetrySession="$(VsTelemetrySession)"/>
  </Target>

  <Target Name="_ValidateAzureCodeSigningVersion"
          Condition="$(AzureCodeSigningEnabled)">
    <ValidateAzureCodeSigningVersion UseSdkBuildToolsPackage="$(UseSdkBuildToolsPackage)"
                                     WindowsSDKBuildToolsVersion="$(WindowsSDKBuildToolsVersion)"
                                     TargetPlatformVersion="$(TargetPlatformVersion)" />
  </Target>

  <Target Name="_ValidateAzureKeyVaultVersion"
          Condition="$(AzureKeyVaultEnabled)">
    <ValidateAzureKeyVaultVersion TargetPlatformVersion="$(TargetPlatformVersion)" />
  </Target>

  <!-- Validate that the signing path and thumbprint match -->
  <Target Name="_ValidateSigningCertificate"
          DependsOnTargets="_FindStoreAssociationFile"
          Condition="'$(AppxPackage)' == 'true' and
                     '$(AzureCodeSigningEnabled)' != 'true' and
                     '$(AzureKeyVaultEnabled)' != 'true'">

    <!--
      If no thumbprint or cert file is provided, but we're generating sideload packages during a store build...
      Generate a disposable certificate and enable package signing so the sideload packages get signed properly.
    -->
    <GenerateDisposableSigningCertificate Condition="'$(GenerateTemporaryStoreCertificate)' == 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'"
                                          AppxManifest="@(AppxManifest)"
                                          StoreAssociationFile="@(StoreAssociationFile)">
      <Output TaskParameter="DisposableSigningCertificateThumbprint" PropertyName="PackageCertificateThumbprint" />
      <Output TaskParameter="EnableAppxPackageSigning" PropertyName="AppxPackageSigningEnabled" />
    </GenerateDisposableSigningCertificate>

    <!--
      We need to clear the PackageCertificateKeyFile property if a disposable signing certificate is being
      generated. This is because the ValidateSigningCertificate requires PackageCertificateThumbprint to match
      the thumbprint of the certificate held within the pfx defined by PackageCertificateKeyFile
    -->
    <PropertyGroup Condition="'$(GenerateTemporaryStoreCertificate)' == 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'">
      <PackageCertificateKeyFile></PackageCertificateKeyFile>
    </PropertyGroup>

    <ValidateSigningCertificate Condition="'$(AppxPackageSigningEnabled)' == 'true' and '$(AzureCodeSigningEnabled)' != 'true'"
                                CertificateThumbprint="$(PackageCertificateThumbprint)"
                                CertificateFile="$(PackageCertificateKeyFile)"
                                CertificatePassword="$(PackageCertificatePassword)"
                                VsTelemetrySession="$(VsTelemetrySession)">
    </ValidateSigningCertificate>

  </Target>

  <!-- Validate that the publisher name is appropriate for the build scenario -->
  <Target Name="_ValidatePublisherName"
          DependsOnTargets="_FindStoreAssociationFile"
          Condition="'$(AppxPackage)' == 'true' and
                     '$(BuildAppxUploadPackageForUap)' == 'true' and
                     '$(SkipPublisherNameValidation)' != 'true'">

    <ValidatePublisherName IsPackageSigningEnabled="$(AppxPackageSigningEnabled)"
                           CertificateThumbprint="$(PackageCertificateThumbprint)"
                           CertificateFile="$(PackageCertificateKeyFile)"
                           CertificatePassword="$(PackageCertificatePassword)"
                           EnableSigningChecks="$(EnableSigningChecks)"
                           AppxManifest="@(AppxManifest)"
                           StoreAssociationFile="@(StoreAssociationFile)"/>

  </Target>

  <!-- Clean up the temporary certificate created for store test package signing -->
  <Target Name="_RemoveDisposableSigningCertificate">

    <RemoveDisposableSigningCertificate Condition="'$(GenerateTemporaryStoreCertificate)' == 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'"
                                        CertificateThumbprint="$(PackageCertificateThumbprint)" />

  </Target>

  <!-- Validates directory paths and ensures trailing slashes -->
  <Target Name="_ValidatePaths">

    <PropertyGroup>
      <AppxPackageDir Condition="!HasTrailingSlash('$(AppxPackageDir)')">$(AppxPackageDir)\</AppxPackageDir>
      <AppxLayoutDir Condition="!HasTrailingSlash('$(AppxLayoutDir)')">'$(AppxLayoutDir)'\</AppxLayoutDir>
      <AppxUploadLayoutDir Condition="!HasTrailingSlash('$(AppxUploadLayoutDir)')">$(AppxUploadLayoutDir)\</AppxUploadLayoutDir>
      <PlatformSpecificBundleArtifactsListDir Condition="!HasTrailingSlash('$(PlatformSpecificBundleArtifactsListDir)')">$(PlatformSpecificBundleArtifactsListDir)\</PlatformSpecificBundleArtifactsListDir>
      <PlatformSpecificUploadBundleArtifactsListDir Condition="'$(PlatformSpecificUploadBundleArtifactsListDir)' == ''">$(PlatformSpecificBundleArtifactsListDir)Upload\</PlatformSpecificUploadBundleArtifactsListDir>
    </PropertyGroup>

  </Target>

  <Target Name="_GetPackageFileExtensions">

    <PropertyGroup Condition="'$(PackageExtPrefix)' == ''">
      <PackageExtPrefix>appx</PackageExtPrefix>
      <PackageExtPrefix Condition="'$(TargetPlatformMinVersion)' &gt;= '10.0.17200.0'">msix</PackageExtPrefix>
    </PropertyGroup>

    <PropertyGroup>
      <AppxPackageExtension Condition="'$(AppxPackageExtension)' == ''">.$(PackageExtPrefix)</AppxPackageExtension>
      <AppxPackageEncryptedExtension Condition="'$(AppxPackageEncryptedExtension)' == ''">.e$(PackageExtPrefix)</AppxPackageEncryptedExtension>
      <AppxSymbolPackageExtension Condition="'$(AppxSymbolPackageExtension)' == ''">.appxsym</AppxSymbolPackageExtension>
      <AppxBundleExtension Condition="'$(AppxBundleExtension)' == ''">.$(PackageExtPrefix)bundle</AppxBundleExtension>
      <AppxBundleEncryptedExtension Condition="'$(AppxBundleEncryptedExtension)' == ''">.e$(PackageExtPrefix)bundle</AppxBundleEncryptedExtension>
      <AppxStoreContainerExtension Condition="'$(AppxStoreContainerExtension)' == ''">.$(PackageExtPrefix)upload</AppxStoreContainerExtension>
      <AppxIntermediateExtension Condition="'$(AppxIntermediateExtension)' == ''">.intermediate</AppxIntermediateExtension>
    </PropertyGroup>

  </Target>

  <!-- If the AutoIncrementPackageRevision flag is false, delete the AppxPackageTestDir in order to ensure all files in the folder are up to date. -->
  <Target Name="_DeleteAppxOutputFolderIfNecessary"
          Condition="('$(BuildingInsideVisualStudio)' != 'true' or '$(AppxAutoIncrementPackageRevision)' != 'true') and Exists($(AppxPackageTestDir))">

    <RemoveDir Directories="$(AppxPackageTestDir)" />
  </Target>

  <!-- Calculates AppxManifestSchema items. -->
  <PropertyGroup>
    <_GetAppxManifestSchemaItemsDependsOn>
      $(_GetAppxManifestSchemaItemsDependsOn);
      _GetAppxManifestSchemaItemsFromSdk;
      _GetAppxManifestSchemaItemsFromPackage
    </_GetAppxManifestSchemaItemsDependsOn>
  </PropertyGroup>

  <Target Name="_GetAppxManifestSchemaItems" Condition="'@(AppxManifestSchema)' == ''" DependsOnTargets="$(_GetAppxManifestSchemaItemsDependsOn)" />

  <!-- Schemas installed via nupkg -->
  <Target Name="_GetAppxManifestSchemaItemsFromPackage" Condition="'$(UseSdkBuildToolsPackage)' == 'true'">

    <PropertyGroup>
      <MetadataNamespaceUri Condition="'$(MetadataNamespaceUri)' == ''">http://schemas.microsoft.com/developer/appx/2015/build</MetadataNamespaceUri>
    </PropertyGroup>

    <ItemGroup Condition="'$(TargetPlatformIdentifier)' == 'Windows'">
      <AppxManifestSchema Include="$(WindowsSDKSchemasFolder)\AppxManifestSchema2010_v2.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(WindowsSDKSchemasFolder)\AppxManifestSchema2013.xsd">
        <NamespaceAlias>m2</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2013/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>

    <ItemGroup Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and '$(SDKVersion)' == '10.0'">
      <AppxManifestSchema Include="$(WindowsSDKSchemasFolder)\FoundationManifestSchema.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/manifest/foundation/windows10</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(WindowsSDKSchemasFolder)\UapManifestSchema.xsd">
        <NamespaceAlias>uap</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/manifest/uap/windows10</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>
  </Target>

  <!--
    For UWP apps using modern .NET, the 'UseUwpTools' property will be set. In that case,
    we can use a private property to fixup the targets below that were originally only
    meant to work on legacy UWP, which has 'TargetPlatformIdentifier' set to 'UAP'. For
    modern .NET, that property will be 'Windows' instead, but the logic for this value
    would not be correct for code being compiled to be used in a UWP application.
  -->
  <PropertyGroup>
    <_TargetPlatformIdentifierForPriResources Condition="'$(UseUwpTools)' == true">UAP</_TargetPlatformIdentifierForPriResources>
    <_TargetPlatformIdentifierForPriResources Condition="'$(UseUwpTools)' != true">$(TargetPlatformIdentifier)</_TargetPlatformIdentifierForPriResources>
  </PropertyGroup>

  <!-- Schemas installed via SDK msi -->
  <Target Name="_GetAppxManifestSchemaItemsFromSdk" Condition="'$(UseSdkBuildToolsPackage)' != 'true'">

    <GetSdkPropertyValue Condition="'$(_TargetPlatformIdentifierForPriResources)' == 'Windows'"
                         TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                         SDKIdentifier="$(SDKIdentifier)"
                         SDKVersion="$(SDKVersion)"
                         TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)"
                         TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                         TargetPlatformVersion="$(TargetPlatformVersion)"
                         PropertyName="WindowsSDK80Path"
                         VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>

    <GetSdkPropertyValue Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'"
                         TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                         SDKIdentifier="$(SDKIdentifier)"
                         SDKVersion="$(SDKVersion)"
                         TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)"
                         TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                         TargetPlatformVersion="$(TargetPlatformVersion)"
                         PropertyName="WindowsPhoneSdkDir"
                         VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>

    <GetSdkPropertyValue Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'"
                         TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                         SDKIdentifier="$(SDKIdentifier)"
                         SDKVersion="$(SDKVersion)"
                         TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)"
                         TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                         TargetPlatformVersion="$(TargetPlatformVersion)"
                         PropertyName="WindowsSdkDir"
                         VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>

    <ItemGroup Condition="'$(_TargetPlatformIdentifierForPriResources)' == 'Windows' and '$(TargetPlatformVersion)' == '8.0'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>

    <ItemGroup Condition="'$(_TargetPlatformIdentifierForPriResources)' == 'Windows' and '$(TargetPlatformVersion)' != '8.0'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2010_v2.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2013.xsd">
        <NamespaceAlias>m2</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2013/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>

    <ItemGroup Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and '$(SDKVersion)' == '10.0'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\$(TargetPlatformVersion)\WinRT\FoundationManifestSchema.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/manifest/foundation/windows10</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\$(TargetPlatformVersion)\WinRT\UapManifestSchema.xsd">
        <NamespaceAlias>uap</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/manifest/uap/windows10</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>

    <ItemGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2010_v3.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2013_v2.xsd">
        <NamespaceAlias>m2</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2013/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2014.xsd">
        <NamespaceAlias>m3</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2014/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxPhoneManifestSchema2014.xsd">
        <NamespaceAlias>mp</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2014/phone/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>

    <PropertyGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true' and Exists('$(_TargetPlatformSdkDir)\Include\WinRT\StoreManifest.xsd')">
      <_StoreManifestSchemaDir>$(_TargetPlatformSdkDir)\Include\WinRT\</_StoreManifestSchemaDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true' and !Exists('$(_TargetPlatformSdkDir)\Include\WinRT\StoreManifest.xsd')">
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\SxS\VS7@15.0)</CURRENTVSINSTALLDIR>
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_CURRENT_USER\SOFTWARE\Microsoft\VisualStudio\SxS\VS7@15.0)</CURRENTVSINSTALLDIR>
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\SxS\VS7@15.0)</CURRENTVSINSTALLDIR>
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_CURRENT_USER\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\SxS\VS7@15.0)</CURRENTVSINSTALLDIR>
      <_StoreManifestSchemaDir>$(CURRENTVSINSTALLDIR)Xml\Schemas\</_StoreManifestSchemaDir>
    </PropertyGroup>

    <ItemGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">
      <StoreManifestSchema Include="$(_StoreManifestSchemaDir)StoreManifest.xsd">
        <NamespaceAlias>store</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/StoreManifest</NamespaceUri>
      </StoreManifestSchema>
    </ItemGroup>

    <!--
            Define AppxValidateStoreManifest based on whether we ended up with any
            StoreManifestSchemas or not.  This keeps the logic agnostic about which
            TargetPlatform/Version supports validating the Store manifest.
        -->
    <PropertyGroup>
      <AppxValidateStoreManifest Condition="'$(AppxValidateStoreManifest)' == '' and '@(StoreManifestSchema)' != ''">true</AppxValidateStoreManifest>
    </PropertyGroup>

    <PropertyGroup>
      <MetadataNamespaceUri Condition="'$(MetadataNamespaceUri)' == '' and '$(SDKIdentifier)' != ''">http://schemas.microsoft.com/developer/appx/2015/build</MetadataNamespaceUri>
      <MetadataNamespaceUri Condition="'$(MetadataNamespaceUri)' == ''">http://schemas.microsoft.com/developer/appx/2012/build</MetadataNamespaceUri>
    </PropertyGroup>
  </Target>

  <!-- Finds SDK tool executables paths. -->
  <PropertyGroup>
    <_GetSdkToolsPathsDependsOn>
      $(_GetSdkToolsPathsDependsOn);
      _GetSdkToolsPathsFromSdk;
      _GetSdkToolsPathsFromPackage
    </_GetSdkToolsPathsDependsOn>
  </PropertyGroup>

  <Target Name="_GetSdkToolPaths" DependsOnTargets="$(_GetSdkToolsPathsDependsOn)" />

  <!-- Tools installed via nupkg -->
  <Target Name="_GetSdkToolsPathsFromPackage" Condition="'$(UseSdkBuildToolsPackage)' == 'true'" />

  <!-- Tools installed via SDK msi-->
  <Target Name="_GetSdkToolsPathsFromSdk" Condition="'$(UseSdkBuildToolsPackage)' != 'true'">
    <PropertyGroup>
      <MSBuildExtensionsPath64Exists Condition="'$(MSBuildExtensionsPath64)' == ''">false</MSBuildExtensionsPath64Exists>
      <MSBuildExtensionsPath64Exists Condition="'$(MSBuildExtensionsPath64)' != ''">true</MSBuildExtensionsPath64Exists>
    </PropertyGroup>

    <GetSdkFileFullPath Condition="'$(AppxGeneratePriEnabled)' == 'true' or '$(AppxGeneratePrisForPortableLibrariesEnabled)' == 'true'"
                        FileName="MakePri.exe"
                        FullFilePath="$(MakePriExeFullPath)"
                        FileArchitecture="$(MakePriArchitecture)"
                        RequireExeExtension="true"
                        TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                        SDKIdentifier="$(SDKIdentifier)"
                        SDKVersion="$(SDKVersion)"
                        TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)"
                        TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                        TargetPlatformVersion="$(TargetPlatformVersion)"
                        MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)"
                        VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="MakePriExeFullPath" />
      <Output TaskParameter="ActualFileArchitecture" PropertyName="MakePriArchitecture" />
    </GetSdkFileFullPath>

    <!--Use the x64 version of MakeAppx.exe on Arm64 OS if necessary.-->
    <PropertyGroup Condition="'$(MakeAppxArchitecture)' == ''">
      <MakeAppxArchitecture Condition="'$(UseX64ToolsOnArm64OS)'=='true'">x64</MakeAppxArchitecture>
    </PropertyGroup>

    <GetSdkFileFullPath Condition="'$(AppxPackage)' == 'true' or '$(GenerateAppxPackageOnBuild)' == 'true' or '@(BundleMappingFile)' != ''"
                        FileName="MakeAppx.exe"
                        FullFilePath="$(MakeAppxExeFullPath)"
                        FileArchitecture="$(MakeAppxArchitecture)"
                        RequireExeExtension="true"
                        TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                        SDKIdentifier="$(SDKIdentifier)"
                        SDKVersion="$(SDKVersion)"
                        TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)"
                        TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                        TargetPlatformVersion="$(TargetPlatformVersion)"
                        MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)"
                        VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="MakeAppxExeFullPath" />
    </GetSdkFileFullPath>

    <GetSdkFileFullPath Condition="'$(AppxPackage)' == 'true' or '$(GenerateAppxPackageOnBuild)' == 'true'"
                        FileName="signtool.exe"
                        FullFilePath="$(SignAppxPackageExeFullPath)"
                        FileArchitecture="$(SignToolArchitecture)"
                        RequireExeExtension="true"
                        TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                        SDKIdentifier="$(SDKIdentifier)"
                        SDKVersion="$(SDKVersion)"
                        TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)"
                        TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                        TargetPlatformVersion="$(TargetPlatformVersion)"
                        MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)"
                        VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="SignAppxPackageExeFullPath" />
    </GetSdkFileFullPath>

    <PropertyGroup Condition="'$(AppxPackagingArchitecture)' == ''">
      <AppxPackagingArchitecture Condition="$([System.Environment]::Is64BitProcess)">x64</AppxPackagingArchitecture>
      <AppxPackagingArchitecture Condition="!$([System.Environment]::Is64BitProcess)">x86</AppxPackagingArchitecture>
      <AppxPackagingArchitecture Condition="'$(UseX64ToolsOnArm64OS)'=='false'">ARM64</AppxPackagingArchitecture>
    </PropertyGroup>

    <GetSdkFileFullPath Condition="'$(SDKIdentifier)' != ''"
                        FileName="Microsoft.Windows.Build.Appx.AppxPackaging.dll.manifest"
                        FullFilePath="$(AppxPackagingComponentManifestPath)"
                        FileArchitecture="$(AppxPackagingArchitecture)"
                        TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                        SDKIdentifier="$(SDKIdentifier)"
                        SDKVersion="$(SDKVersion)"
                        TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)"
                        TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                        TargetPlatformVersion="$(TargetPlatformVersion)"
                        MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)"
                        VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="AppxPackagingComponentManifestPath" />
    </GetSdkFileFullPath>

    <PropertyGroup Condition="'$(MrmSupportLibraryArchitecture)' == ''">
      <MrmSupportLibraryArchitecture Condition="$([System.Environment]::Is64BitProcess)">x64</MrmSupportLibraryArchitecture>
      <MrmSupportLibraryArchitecture Condition="!$([System.Environment]::Is64BitProcess)">x86</MrmSupportLibraryArchitecture>
      <MrmSupportLibraryArchitecture Condition="'$(UseX64ToolsOnArm64OS)'=='false'">ARM64</MrmSupportLibraryArchitecture>
    </PropertyGroup>

    <GetSdkFileFullPath Condition="'$(SDKIdentifier)' != ''"
                        FileName="MrmSupport.dll"
                        FullFilePath="$(MrmSupportLibraryPath)"
                        FileArchitecture="$(MrmSupportLibraryArchitecture)"
                        TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                        SDKIdentifier="$(SDKIdentifier)"
                        SDKVersion="$(SDKVersion)"
                        TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)"
                        TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                        TargetPlatformVersion="$(TargetPlatformVersion)"
                        MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)"
                        VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="MrmSupportLibraryPath" />
    </GetSdkFileFullPath>

    <GetSdkPropertyValue TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                         SDKIdentifier="$(SDKIdentifier)"
                         SDKVersion="$(SDKVersion)"
                         TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)"
                         TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                         TargetPlatformVersion="$(TargetPlatformVersion)"
                         PropertyName="MakePriExtensionPath"
                         VsTelemetrySession="$(VsTelemetrySession)"
                         Condition="'$(MakePriExtensionPath)' == '' and '$(SDKIdentifier)' == ''">
      <Output TaskParameter="PropertyValue" PropertyName="MakePriExtensionPath" />
    </GetSdkPropertyValue>

    <GetSdkPropertyValue TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                         SDKIdentifier="$(SDKIdentifier)"
                         SDKVersion="$(SDKVersion)"
                         TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)"
                         TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                         TargetPlatformVersion="$(TargetPlatformVersion)"
                         PropertyName="MakePriExtensionPath_x64"
                         VsTelemetrySession="$(VsTelemetrySession)"
                         Condition="'$(MakePriExtensionPath_x64)' == '' and '$(SDKIdentifier)' == ''">
      <Output TaskParameter="PropertyValue" PropertyName="MakePriExtensionPath_x64" />
    </GetSdkPropertyValue>

    <!--Clear out MakePriExtensionPath for UAP projects since it should never be used.-->
    <PropertyGroup Condition="'$(SDKIdentifier)' != ''">
      <MakePriExtensionPath></MakePriExtensionPath>
      <MakePriExtensionPath_x64></MakePriExtensionPath_x64>
    </PropertyGroup>

    <PropertyGroup>
      <OutOfProcessMakePriExtensionPath Condition="'$(MakePriArchitecture)' != 'amd64'">$(MakePriExtensionPath)</OutOfProcessMakePriExtensionPath>
      <OutOfProcessMakePriExtensionPath Condition="'$(MakePriArchitecture)' == 'amd64'">$(MakePriExtensionPath_x64)</OutOfProcessMakePriExtensionPath>
    </PropertyGroup>

    <PropertyGroup>
      <InProcessMakePriExtensionPath Condition="!$([System.Environment]::Is64BitProcess)">$(MakePriExtensionPath)</InProcessMakePriExtensionPath>
      <InProcessMakePriExtensionPath Condition="$([System.Environment]::Is64BitProcess)">$(MakePriExtensionPath_x64)</InProcessMakePriExtensionPath>
    </PropertyGroup>

  </Target>

  <!-- Calculates paths to priconfig.xml snippets -->
  <Target Name="_GetPriConfigXmlSnippets">

    <ItemGroup Condition="'$(AppxPriConfigXmlPackagingSnippetPath)' == ''">
      <_AppxPriConfigXmlPackagingSnippetItem Include="@(None)" Condition="'%(Identity)' == 'priconfig.packaging.xml'" />
      <_AppxPriConfigXmlPackagingSnippetItem Include="@(Xml)" Condition="'%(Identity)' == 'priconfig.packaging.xml' and '%(Xml.DeploymentContent)' == 'false'" />
    </ItemGroup>

    <PropertyGroup Condition="'@(_AppxPriConfigXmlPackagingSnippetItem)' != ''">
      <AppxPriConfigXmlPackagingSnippetPath>%(_AppxPriConfigXmlPackagingSnippetItem.FullPath)</AppxPriConfigXmlPackagingSnippetPath>
    </PropertyGroup>

    <ItemGroup Condition="'$(AppxPriConfigXmlDefaultSnippetPath)' == ''">
      <_AppxPriConfigXmlDefaultSnippetItem Include="@(None)" Condition="'%(Identity)' == 'priconfig.default.xml'" />
      <_AppxPriConfigXmlDefaultSnippetItem Include="@(Xml)" Condition="'%(Identity)' == 'priconfig.default.xml' and '%(Xml.DeploymentContent)' == 'false'" />
    </ItemGroup>

    <PropertyGroup Condition="'@(_AppxPriConfigXmlDefaultSnippetItem)' != ''">
      <AppxPriConfigXmlDefaultSnippetPath>%(_AppxPriConfigXmlDefaultSnippetItem.FullPath)</AppxPriConfigXmlDefaultSnippetPath>
    </PropertyGroup>

  </Target>

  <PropertyGroup>
    <ValidatePresenceOfAppxManifestItemsDependsOn>
      $(ValidatePresenceOfAppxManifestItemsDependsOn);
    </ValidatePresenceOfAppxManifestItemsDependsOn>
  </PropertyGroup>

  <!-- Finds out if there is a custom AppxManifest override item, -->
  <!-- validates that one and only one manifest exists,           -->
  <!-- extracts identity name and version out of the manifest,    -->
  <!-- defines ProjectPriIndexName,                               -->
  <!-- and defines SourceAppxManifest item.                       -->
  <Target Name="_ValidatePresenceOfAppxManifestItems"
          DependsOnTargets="$(ValidatePresenceOfAppxManifestItemsDependsOn)"
            >

    <ItemGroup>
      <CustomAppxManifest Include="@(Content)" Condition="'%(Identity)' == '$(AppxManifestFileName)'" />
    </ItemGroup>

    <ValidateAppxManifestItems AppxPackageProject="$(AppxPackage)"
                               AppxManifestItems="@(AppxManifest)"
                               CustomAppxManifestItems="@(CustomAppxManifest)"
                               VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="IdentityName" PropertyName="AppxManifestIdentityName" />
      <Output TaskParameter="IdentityVersion" PropertyName="AppxManifestIdentityVersion" />
    </ValidateAppxManifestItems>

    <ItemGroup>
      <SourceAppxManifest Include="@(AppxManifest)" Condition="'@(AppxManifest)' != ''" />
      <SourceAppxManifest Include="@(CustomAppxManifest)" Condition="'@(CustomAppxManifest)' != ''" />
    </ItemGroup>

    <PropertyGroup Condition="'$(ProjectPriIndexName)' == ''">
      <ProjectPriIndexName Condition="'$(AppxPackage)' == 'true'">$(AppxManifestIdentityName)</ProjectPriIndexName>
      <ProjectPriIndexName Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' == ''">$(TargetName)</ProjectPriIndexName>
      <ProjectPriIndexName Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)</ProjectPriIndexName>
    </PropertyGroup>

    <PropertyGroup>
      <_CustomAppxManifestUsed Condition="'@(CustomAppxManifest)' == ''">false</_CustomAppxManifestUsed>
      <_CustomAppxManifestUsed Condition="'@(CustomAppxManifest)' != ''">true</_CustomAppxManifestUsed>
    </PropertyGroup>
  </Target>

  <!-- ============================ -->
  <!-- Generating project PRI file. -->
  <!-- ============================ -->

  <PropertyGroup>
    <_GenerateProjectPriFileDependsOn>
      $(_GenerateProjectPriFileDependsOn);
      BeforeGenerateProjectPriFile;
      _GeneratePrisForPortableLibraries;
      _GetPriFilesFromPayload;
      _ComputeInputPriFiles;
      _GenerateProjectPriConfigurationFiles;
      _CalculateInputsForGenerateProjectPriFileCore;
      _GenerateProjectPriFileCore;
      _AddFileReadsAndFileWritesForProjectPri;
      _CreateProjectPriFileItem;
      _ExpandProjectPriFile;
      _ExpandPriFiles;
      _ExpandPriUploadFiles;
      AfterGenerateProjectPriFile
    </_GenerateProjectPriFileDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <_SupportEmbedFileResources Condition="'$(_SupportEmbedFileResources)' =='' AND ('$(TargetPlatformIdentifier)' == 'UAP' OR '$(UseUwpTools)' == 'true')">true</_SupportEmbedFileResources>
    <_PriConfigXmlPath>$(IntermediateOutputPath)priconfig.xml</_PriConfigXmlPath>
    <_UnfilteredLayoutResfilesPath>$(IntermediateOutputPath)unfiltered.layout.resfiles</_UnfilteredLayoutResfilesPath>
    <_FilteredLayoutResfilesPath>$(IntermediateOutputPath)filtered.layout.resfiles</_FilteredLayoutResfilesPath>
    <_FilteredPackageLayoutFilePath Condition="'$(FilterSatelliteAssembliesForMakePri)' != '' AND '$(FilterSatelliteAssembliesForMakePri)' != 'false'">$(IntermediateOutputPath)filtered.package.layout.resfiles</_FilteredPackageLayoutFilePath>
    <_ExcludedPackageLayoutFilePath Condition="'$(FilterSatelliteAssembliesForMakePri)' != '' AND '$(FilterSatelliteAssembliesForMakePri)' != 'false'">$(IntermediateOutputPath)excluded.package.layout.resfiles</_ExcludedPackageLayoutFilePath>
    <_FilteredUploadPackageLayoutFilePath Condition="'$(FilterSatelliteAssembliesForMakePri)' != '' AND '$(FilterSatelliteAssembliesForMakePri)' != 'false'">$(IntermediateUploadOutputPath)filtered.package.layout.resfiles</_FilteredUploadPackageLayoutFilePath>
    <_ExcludedUploadPackageLayoutFilePath Condition="'$(FilterSatelliteAssembliesForMakePri)' != '' AND '$(FilterSatelliteAssembliesForMakePri)' != 'false'">$(IntermediateUploadOutputPath)excluded.package.layout.resfiles</_ExcludedUploadPackageLayoutFilePath>
    <_ExcludedLayoutResfilesPath>$(IntermediateOutputPath)excluded.layout.resfiles</_ExcludedLayoutResfilesPath>
    <_ResourcesResfilesPath>$(IntermediateOutputPath)resources.resfiles</_ResourcesResfilesPath>
    <_PriResfilesPath>$(IntermediateOutputPath)pri.resfiles</_PriResfilesPath>
    <_EmbedFileResfilePath Condition="'$(_SupportEmbedFileResources)' == 'true'">$(IntermediateOutputPath)$(AppxSubfolderWithFilesToBeEmbedded)\embed.resfiles</_EmbedFileResfilePath>
    <_QualifiersPath>$(IntermediateOutputPath)qualifiers.txt</_QualifiersPath>
    <_MultipleQualifiersPerDimensionFoundPath>$(IntermediateOutputPath)MultipleQualifiersPerDimensionFound.txt</_MultipleQualifiersPerDimensionFoundPath>
  </PropertyGroup>

  <Target Name="_GenerateProjectPriFile"
          Condition="'$(AppxGeneratePriEnabled)' == 'true'"
          DependsOnTargets="$(_GenerateProjectPriFileDependsOn)"
            />

  <!-- Override to specify actions to happen before generating project PRI file. -->
  <Target Name="BeforeGenerateProjectPriFile" />

  <!-- Generates a PRI file for all managed libraries that contain .resources files   -->
  <!-- in them (and their satellites).  This allows a .NET Portable Library to be     -->
  <!-- built with only .resources files, yet still be localized when compiled into    -->
  <!-- an AppX package where the ResourceManager uses the WinRT resource manager.     -->
  <Target Name="_GeneratePrisForPortableLibraries"
          Condition="'$(AppxPackage)' == 'true' and '$(AppxGeneratePrisForPortableLibrariesEnabled)' == 'true'"
            >
    <!--
    Do not rename or delete the item groups _LibrariesUnfiltered and CreatedResWFiles

    In case of compiling Universal app, the item group _LibrariesUnfiltered will get initialized with the filtered list of
    the app assemblies excluding the framework assemblies.
    the initialization will occur in the target _GetLibrariesToGeneratePrisForUWPApps in the file Microsoft.Net.CoreRuntime.targets.
    also _GetLibrariesToGeneratePrisForUWPApps will fill the initial list of CreatedResWFiles.
    -->

    <ItemGroup Condition="'@(_LibrariesUnfiltered)' == '' and '@(CreatedResWFiles)' == '' and '$(NetCoreGeneratePrisForPortableLibraries)'!='true'">
      <_LibrariesUnfiltered Include="@(PackagingOutputs)" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>

    <RemovePayloadDuplicates Inputs="@(_LibrariesUnfiltered)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_LibrariesFiltered" />
    </RemovePayloadDuplicates>

    <ItemGroup>
      <_Libraries Include="@(_LibrariesFiltered)" Condition="'%(_LibrariesFiltered.BaseAssemblyFullPath)' == ''" />
      <_Libraries Include="@(_LibrariesFiltered)" Condition="'%(_LibrariesFiltered.BaseAssemblyFullPath)' != ''">
        <OriginalItemSpec>%(_LibrariesFiltered.BaseAssemblyFullPath)</OriginalItemSpec>
      </_Libraries>
    </ItemGroup>

    <GenerateResource
                SdkToolsPath="$(ResgenToolPath)"
                ExtractResWFiles="true"
                Sources="@(_Libraries)"
                UseSourcePath="$(UseSourcePath)"
                References="@(ReferencePath)"
                AdditionalInputs="$(MSBuildAllProjects)"
                NeverLockTypeAssemblies="$(GenerateResourceNeverLockTypeAssemblies)"
                StateFile="$(IntermediateOutputPath)$(MSBuildProjectFile).GenerateResource.Cache"
                OutputDirectory="$(IntermediateOutputPath)"
                ExecuteAsTool="false"
                MSBuildRuntime="$(GenerateResourceMSBuildRuntime)"
                MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)">

      <Output TaskParameter="FilesWritten" ItemName="ExtractedFileWrites"/>
      <Output TaskParameter="OutputResources" ItemName="CreatedResWFiles" />
    </GenerateResource>

    <ItemGroup>
      <FileWrites Include="@(ExtractedFileWrites)" />
    </ItemGroup>

    <!-- Now generate a PRI file for each set of ResW files (ie, a main assembly + all satellites). -->
    <!-- Note: The task relies on some metadata set on each ITaskItem, set by GenerateResource.  -->

    <CreatePriFilesForPortableLibraries
                    MakePriExeFullPath="$(MakePriExeFullPath)"
                    MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                    ContentToIndex="@(CreatedResWFiles)"
                    IntermediateDirectory="$(IntermediateOutputPath)"
                    AdditionalMakepriExeParameters="$(AppxCreatePriFilesForPortableLibrariesAdditionalMakepriExeParameters)"
                    DefaultResourceLanguage="$(DefaultResourceLanguage)"
                    DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
                    IntermediateExtension="$(AppxIntermediateExtension)"
                    TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                    TargetPlatformVersion="$(TargetPlatformResourceVersion)"
                    AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
                    SkipIntermediatePriGenerationForResourceFiles="$(SkipIntermediatePriGenerationForResourceFiles)"
                    VsTelemetrySession="$(VsTelemetrySession)"
                        >
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
      <Output TaskParameter="CreatedPriFiles" ItemName="_PortableLibraryCreatedPriFiles" />
      <Output TaskParameter="UnprocessedReswFiles_DefaultLanguage" ItemName="_UnprocessedReswFiles_DefaultLanguage" />
      <Output TaskParameter="UnprocessedReswFiles_OtherLanguages" ItemName="_UnprocessedReswFiles_OtherLanguages" />
    </CreatePriFilesForPortableLibraries>

    <!-- Add all resw files we didn't generate a pri file for to the PRIResource group so they get included during           -->
    <!-- final pri generation, with the exception of those that need to be indexed using a language other than the project's -->
    <!-- default.  This group will always be empty if SkipIntermediatePriGenerationForResourceFiles is false.                -->
    <ItemGroup>
      <PRIResource Include="@(_UnprocessedReswFiles_DefaultLanguage)" />
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="@(_PortableLibraryCreatedPriFiles)" />
    </ItemGroup>

  </Target>

  <!-- Get list of PRI files from the payload. -->
  <Target Name="_GetPriFilesFromPayload"
          Condition="'$(AppxPackage)' == 'true'"
            >

    <ItemGroup>
      <_PriFilesFromPayloadRaw Include="@(PackagingOutputs)"
                               Condition="'%(Extension)' == '.pri'
                                            and '%(ProjectName)' != '$(ProjectName)'"
                                     />
      <_PriFilesFromPayloadRaw Include="@(PackagingOutputs)"
                               Condition="'%(Extension)' == '.pri'
                                            and '%(ProjectName)' == '$(ProjectName)'
                                            and '%(OutputGroup)' != 'ProjectPriFile'"
                                     />
    </ItemGroup>

    <RemoveDuplicatePriFiles Inputs="@(_PriFilesFromPayloadRaw)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_PriFilesFromPayload" />
    </RemoveDuplicatePriFiles>

  </Target>

  <!-- Compute final list of input PRI files. -->
  <Target Name="_ComputeInputPriFiles"
          Condition="'$(AppxPackage)' == 'true'"
            >

    <ItemGroup>
      <_PriFile Include="@(_PriFilesFromPayload)" />
      <_PriFile Include="@(_PortableLibraryCreatedPriFiles)" />
    </ItemGroup>

  </Target>

  <!-- Generates configuration files for makepri.exe. -->
  <Target Name="_GenerateProjectPriConfigurationFiles"
          DependsOnTargets="_GetPackageFileExtensions"
          Inputs="$(MSBuildAllProjects);@(_PriFile);$(AppxPriConfigXmlDefaultSnippetPath);@(PackagingOutputs)"
          Outputs="$(_PriConfigXmlPath);$(_UnfilteredLayoutResfilesPath);$(_FilteredLayoutResfilesPath);$(_ExcludedLayoutResfilesPath);$(_ResourcesResfilesPath);$(_PriResfilesPath)"
            >

    <ItemGroup>
      <!--
        First, build out the complete list of files we want to consider for the layout.
        Then exclude anything that matches any pattern or filename listed in _AppxLayoutAssetPackageFiles.
        We could do this as a 'Remove' operation, but by building an oracle we don't modify, we simplify future manipulations of this data set.
      -->
      <_LayoutFileSource Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'ContentFilesProjectOutputGroup' and '%(ProjectName)' == '$(ProjectName)'" />
      <_LayoutFileSource Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'CustomOutputGroupForPackaging' and '%(ProjectName)' == '$(ProjectName)'" />
      <_LayoutFile Include="@(_LayoutFileSource)" Exclude="@(_AppxLayoutAssetPackageFiles)" />
      <_EmbedFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'EmbedOutputGroupForPackaging' and '%(ProjectName)' == '$(ProjectName)'"/>
      <_EmbedFileCopy Include="@(_EmbedFile->'$(IntermediateOutputPath)$(AppxSubfolderWithFilesToBeEmbedded)\%(TargetPath)')" />
      <!-- If we have the .xbf we don't need the .xaml file-->
      <_LayoutFileXbfXaml Include="$([System.IO.Path]::ChangeExtension('%(_LayoutFile.Identity)','.xaml'))" Condition="'%(Extension)' == '.xbf'" />
      <_LayoutFile Remove="@(_LayoutFileXbfXaml)" />
    </ItemGroup>

    <!-- Filter out PRIResource files which are marked by C++ project system as ExcludedFromBuild -->
    <ItemGroup>
      <_PRIResourceFiltered Include="@(PRIResource)" Condition="'%(PRIResource.ExcludedFromBuild)' != 'true'" />
    </ItemGroup>

    <GeneratePriConfigurationFiles
          UnfilteredLayoutResfilesPath="$(_UnfilteredLayoutResfilesPath)"
          FilteredLayoutResfilesPath="$(_FilteredLayoutResfilesPath)"
          ExcludedLayoutResfilesPath="$(_ExcludedLayoutResfilesPath)"
          ResourcesResfilesPath="$(_ResourcesResfilesPath)"
          PriResfilesPath="$(_PriResfilesPath)"
          EmbedFileResfilePath="$(_EmbedFileResfilePath)"
          LayoutFiles="@(_LayoutFile)"
          PRIResourceFiles="@(_PRIResourceFiltered)"
          PriFiles="@(_PriFile)"
          EmbedFiles="@(_EmbedFile)"
          IntermediateExtension="$(AppxIntermediateExtension)"
          UnprocessedResourceFiles_OtherLanguages="@(_UnprocessedReswFiles_OtherLanguages)"
          VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="AdditionalResourceResFiles" ItemName="_AdditionalResourceResFiles" />
    </GeneratePriConfigurationFiles>

    <CreatePriConfigXmlForFullIndex
        PriConfigXmlPath="$(_PriConfigXmlPath)"
        LayoutResfilesPath="$(_FilteredLayoutResfilesPath)"
        ResourcesResfilesPath="$(_ResourcesResfilesPath)"
        PriResfilesPath="$(_PriResfilesPath)"
        EmbedFileResfilePath="$(_EmbedFileResfilePath)"
        PriInitialPath="$(AppxPriInitialPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
        IntermediateExtension="$(AppxIntermediateExtension)"
        PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformResourceVersion)"
        AdditionalResourceResFiles="@(_AdditionalResourceResFiles)"
        VsTelemetrySession="$(VsTelemetrySession)"
            />

    <!-- Copy Embed files to location expected by embed indexer-->
    <MakeDir Directories="$(IntermediateOutputPath)$(AppxSubfolderWithFilesToBeEmbedded)" />

    <Copy
        SourceFiles="@(_EmbedFile)"
        DestinationFiles="@(_EmbedFileCopy)"
        SkipUnchangedFiles='true'
        />

  </Target>

  <Target Name="_SuppressDeploymentOnlyFeatures">

    <!-- Disable adding the reverse map to the PRI file. This is necessary when building from the packaging wizard. -->
    <PropertyGroup>
      <InsertReverseMap>false</InsertReverseMap>
      <ProjectPriFullPath>$(_ProjectPriFullPathOriginal)</ProjectPriFullPath>
      <DisableEmbeddedXbf Condition="'$(_OverriddenDisableXbf)' == 'false'">False</DisableEmbeddedXbf>
    </PropertyGroup>

  </Target>

  <!-- Calculate inputs for _GenerateProjectPriFileCore. -->
  <Target Name="_CalculateInputsForGenerateProjectPriFileCore">
    <ItemGroup>
      <_GenerateProjectPriFileCoreInput Include="$(_PriConfigXmlPath)" />
      <_GenerateProjectPriFileCoreInput Include="$(_FilteredLayoutResfilesPath)" />
      <_GenerateProjectPriFileCoreInput Include="$(_ResourcesResfilesPath)" />
      <_GenerateProjectPriFileCoreInput Include="$(_PriResfilesPath)" />
      <_GenerateProjectPriFileCoreInput Include="@(PRIResource)" />
      <_GenerateProjectPriFileCoreInput Include="@(_PriFile)" />
      <_GenerateProjectPriFileCoreInput Include="@(SourceAppxManifest)" />
      <_GenerateProjectPriFileCoreInput Include="$(_EmbedFileResfilePath)" />
      <_GenerateProjectPriFileCoreInput Include="@(_EmbedFile)" />
      <_GenerateProjectPriFileCoreInput Include="@(_AdditionalResourceResFiles)" />
    </ItemGroup>
  </Target>

  <!-- Generates intermediate PRI file for the current project. -->
  <Target Name="_GenerateProjectPriFileCore"
          Inputs="$(MSBuildAllProjects);@(_GenerateProjectPriFileCoreInput)"
          Outputs="$(ProjectPriFullPath)"
            >

    <MakeDir Condition="'$(InsertReverseMap)' == 'true'"
             Directories="$(_ReverseMapProjectPriDirectory)"
                 />

    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)"
                            MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                            PriConfigXmlPath="$(_PriConfigXmlPath)"
                            IndexFilesForQualifiersCollection="$(_FilteredLayoutResfilesPath);$(_ResourcesResfilesPath)"
                            ProjectPriIndexName="$(ProjectPriIndexName)"
                            InsertReverseMap="$(InsertReverseMap)"
                            ProjectDirectory="$(ProjectDir)"
                            OutputFileName="$(ProjectPriFullPath)"
                            QualifiersPath="$(_QualifiersPath)"
                            IntermediateExtension="$(AppxIntermediateExtension)"
                            AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
                            MultipleQualifiersPerDimensionFoundPath="$(_MultipleQualifiersPerDimensionFoundPath)"
                            AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)"
                            VsTelemetrySession="$(VsTelemetrySession)"
                            />

  </Target>

  <!-- Add FileReads and FileWrites done during generation of project PRI file. -->
  <Target Name="_AddFileReadsAndFileWritesForProjectPri">

    <ItemGroup>
      <FileReads Include="@(_GenerateProjectPriFileCoreInput)" />
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="$(_PriConfigXmlPath)" />
      <FileWrites Include="$(_PriConfigXmlPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_UnfilteredLayoutResfilesPath)" />
      <FileWrites Include="$(_UnfilteredLayoutResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_FilteredLayoutResfilesPath)" />
      <FileWrites Include="$(_FilteredLayoutResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_ExcludedLayoutResfilesPath)" />
      <FileWrites Include="$(_ExcludedLayoutResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_ResourcesResfilesPath)" />
      <FileWrites Include="$(_ResourcesResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_PriResfilesPath)" />
      <FileWrites Include="$(_PriResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(ProjectPriFullPath)" />
      <FileWrites Include="$(_QualifiersPath)" />
      <FileWrites Include="$(_QualifiersPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_MultipleQualifiersPerDimensionFoundPath)" />
      <FileWrites Include="@(_AdditionalResourceResFiles)" />
      <FileWrites Include="@(_AdditionalResourceResFiles->'%(Identity)$(AppxIntermediateExtension)')" />
    </ItemGroup>

  </Target>

  <!--Create ProjectPriFile item. -->
  <Target Name="_CreateProjectPriFileItem"
          Condition="'$(AppxPackage)' == 'true'"
            >

    <ItemGroup>
      <ProjectPriFile Remove="@(ProjectPriFile)" />
      <ProjectPriFile Include="$(ProjectPriFullPath)">
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </ProjectPriFile>
    </ItemGroup>

    <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == ''">
      <OsVersion>$(registry:HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion@CurrentVersion)</OsVersion>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == ''">
      <AppxUseResourceIndexerApi Condition="'$(OsVersion)' &lt; '6.3'">false</AppxUseResourceIndexerApi>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == ''">
      <AppxUseResourceIndexerApi>true</AppxUseResourceIndexerApi>
    </PropertyGroup>

  </Target>

  <!-- Expand content of project PRI file. -->
  <Target Name="_ExpandProjectPriFile"
          Condition="'$(AppxPackage)' == 'true' and '$(AppxUseResourceIndexerApi)' == 'false'">

    <ExpandPriContent Inputs="@(ProjectPriFile)"
                      MakePriExeFullPath="$(MakePriExeFullPath)"
                      MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                      IntermediateDirectory="$(IntermediateOutputPath)"
                      AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)"
                      VsTelemetrySession="$(VsTelemetrySession)"
                          >
      <Output TaskParameter="Expanded" ItemName="IndexedPayloadFiles" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>

  </Target>

  <PropertyGroup>
    <GetCopyToOutputDirectoryItemsDependsOn>
      <!-- ResolveProjectReferences has to come before the DependsOn as AssignTargetPath will cause _SplitProjectReferencesByFileExistence to run which will be skipped due
       to no _ProjectReferenceWithConfiguration then when we try to run it later it will be skipped because it was already 'built successfully' -->
      ResolveProjectReferences;
      $(GetCopyToOutputDirectoryItemsDependsOn);
      _SetPortablePriProperties;
      AddPriPayloadFilesToCopyToOutputDirectoryItems
    </GetCopyToOutputDirectoryItemsDependsOn>
  </PropertyGroup>

  <Target Name="_SetPortablePriProperties" Condition="'$(TargetPlatformIdentifier)' == 'Portable'" DependsOnTargets="ImplicitlyExpandTargetFramework">
    <PropertyGroup>
      <_PortablePriResourcesEnabled Condition="'%(ReferencePath.FileName)' == 'System.Runtime.WindowsRuntime.UI.Xaml'">true</_PortablePriResourcesEnabled>
    </PropertyGroup>

    <PropertyGroup Condition="'$(_PortablePriResourcesEnabled)' != 'true'">
      <AppxGeneratePriEnabled>false</AppxGeneratePriEnabled>
      <AppxGeneratePrisForPortableLibrariesEnabled>false</AppxGeneratePrisForPortableLibrariesEnabled>
      <AppxGetPackagePropertiesEnabled>false</AppxGetPackagePropertiesEnabled>
      <IncludeProjectPriFile>false</IncludeProjectPriFile>
    </PropertyGroup>
  </Target>

  <!-- .pri files may contain asset files that are not included as part of the project outputs, because of this we need to expand the pri and add the files to the copy local output -->
  <Target Name="AddPriPayloadFilesToCopyToOutputDirectoryItems" Condition="'$(AppxGeneratePriEnabled)' != 'false' AND '$(SkipAddPriPayloadFilesToCopyToOutputDirectoryItems)' != 'true'" DependsOnTargets="_GetSdkToolPaths;$(AllOutputGroupsDependsOn)">
    <ItemGroup>
      <_PriFilesToExpandFromReference Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pri'"/>
      <_PriFilesToExpandFromReference Include="@(ReferenceCopyLocalPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pri'" KeepDuplicates="false" />
    </ItemGroup>

    <ExpandPriContent Condition="'$(MakePriExeFullPath)' != ''"
                      Inputs="@(_PriFilesToExpandFromReference)"
                      MakePriExeFullPath="$(MakePriExeFullPath)"
                      MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                      IntermediateDirectory="$(IntermediateOutputPath)"
                      AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)"
                      ExcludeXamlFromLibraryLayoutsWhenXbfIsPresent="$(AppxExcludeXamlFromLibraryLayoutsWhenXbfIsPresent)"
                      VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Expanded" ItemName="_ExtraPriPayloadFiles" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>

    <ItemGroup>
      <_AllChildProjectItemsWithTargetPath Include="@(_ExtraPriPayloadFiles)" KeepMetadata="TargetPath">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      </_AllChildProjectItemsWithTargetPath>
    </ItemGroup>
  </Target>

  <!-- Expand content of project PRI file. -->
  <Target Name="_ExpandMainPriFile">

    <ExpandPriContent Inputs="$(AppxBundleSplitResourcesPriPath)"
                      MakePriExeFullPath="$(MakePriExeFullPath)"
                      MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                      IntermediateDirectory="$(IntermediateOutputPath)"
                      AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)"
                      VsTelemetrySession="$(VsTelemetrySession)"
                          >
      <Output TaskParameter="Expanded" ItemName="IndexedMainPayloadFiles" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>

  </Target>

  <!-- Expand content of PRI files. -->
  <Target Name="_ExpandPriFiles">

    <ItemGroup>
      <_PriFilesToExpand Include="@(_PriFilesFromPayload)"
                         Condition="'%(OutputGroup)' != 'ProjectPriFile'
                                      and '%(OutputGroup)' != 'SDKRedistOutputGroup'"
                               />
    </ItemGroup>

    <ExpandPriContent Inputs="@(_PriFilesToExpand)"
                      MakePriExeFullPath="$(MakePriExeFullPath)"
                      MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                      IntermediateDirectory="$(IntermediateOutputPath)"
                      AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)"
                      ExcludeXamlFromLibraryLayoutsWhenXbfIsPresent="$(AppxExcludeXamlFromLibraryLayoutsWhenXbfIsPresent)"
                      VsTelemetrySession="$(VsTelemetrySession)"
                      >
      <Output TaskParameter="Expanded" ItemName="_ExpandedPriPayload" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>

  </Target>

  <!-- Expand content of PRI files. -->
  <Target Name="_ExpandPriUploadFiles"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <_PriUploadFilesToExpand Include="@(_PriFilesFromPayload)"
                               Condition="'%(OutputGroup)' != 'ProjectPriUploadFile'
                                      and '%(OutputGroup)' != 'ProjectPriFile'
                                      and '%(OutputGroup)' != 'SDKRedistOutputGroup'"
                               />
    </ItemGroup>

    <ExpandPriContent Inputs="@(_PriUploadFilesToExpand)"
                      MakePriExeFullPath="$(MakePriExeFullPath)"
                      MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                      IntermediateDirectory="$(IntermediateOutputPath)"
                      AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)"
                      ExcludeXamlFromLibraryLayoutsWhenXbfIsPresent="$(AppxExcludeXamlFromLibraryLayoutsWhenXbfIsPresent)"
                      VsTelemetrySession="$(VsTelemetrySession)"
                      >
      <Output TaskParameter="Expanded" ItemName="_ExpandedPriUploadPayload" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>

  </Target>

  <!-- Override to specify actions to happen after generating project PRI file. -->
  <Target Name="AfterGenerateProjectPriFile" />

  <PropertyGroup>
    <_ProjectArchitecturesFilePath>$(IntermediateOutputPath)ProjectArchitectures.txt</_ProjectArchitecturesFilePath>
  </PropertyGroup>

  <!-- Add Union winmd to payload if Appx contains managed component to make JITer happy -->
  <Target Name="_AddUnionWinmd" Condition="'$(AppxPackage)' == 'true' AND '$(TargetPlatformIdentifier)' == 'UAP' AND $(SkipUnionWinmd) != 'true'">

    <ItemGroup>
      <_PackagingOutputWinmd Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd'" />
    </ItemGroup>

    <GetUnionWinmdPropertyValues TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
                                 WinmdFiles="@(_PackagingOutputWinmd)"
                                 VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="UnionWinmdRequired" PropertyName="_UnionWinmdRequired" />
    </GetUnionWinmdPropertyValues>

    <GetSdkPropertyValue TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                         SDKIdentifier="$(SDKIdentifier)"
                         SDKVersion="$(SDKVersion)"
                         TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                         TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                         TargetPlatformVersion="$(TargetPlatformVersion)"
                         PropertyName="WindowsSDK_UnionMetadataPath"
                         VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="PropertyValue" PropertyName="_UnionMetadataPath" />
    </GetSdkPropertyValue>

    <ItemGroup>
      <UnionWinmdPath Condition="'$(_UnionMetadataPath)' == ''" Include="$(_TargetPlatformSdkDir)UnionMetadata\Windows.winmd"/>
      <UnionWinmdPath Condition="'$(_UnionMetadataPath)' != ''" Include="$(_UnionMetadataPath)\Windows.winmd"/>

      <UnionMetadataWinmd Include="@(UnionWinmdPath)" Condition="Exists(@(UnionWinmdPath)) AND ('IncludeWindowsSdkWinmd' == 'true' OR '$(_UnionWinmdRequired)' == 'true')">
        <ResolvedFrom>GetSDKReferenceFiles</ResolvedFrom>
        <SkipHarvestingWinmdRegistration>true</SkipHarvestingWinmdRegistration>
        <TargetPath>$(WinMetadataDir)\Windows.winmd</TargetPath>
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </UnionMetadataWinmd>

      <PackagingOutputs Include="@(UnionMetadataWinmd)" />
    </ItemGroup>

  </Target>

  <!-- Add referenced winmds from Framework SDKs -->
  <Target Name="_AddFxWinmd"
          Condition="'$(AppxPackage)' == 'true' AND
                     '$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <_FrameworkSdkReference Include="@(ResolvedSDKReference)" Condition=" '%(ResolvedSDKReference.FrameworkIdentity)' != '' " />
    </ItemGroup>

    <PropertyGroup>
      <_FrameworkSdkNames>@(_FrameworkSdkReference->'%(SDKName)', ';')</_FrameworkSdkNames>
    </PropertyGroup>

    <ItemGroup>
      <WinmdsFromFrameworkSDKs Include="@(ReferencesFromSDK)"
                               Condition="$(_FrameworkSdkNames.Contains('%(ReferencesFromSDK.ReferenceFromSDK)')) and
                                          '%(ReferencesFromSDK.WinMDFile)'=='true'" >
        <SkipHarvestingWinmdRegistration>true</SkipHarvestingWinmdRegistration>
        <TargetPath>$(WinMetadataDir)\$([System.IO.Path]::GetFileName(%(ReferencesFromSDK.Identity)))</TargetPath>
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </WinmdsFromFrameworkSDKs>
      <PackagingOutputs Include="@(WinmdsFromFrameworkSDKs)" />
    </ItemGroup>
  </Target>

  <!-- =================================================================================================== -->
  <!-- Computes the AppxUpload creation flag for UAP if the user did not specify a UapAppxPackageBuildMode -->
  <!-- =================================================================================================== -->
  <Target Name="_ComputeBuildAppxUploadPackageForUapFlag"
          DependsOnTargets="_FindStoreAssociationFile">

    <!-- When buildling from the commandline, if the BuildMode is NOT set but an AppxUpload package is requested, we have to make a couple extra checks -->
    <PropertyGroup Condition="'$(BuildingInsideVisualStudio)' != 'true' and
                              '$(UapAppxPackageBuildModeIsValid)' == 'false' and
                              '$(BuildAppxUploadPackageForUap)' != ''">

      <!-- First, we assume that this flow should NOT be creating an .appxupload/.msixupload package -->
      <BuildAppxUploadPackageForUap>false</BuildAppxUploadPackageForUap>

      <!-- If we are here, the build mode was NOT explicitly set. So, only produce an .appxupload/.msixupload if:
        - we are in the UAP pipeline
        - AND the .NetNative toolchain is not disabled (doing a negative check as non .net platforms may leave this value blank)
        - AND the project configuration is not Debug (doing a negative check to avoid ruling out custom build configurations)
        - AND the store association file exists
      -->
      <BuildAppxUploadPackageForUap Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and
                                               '$(UseDotNetNativeToolchain)' != 'false' and
                                               '$(Configuration)' != 'Debug' and
                                               '%(StoreAssociationFile.Identity)' != ''">true</BuildAppxUploadPackageForUap>
    </PropertyGroup>

  </Target>

  <!-- ================================================================================================== -->
  <!-- Computes Appx package payload that will be included in the appx package (excluding Appx manifest). -->
  <!-- ================================================================================================== -->
  <Target Name="_ComputeAppxPackagePayload"
          Condition="'$(AppxPackage)' == 'true'"
          DependsOnTargets="_FindSourceAppxContentGroupMap">

    <RemoveRedundantCopyLocalItems Condition="'$(AppxRemoveRedundantCopyLocalItems)' == 'true'"
                                   Inputs="@(PackagingOutputs)"
                                   VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_PackagingOutputsWithoutRedundantCopyLocalItems" />
    </RemoveRedundantCopyLocalItems>

    <ItemGroup Condition="'$(AppxRemoveRedundantCopyLocalItems)' != 'true'">
      <_PackagingOutputsWithoutRedundantCopyLocalItems Include="@(PackagingOutputs)" />
    </ItemGroup>

    <ItemGroup>
      <_UnfilteredAppxPackagePayload Include="@(_PackagingOutputsWithoutRedundantCopyLocalItems)" Condition="'%(Extension)' != '.pri' AND
                                                                                                             '%(OutputGroup)' != 'GetResolvedSDKReferences' AND
                                                                                                             '%(OutputGroup)' != '_GetProjectArchitecture' AND
                                                                                                             '%(OutputGroup)' != 'EmbedOutputGroupForPackaging'"/>
      <_UnfilteredAppxPackagePayload Include="@(_ExpandedPriPayload)" />
      <_UnfilteredAppxPackagePayload Include="@(ProjectPriFile)" />
    </ItemGroup>

    <!-- Users can manually populate the AppxPackagePayload. In the .NetNative case, this is handled by ILC. Otherwise, we need to retain those files -->
    <ItemGroup Condition="'$(UseDotNetNativeToolchain)' != 'true'">

      <!-- If the user added a payload with a rooted path, we can safely use that -->
      <_UnfilteredAppxPackagePayload Condition="$([System.IO.Path]::IsPathRooted('%(Identity)')) == 'true'"
                                     Include="@(AppxPackagePayload->'%(Identity)')">
        <TargetPath>$([System.String]::Copy('%(TargetPath)').Replace('\\','\'))</TargetPath>
      </_UnfilteredAppxPackagePayload>

      <!-- If the user added a payload with a relative path, we make the assumption that it's relative to the project root and build out the full path -->
      <_UnfilteredAppxPackagePayload Condition="$([System.IO.Path]::IsPathRooted('%(Identity)')) == 'false'"
                                     Include="@(AppxPackagePayload->'$(MSBuildProjectDirectory)\%(Identity)')">
        <TargetPath>$([System.String]::Copy('%(TargetPath)').Replace('\\','\'))</TargetPath>
      </_UnfilteredAppxPackagePayload>

      <!-- Reset the AppxPackagePayload to avoid duplicate entries later -->
      <AppxPackagePayload Remove="@(AppxPackagePayload)"/>
    </ItemGroup>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_UnfilteredAppxUploadPackagePayload Include="@(_PackagingOutputsWithoutRedundantCopyLocalItems)" Condition="'%(Extension)' != '.pri' AND
                                                                                                                   '%(OutputGroup)' != 'GetResolvedSDKReferences' AND
                                                                                                                   '%(OutputGroup)' != '_GetProjectArchitecture' AND
                                                                                                                   '%(OutputGroup)' != 'EmbedOutputGroupForPackaging'"/>
      <_UnfilteredAppxUploadPackagePayload Include="@(_ExpandedPriUploadPayload)" />
      <_UnfilteredAppxUploadPackagePayload Include="@(ProjectPriUploadFile)" />
    </ItemGroup>

    <RemovePayloadDuplicates Inputs="@(_UnfilteredAppxPackagePayload)"
                             HasSharedItems="$(HasSharedItems)"
                             MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="AppxPackagePayload" />
    </RemovePayloadDuplicates>

    <RemovePayloadDuplicates Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
                             Inputs="@(_UnfilteredAppxUploadPackagePayload)"
                             HasSharedItems="$(HasSharedItems)"
                             MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="DeDupedAppxUploadPackagePayload" />
    </RemovePayloadDuplicates>

    <!--
        If packaging outputs contain a file named AppxManifest.xml, this is an override manifest and it is handled elsewhere.
        If packaging outputs contain the store association file, we need to remove it. Furthermore,
        we need to remove the SourceAppxContentGroupMap file, or if producing an Appx Bundle, the AppxContentGroupMap as well.
        Except for builds using PackageLayout - in that case, we leave the AppxContentGroupMap in.
    -->
    <ItemGroup>
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(TargetPath)' == '$(AppxManifestFileName)'" />
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(TargetPath)' == 'Package.StoreAssociation.xml'"/>
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(TargetPath)' == 'SourceAppxContentGroupMap.xml'"/>
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'$(UseAppxLayout)' != 'true' AND
                                                                    '$(ProduceAppxBundle)' == 'true' AND
                                                                    '%(TargetPath)' == 'AppxContentGroupMap.xml'"/>

      <!-- If we're flat bundling, remove any assets that will be placed in the dedicated asset package. -->
      <AppxPackagePayload Remove="@(_AppxLayoutAssetPackageFiles)" Condition="'$(UseAppxLayout)' == 'true'" />
    </ItemGroup>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <DeDupedAppxUploadPackagePayload Remove="@(DeDupedAppxUploadPackagePayload)" Condition="'%(TargetPath)' == '$(AppxManifestFileName)'" />
    </ItemGroup>

    <!-- If we are NOT going through the .Net Native toolchain, this generated payload becomes the payload we'll package for upload -->
    <ItemGroup Condition="'$(UseDotNetNativeToolchain)' != 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxUploadPackagePayload Include="@(DeDupedAppxUploadPackagePayload)"/>
    </ItemGroup>

    <!-- If the Upload packaging outputs contain the store association file, the SourceAppxContentGroupMap file, 
         or if producing an Appx Bundle, the AppxContentGroupMap, we need to remove it
         Except for builds using PackageLayout - in that case, we leave the AppxContentGroupMap in.
    -->
    <ItemGroup>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(TargetPath)' == 'Package.StoreAssociation.xml'"/>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(TargetPath)' == 'SourceAppxContentGroupMap.xml'"/>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'$(UseAppxLayout)' != 'true' AND
                                                                                '$(ProduceAppxBundle)' == 'true' AND
                                                                                '%(TargetPath)' == 'AppxContentGroupMap.xml'"/>

      <!-- If we're flat bundling, remove any assets that will be placed in the dedicated asset package. -->
      <AppxUploadPackagePayload Remove="@(_AppxLayoutAssetPackageFiles)" Condition="'$(UseAppxLayout)' == 'true'" />
    </ItemGroup>

    <ItemGroup>
      <_ProjectArchitectureFromPayload Include="@(PackagingOutputs)"
                                       Condition="'%(PackagingOutputs.OutputGroup)' == '_GetProjectArchitecture'
                                                    AND '%(PackagingOutputs.MSBuildSourceProjectFile)' != ''"
                                             />
      <_ProjectArchitectureFromPayload Include="@(PackagingOutputs)"
                                       Condition="'%(PackagingOutputs.OutputGroup)' == '_GetProjectArchitecture'
                                                    AND '%(PackagingOutputs.MSBuildSourceProjectFile)' == ''"
                                             >
        <MSBuildSourceProjectFile>$(MSBuildProjectFullPath)</MSBuildSourceProjectFile>
      </_ProjectArchitectureFromPayload>
    </ItemGroup>

    <GenerateProjectArchitecturesFile
        ProjectArchitectures="@(_ProjectArchitectureFromPayload)"
        ProjectArchitecturesFilePath="$(_ProjectArchitecturesFilePath)"
        VsTelemetrySession="$(VsTelemetrySession)"
            />

    <ItemGroup>
      <FileWrites Include="$(_ProjectArchitecturesFilePath)" />
    </ItemGroup>

  </Target>

  <!-- BEGIN APPXLAYOUT PREPARATION -->

  <!-- ==================================================================================== -->
  <!-- Ingest AppxLayout files.                                                             -->
  <!-- Happens prior to kicking off any other work.                                         -->
  <!-- ==================================================================================== -->
  <PropertyGroup>
    <_ReadAppxLayoutDependsOn>
      _FindAppxLayoutFile;
      _ReadAppxLayoutTemplate;
    </_ReadAppxLayoutDependsOn>
  </PropertyGroup>

  <Target Name="_ReadAppxLayout"
          Condition="'$(AppxLayoutEnabled)' == 'true'"
          DependsOnTargets="$(_ReadAppxLayoutDependsOn)"/>

  <!-- ===================================================================================== -->
  <!-- Locate the .packagelayout file.                                                          -->
  <!-- ===================================================================================== -->
  <Target Name="_FindAppxLayoutFile">

    <ItemGroup Condition="'@(AppxLayoutFile)' == ''">
      <AppxLayoutFile Include="@(PackageLayout)" Condition="'%(Identity)' != ''" />
      <AppxLayoutFile Include="@(Content)" Condition="'%(Identity)' == '$(AppxLayoutFileName)' and '$(AppxLayoutFile)' == ''" />
      <AppxLayoutFile Include="@(Text)" Condition="'%(Identity)' == '$(AppxLayoutFileName)' and '$(AppxLayoutFile)' == ''" />
      <None Remove="@(PackageLayout)" Condition="'%(Identity)' == '$(AppxLayoutFileName)'" />
    </ItemGroup>

    <PropertyGroup>
      <UseAppxLayout Condition="'%(AppxLayoutFile.Identity)' == ''">false</UseAppxLayout>
      <UseAppxLayout Condition="'%(AppxLayoutFile.Identity)' != ''">true</UseAppxLayout>
    </PropertyGroup>

  </Target>

  <!-- ===================================================================================== -->
  <!-- Getting template components.                                                          -->
  <!-- ===================================================================================== -->
  <Target Name="_ReadAppxLayoutTemplate"
          Condition="'$(UseAppxLayout)' == 'true'">

    <ReadAppxLayoutTemplate AppxLayoutTemplatePath="@(AppxLayoutFile)"
                            GenerateSideloadItems="$(BuildAppxSideloadPackageForUap)"
                            GenerateUploadItems="$(BuildAppxUploadPackageForUap)"
                            VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="AppxLayoutIsValid" PropertyName="_UseAppxLayoutFlag" />
      <Output TaskParameter="AppxLayoutIsTemplate" PropertyName="_AppxLayoutIsTemplateFlag" />

      <Output TaskParameter="GeneratedPackageFamilies" ItemName="_GeneratedPackageFamilies" />
      <Output TaskParameter="GeneratedPackages" ItemName="_GeneratedPackages" />
      <Output TaskParameter="GeneratedResourcePackages" ItemName="_GeneratedResourcePackages" />
      <Output TaskParameter="GeneratedAssetPackages" ItemName="_GeneratedAssetPackages" />

      <Output Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" TaskParameter="PackageFamilies" ItemName="_PackageFamilies" />
      <Output Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" TaskParameter="Packages" ItemName="_Packages" />
      <Output Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" TaskParameter="ResourcePackages" ItemName="_ResourcePackages" />
      <Output Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" TaskParameter="AssetPackages" ItemName="_AssetPackages" />
      <Output Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" TaskParameter="Files" ItemName="_Files" />
      <Output Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" TaskParameter="Resources" ItemName="_Resources" />

      <Output Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" TaskParameter="UploadPackageFamilies" ItemName="_UploadPackageFamilies" />
      <Output Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" TaskParameter="UploadPackages" ItemName="_UploadPackages" />
      <Output Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" TaskParameter="UploadResourcePackages" ItemName="_UploadResourcePackages" />
      <Output Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" TaskParameter="UploadAssetPackages" ItemName="_UploadAssetPackages" />
      <Output Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" TaskParameter="UploadFiles" ItemName="_UploadFiles" />
      <Output Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" TaskParameter="UploadResources" ItemName="_UploadResources" />

      <Output TaskParameter="OptionalPackages" ItemName="_OptionalPackages" />
      <Output TaskParameter="PrebuiltPackages" ItemName="_PrebuiltPackages" />

      <Output TaskParameter="AssetPackageFiles" ItemName="_AssetPackageFiles" />
    </ReadAppxLayoutTemplate>

    <ItemGroup>
      <_AppxLayoutGeneratedPackageFamilies Include="@(_GeneratedPackageFamilies)" />
      <_AppxLayoutGeneratedPackages Include="@(_GeneratedPackages)" />
      <_AppxLayoutGeneratedResourcePackages Include="@(_GeneratedResourcePackages)" />
      <_AppxLayoutGeneratedAssetPackages Include="@(_GeneratedAssetPackages)" />
      <_AppxLayoutOptionalPackages Include="@(_OptionalPackages)"/>
      <_AppxLayoutPrebuiltPackages Include="@(_PrebuiltPackages)"/>
      <_AppxLayoutAssetPackageFiles Include="@(_AssetPackageFiles)"/>
    </ItemGroup>

    <ItemGroup Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
      <_AppxLayoutPackageFamilies Include="@(_PackageFamilies)"/>
      <_AppxLayoutPackages Include="@(_Packages)"/>
      <_AppxLayoutResourcePackages Include="@(_ResourcePackages)"/>
      <_AppxLayoutAssetPackages Include="@(_AssetPackages)"/>
      <_AppxLayoutFiles Include="@(_Files)"/>
      <_AppxLayoutResources Include="@(_Resources)"/>
    </ItemGroup>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_AppxLayoutUploadPackageFamilies Include="@(_UploadPackageFamilies)"/>
      <_AppxLayoutUploadPackages Include="@(_UploadPackages)"/>
      <_AppxLayoutUploadResourcePackages Include="@(_UploadResourcePackages)"/>
      <_AppxLayoutUploadAssetPackages Include="@(_UploadAssetPackages)"/>
      <_AppxLayoutUploadFiles Include="@(_UploadFiles)"/>
      <_AppxLayoutUploadResources Include="@(_UploadResources)"/>
    </ItemGroup>

    <PropertyGroup>
      <UseAppxLayout>$(_UseAppxLayoutFlag)</UseAppxLayout>
      <AppxLayoutIsTemplate>$(_AppxLayoutIsTemplateFlag)</AppxLayoutIsTemplate>
    </PropertyGroup>

  </Target>

  <!-- ===================================================================================== -->
  <!-- Convert any GeneratedPackage templates into actual Package entries.                   -->
  <!-- ===================================================================================== -->
  <Target Name="_HydrateAppxLayoutMainPackage"
          Condition="'$(UseAppxLayout)' == 'true' and
                     '$(AppxLayoutIsTemplate)' == 'true'">

    <!-- Generate SIDELOAD PackageFamilies and Packages from the template, if requested -->
    <HydrateAppxLayoutPackage Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'"
                              GeneratedPackageFamilies="@(_AppxLayoutGeneratedPackageFamilies)"
                              GeneratedPackages="@(_AppxLayoutGeneratedPackages)"
                              PackageFamilies="@(_AppxLayoutPackageFamilies)"
                              Packages="@(_AppxLayoutPackages)"
                              PackageExtPrefix="$(PackageExtPrefix)"
                              Platforms="$(AppxBundlePlatforms)"
                              Architecture="$(PackageArchitecture)"
                              FileMap="$(AppxBundleMainPackageFileMapPath)"
                              ContentGroupMap="$(AppxContentGroupMapFullPath)"
                              PackageFamilyManifest="@(FinalAppxManifest)"
                              PackageManifest="@(AppxManifestForBundle)"
                              AppName="$(ProjectName)"
                              AppVersion="$(AppxManifestIdentityVersion)"
                              VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="NewPackageFamilies" ItemName="HydratePackagePackageFamilies"/>
      <Output TaskParameter="NewPackages" ItemName="HydratePackagePackages"/>
      <Output TaskParameter="NewFiles" ItemName="HydratePackageFiles"/>
      <Output TaskParameter="NewResources" ItemName="HydratePackageResources"/>
    </HydrateAppxLayoutPackage>

    <ItemGroup Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
      <_AppxLayoutPackageFamilies Include="@(HydratePackagePackageFamilies)"/>
      <_AppxLayoutPackages Include="@(HydratePackagePackages)"/>
      <_AppxLayoutFiles Include="@(HydratePackageFiles)"/>
      <_AppxLayoutResources Include="@(HydratePackageResources)"/>
    </ItemGroup>

    <!-- Generate UPLOAD PackageFamilies and Packages from the template, if requested -->
    <HydrateAppxLayoutPackage Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
                              GeneratedPackageFamilies="@(_AppxLayoutGeneratedPackageFamilies)"
                              GeneratedPackages="@(_AppxLayoutGeneratedPackages)"
                              PackageFamilies="@(_AppxLayoutUploadPackageFamilies)"
                              Packages="@(_AppxLayoutUploadPackages)"
                              PackageExtPrefix="$(PackageExtPrefix)"
                              Platforms="$(AppxBundlePlatforms)"
                              Architecture="$(PackageArchitecture)"
                              FileMap="$(AppxUploadBundleMainPackageFileMapPath)"
                              ContentGroupMap="$(AppxContentGroupMapFullPath)"
                              PackageFamilyManifest="@(FinalAppxUploadManifest)"
                              PackageManifest="@(AppxUploadManifestForBundle)"
                              AppName="$(ProjectName)"
                              AppVersion="$(AppxManifestIdentityVersion)"
                              VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="NewPackageFamilies" ItemName="HydratePackageUploadPackageFamilies"/>
      <Output TaskParameter="NewPackages" ItemName="HydratePackageUploadPackages"/>
      <Output TaskParameter="NewFiles" ItemName="HydratePackageUploadFiles"/>
      <Output TaskParameter="NewResources" ItemName="HydratePackageUploadResources"/>
    </HydrateAppxLayoutPackage>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_AppxLayoutUploadPackageFamilies Include="@(HydratePackageUploadPackageFamilies)"/>
      <_AppxLayoutUploadPackages Include="@(HydratePackageUploadPackages)"/>
      <_AppxLayoutUploadFiles Include="@(HydratePackageUploadFiles)"/>
      <_AppxLayoutUploadResources Include="@(HydratePackageUploadResources)"/>
    </ItemGroup>
  </Target>

  <!-- ===================================================================================== -->
  <!-- Convert any GeneratedResourcePackage templates into actual ResourcePackage entries.   -->
  <!-- ===================================================================================== -->
  <Target Name="_HydrateAppxLayoutResourcePackage"
          Condition="'$(UseAppxLayout)' == 'true' and
                     '$(AppxLayoutIsTemplate)' == 'true'">

    <!-- Generate SIDELOAD ResourcePackages from the template -->
    <HydrateAppxLayoutResourcePackage Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'"
                                      GeneratedResourcePackages="@(_AppxLayoutGeneratedResourcePackages)"
                                      PackageFamilies="@(_AppxLayoutPackageFamilies)"
                                      PackageExtPrefix="$(PackageExtPrefix)"
                                      ResourcePackages="@(_AppxLayoutResourcePackages)"
                                      FileMaps="@(_AppxBundleResourceFileMaps)"
                                      ContentGroupMap="$(AppxContentGroupMapFullPath)"
                                      PackageManifest="@(AppxManifestForBundle)"
                                      AppName="$(ProjectName)"
                                      AppVersion="$(AppxManifestIdentityVersion)"
                                      VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="NewResourcePackages" ItemName="HydrateResPackResourcePackages"/>
      <Output TaskParameter="NewFiles" ItemName="HydrateResPackFiles"/>
      <Output TaskParameter="NewResources" ItemName="HydrateResPackResources"/>
    </HydrateAppxLayoutResourcePackage>

    <ItemGroup Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
      <_AppxLayoutResourcePackages Include="@(HydrateResPackResourcePackages)"/>
      <_AppxLayoutFiles Include="@(HydrateResPackFiles)"/>
      <_AppxLayoutResources Include="@(HydrateResPackResources)"/>
    </ItemGroup>

    <!-- Generate UPLOAD ResourcePackages from the template -->
    <HydrateAppxLayoutResourcePackage Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
                                      GeneratedResourcePackages="@(_AppxLayoutGeneratedResourcePackages)"
                                      PackageFamilies="@(_AppxLayoutUploadPackageFamilies)"
                                      PackageExtPrefix="$(PackageExtPrefix)"
                                      ResourcePackages="@(_AppxLayoutUploadResourcePackages)"
                                      FileMaps="@(_AppxUploadBundleResourceFileMaps)"
                                      ContentGroupMap="$(AppxContentGroupMapFullPath)"
                                      PackageManifest="@(AppxUploadManifestForBundle)"
                                      AppName="$(ProjectName)"
                                      AppVersion="$(AppxManifestIdentityVersion)"
                                      VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="NewResourcePackages" ItemName="HydrateResPackUploadResourcePackages"/>
      <Output TaskParameter="NewFiles" ItemName="HydrateResPackUploadFiles"/>
      <Output TaskParameter="NewResources" ItemName="HydrateResPackUploadResources"/>
    </HydrateAppxLayoutResourcePackage>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_AppxLayoutUploadResourcePackages Include="@(HydrateResPackUploadResourcePackages)"/>
      <_AppxLayoutUploadFiles Include="@(HydrateResPackUploadFiles)"/>
      <_AppxLayoutUploadResources Include="@(HydrateResPackUploadResources)"/>
    </ItemGroup>
  </Target>

  <!-- ===================================================================================== -->
  <!-- Convert any GeneratedAssetPackage templates into actual AssetPackage entries.   -->
  <!-- ===================================================================================== -->
  <Target Name="_HydrateAppxLayoutAssetPackage"
          Condition="'$(UseAppxLayout)' == 'true' and
                     '$(AppxLayoutIsTemplate)' == 'true' and
                     ('$(AppxBundlePlatforms)' == '' or '$(AppxBundleProducingPlatform)' == '$(PackageArchitecture)')">

    <HydrateAppxLayoutAssetPackage Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'"
                                   GeneratedAssetPackages="@(_AppxLayoutGeneratedAssetPackages)"
                                   PackageFamilies="@(_AppxLayoutPackageFamilies)"
                                   PackageExtPrefix="$(PackageExtPrefix)"
                                   AssetPackages="@(_AppxLayoutAssetPackages)"
                                   PackageManifest="@(AppxManifestForBundle)"
                                   AppName="$(ProjectName)"
                                   AppVersion="$(AppxManifestIdentityVersion)"
                                   VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="NewAssetPackages" ItemName="HydrateAssetPackAssetPackages"/>
      <Output TaskParameter="NewFiles" ItemName="HydrateAssetPackFiles"/>
    </HydrateAppxLayoutAssetPackage>

    <ItemGroup Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
      <_AppxLayoutAssetPackages Include="@(HydrateAssetPackAssetPackages)"/>
      <_AppxLayoutFiles Include="@(HydrateAssetPackFiles)"/>
    </ItemGroup>

    <HydrateAppxLayoutAssetPackage Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
                                   GeneratedAssetPackages="@(_AppxLayoutGeneratedAssetPackages)"
                                   PackageFamilies="@(_AppxLayoutUploadPackageFamilies)"
                                   PackageExtPrefix="$(PackageExtPrefix)"
                                   AssetPackages="@(_AppxLayoutUploadAssetPackages)"
                                   PackageManifest="@(AppxUploadManifestForBundle)"
                                   AppName="$(ProjectName)"
                                   AppVersion="$(AppxManifestIdentityVersion)"
                                   VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="NewAssetPackages" ItemName="HydrateAssetPackUploadAssetPackages"/>
      <Output TaskParameter="NewFiles" ItemName="HydrateAssetPackUploadFiles"/>
    </HydrateAppxLayoutAssetPackage>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_AppxLayoutUploadAssetPackages Include="@(HydrateAssetPackUploadAssetPackages)"/>
      <_AppxLayoutUploadFiles Include="@(HydrateAssetPackUploadFiles)"/>
    </ItemGroup>

  </Target>

  <!-- ===================================================================================== -->
  <!-- Convert any Optional or External packages into actual PrebuiltPackage entries.        -->
  <!--   NOTE: this step needs to happen even for non-template appxlayouts                   -->
  <!--         since we can't handle true optional PackageFamily entries.                    -->
  <!-- ===================================================================================== -->
  <Target Name="_HydrateAppxLayoutPrebuiltPackage"
          Condition="'$(UseAppxLayout)' == 'true' and
                     '$(AppxLayoutIsTemplate)' == 'true' and
                     ('$(AppxBundlePlatforms)' == '' or '$(AppxBundleProducingPlatform)' == '$(PackageArchitecture)')">

    <HydrateAppxLayoutPrebuiltPackage Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'"
                                      PrebuiltPackages="@(_AppxLayoutPrebuiltPackages)"
                                      ExternalPackages="@(BundleMappingSideloadExternalPackages)"
                                      VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FinalPrebuiltPackage" ItemName="HydratePrebuiltPrebuildPackages"/>
    </HydrateAppxLayoutPrebuiltPackage>

    <ItemGroup Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
      <_AppxLayoutFinalPrebuiltPackages Include="@(HydratePrebuiltPrebuildPackages)"/>
    </ItemGroup>

    <HydrateAppxLayoutPrebuiltPackage Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
                                      PrebuiltPackages="@(_AppxLayoutPrebuiltPackages)"
                                      ExternalPackages="@(BundleMappingUploadExternalPackages)"
                                      VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FinalPrebuiltPackage" ItemName="HydratePrebuiltUploadPrebuildPackages"/>
    </HydrateAppxLayoutPrebuiltPackage>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_AppxLayoutUploadFinalPrebuiltPackages Include="@(HydratePrebuiltUploadPrebuildPackages)"/>
    </ItemGroup>

  </Target>

  <!-- ===================================================================================== -->
  <!-- Generate the platform AppxLayout file for sideload package bundling.                  -->
  <!-- ===================================================================================== -->
  <Target Name="_CreatePlatformAppxLayoutFiles"
          Condition="'$(UseAppxLayout)' == 'true' and
                     '$(AppxLayoutIsTemplate)' == 'true'">

    <GenerateAppxLayout Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'"
                        AppxLayoutFile="$(PlatformAppxLayoutFile)"
                        Architecture="$(PackageArchitecture)"
                        PackageFamilies="@(_AppxLayoutPackageFamilies)"
                        Packages="@(_AppxLayoutPackages)"
                        ResourcePackages="@(_AppxLayoutResourcePackages)"
                        AssetPackages="@(_AppxLayoutAssetPackages)"
                        PrebuiltPackages="@(_AppxLayoutFinalPrebuiltPackages)"
                        Files="@(_AppxLayoutFiles)"
                        Resources="@(_AppxLayoutResources)"
                        VsTelemetrySession="$(VsTelemetrySession)">
    </GenerateAppxLayout>

    <GenerateAppxLayout Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
                        AppxLayoutFile="$(PlatformAppxLayoutUploadFile)"
                        Architecture="$(PackageArchitecture)"
                        PackageFamilies="@(_AppxLayoutUploadPackageFamilies)"
                        Packages="@(_AppxLayoutUploadPackages)"
                        ResourcePackages="@(_AppxLayoutUploadResourcePackages)"
                        AssetPackages="@(_AppxLayoutUploadAssetPackages)"
                        PrebuiltPackages="@(_AppxLayoutUploadFinalPrebuiltPackages)"
                        Files="@(_AppxLayoutUploadFiles)"
                        Resources="@(_AppxLayoutUploadResources)"
                        VsTelemetrySession="$(VsTelemetrySession)">
    </GenerateAppxLayout>
  </Target>

  <!-- ===================================================================================== -->
  <!-- Generate the final AppxLayout package.                                                -->
  <!-- ===================================================================================== -->
  <Target Name="_CreateAppxLayoutPackage"
          Inputs="$(MSBuildAllProjects);@(FinalAppxManifest);$(PackageCertificateKeyFile)"
          Outputs="$(AppxPackageOutput)"
          Condition="'$(BuildAppxSideloadPackageForUap)' == 'true' and
                     '$(UseAppxLayout)' == 'true'"
          DependsOnTargets="_DeleteAppxOutputFolderIfNecessary">

    <GenerateFinalAppxLayout AppxLayoutFile="$(PlatformAppxLayoutFile)"
                             Platforms="$(AppxBundlePlatforms)"
                             FinalAppxLayoutFile="$(FinalAppxLayoutFile)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="IsFlatBundle" PropertyName="_AppxLayoutFlatBundleIsFlat"/>
    </GenerateFinalAppxLayout>

    <MakeAppxFlatBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                        PackageLayout="$(FinalAppxLayoutFile)"
                        HashAlgorithmId="$(AppxHashAlgorithmId)"
                        AppxPackageDir="$(AppxPackageTestDir)"
                        Output="$(AppxPackageOutput)"
                        VsTelemetrySession="$(VsTelemetrySession)"/>

    <RemoveDir Directories="$(AppxPackageTestExternalPackagesDir)" />

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(BundleMappingSideloadExternalPackages)"
          DestinationFolder="$(AppxPackageTestExternalPackagesDir)"
              />

    <GetAppxFlatBundlePackages AppxPackageDir="$(AppxPackageTestDir)"
                               AppxBundleFinalName="$(AppxBundleNameForOutput)"
                               PackageExtPrefix="$(PackageExtPrefix)"
                               ReturnBundlesOnly="!$(_AppxLayoutFlatBundleIsFlat)"
                               VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="CreatedPackages" ItemName="AppxLayoutContents"/>
    </GetAppxFlatBundlePackages>

    <SignAppxPackages Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                      AppxPackagesToSign="@(AppxLayoutContents)"
                      CertificateThumbprint="$(PackageCertificateThumbprint)"
                      CertificateFile="$(PackageCertificateKeyFile)"
                      CertificatePassword="$(PackageCertificatePassword)"
                      HashAlgorithmId="$(AppxHashAlgorithmId)"
                      EnableSigningChecks="$(EnableSigningChecks)"
                      SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                      TempCertificateFilePath="$(TempCertificateFilePath)"
                      ExportCertificate="true"
                      VsTelemetrySession="$(VsTelemetrySession)"
                      SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)"
                      SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)"
                      AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)"
                      AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)"
                      AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)"
                      AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)"
                      AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)"
                      AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)"
                      AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)"
                      AzureKeyVaultUrl="$(AzureKeyVaultUrl)"
                      AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint"/>
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackages>

    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> $(AppxPackagePublicKeyFile)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> $(ResolvedThumbprint)" />

    <ItemGroup>
      <InstallerFileWrites Include="$(AppxPackagePublicKeyFile)" />
    </ItemGroup>
  </Target>

  <!-- ===================================================================================== -->
  <!-- Generate the final AppxLayout upload package.                                         -->
  <!-- ===================================================================================== -->
  <Target Name="_CreateAppxLayoutUploadPackage"
          Inputs="$(MSBuildAllProjects);@(FinalAppxUploadManifest);$(PackageCertificateKeyFile)"
          Outputs="$(AppxUploadPackageOutput)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true' and
                     '$(UseAppxLayout)' == 'true'">

    <!-- Package the Upload Appx -->

    <GenerateFinalAppxLayout AppxLayoutFile="$(PlatformAppxLayoutUploadFile)"
                             Platforms="$(AppxBundlePlatforms)"
                             FinalAppxLayoutFile="$(FinalAppxLayoutUploadFile)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="IsFlatBundle" PropertyName="_AppxLayoutUploadFlatBundleIsFlat"/>
    </GenerateFinalAppxLayout>

    <MakeAppxFlatBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                        PackageLayout="$(FinalAppxLayoutUploadFile)"
                        HashAlgorithmId="$(AppxHashAlgorithmId)"
                        AppxPackageDir="$(AppxUploadPackageDir)"
                        Output="$(AppxUploadPackageOutput)"
                        VsTelemetrySession="$(VsTelemetrySession)">
    </MakeAppxFlatBundle>

    <GetAppxFlatBundlePackages AppxPackageDir="$(AppxUploadPackageDir)"
                               AppxBundleFinalName="$(AppxBundleNameForOutput)"
                               PackageExtPrefix="$(PackageExtPrefix)"
                               ReturnBundlesOnly="!$(_AppxLayoutUploadFlatBundleIsFlat)"
                               VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="CreatedPackages" ItemName="AppxLayoutUploadContents"/>
    </GetAppxFlatBundlePackages>

    <SignAppxPackages Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                      AppxPackagesToSign="@(AppxLayoutUploadContents)"
                      CertificateThumbprint="$(PackageCertificateThumbprint)"
                      CertificateFile="$(PackageCertificateKeyFile)"
                      CertificatePassword="$(PackageCertificatePassword)"
                      HashAlgorithmId="$(AppxHashAlgorithmId)"
                      EnableSigningChecks="$(EnableSigningChecks)"
                      SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                      TempCertificateFilePath="$(TempCertificateFilePath)"
                      ExportCertificate="true"
                      VsTelemetrySession="$(VsTelemetrySession)"
                      SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)"
                      SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)"
                      AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)"
                      AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)"
                      AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)"
                      AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)"
                      AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)"
                      AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)"
                      AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)"
                      AzureKeyVaultUrl="$(AzureKeyVaultUrl)"
                      AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint"/>
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackages>

    <RemoveDir Directories="$(AppxUploadPackageExternalpackagesDir)" />

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(BundleMappingUploadExternalPackages)"
          DestinationFolder="$(AppxUploadPackageExternalPackagesDir)"
              />

    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> $(AppxPackagePublicKeyFile)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> $(ResolvedThumbprint)" />

    <ItemGroup>
      <InstallerFileWrites Include="$(AppxPackagePublicKeyFile)" />
    </ItemGroup>

  </Target>

  <!-- END APPXLAYOUT -->

  <!-- ==================================================================================== -->
  <!-- Generating Appx manifest.                                                            -->
  <!-- Happens after generating PRI file, for every project which can be packaged/deployed. -->
  <!-- ==================================================================================== -->

  <PropertyGroup>
    <_GenerateAppxManifestDependsOn>
      $(_GenerateAppxManifestDependsOn);
      BeforeGenerateAppxManifest;
      _GenerateAdditionalFrameworkSDKReference;
      _GetRecursiveResolvedSDKReferences;
      _CopyCurrentProjectAppxManifestOverride;
      _CopyCurrentProjectAppxUploadManifestOverride;
      _CalculateInputsForGenerateCurrentProjectAppxManifest;
      _GenerateCurrentProjectAppxManifest;
      _CreateFinalAppxManifestItem;
      _FindStoreAssociationFile;
      _ValidateAppxManifest;
      BeforeCopyAppxManifestToUpload;
      _CopyProjectAppxManifestToAppxUpload;
      AfterGenerateAppxManifest
    </_GenerateAppxManifestDependsOn>
  </PropertyGroup>

  <Target Name="BeforeCopyAppxManifestToUpload" />

  <Target Name="_GenerateAdditionalFrameworkSDKReference">

    <PropertyGroup>
      <_AdjustedPlatform Condition="'$(Platform)' != 'Win32'">$(Platform)</_AdjustedPlatform>
      <_AdjustedPlatform Condition="'$(Platform)' == 'Win32'">x86</_AdjustedPlatform>
    </PropertyGroup>

    <ItemGroup>
      <_IntermediateFrameworkSdkReference
        Include="@(AppxPackageRegistration)"
        Condition="'@(AppxPackageRegistration)' != ''
                   AND ('$(Configuration)' == '%(AppxPackageRegistration.Configuration)' OR '%(AppxPackageRegistration.Configuration)' == '')
                   AND ('$(_AdjustedPlatform)' == '%(AppxPackageRegistration.Architecture)' OR '%(AppxPackageRegistration.Configuration)' == '')">
        <SDKName Condition="%(AppxPackageRegistration.Name) != ''">%(AppxPackageRegistration.Name)</SDKName>
        <SDKName Condition="%(AppxPackageRegistration.Name) == ''">%(AppxPackageRegistration.Filename)</SDKName>
        <TargetedSDKConfiguration>%(AppxPackageRegistration.Configuration)</TargetedSDKConfiguration>
        <TargetedSDKArchitecture>%(AppxPackageRegistration.Architecture)</TargetedSDKArchitecture>
        <AppxLocation>%(AppxPackageRegistration.Identity)</AppxLocation>
      </_IntermediateFrameworkSdkReference>

      <FrameworkSdkReference Include="@(_IntermediateFrameworkSdkReference)">
        <FrameworkIdentity>Name = %(_IntermediateFrameworkSdkReference.SDKName), MinVersion = %(_IntermediateFrameworkSdkReference.Version), Publisher = %(_IntermediateFrameworkSdkReference.Publisher)</FrameworkIdentity>
      </FrameworkSdkReference>
    </ItemGroup>

  </Target>

  <Target Name="_GenerateAppxManifest"
          Condition="'$(AppxPackage)' == 'true'"
          DependsOnTargets="$(_GenerateAppxManifestDependsOn)"
            />

  <!-- Override to specify actions to happen before generating Appx manifest. -->
  <Target Name="BeforeGenerateAppxManifest" />

  <!-- Extract SDK references from the payload and filters out duplicates. -->
  <Target Name="_GetRecursiveResolvedSDKReferences">

    <ItemGroup>
      <_UnfilteredRecursiveResolvedSDKReference Include="@(PackagingOutputs)"
                                                Condition="'%(OutputGroup)' == 'GetResolvedSDKReferences'" />
    </ItemGroup>

    <RemoveDuplicateSDKReferences Inputs="@(_UnfilteredRecursiveResolvedSDKReference)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="RecursiveResolvedSDKReference" />
    </RemoveDuplicateSDKReferences>

    <ItemGroup>
      <FrameworkSdkReference Include="@(RecursiveResolvedSDKReference)"
                             Condition="'%(RecursiveResolvedSDKReference.FrameworkIdentity)' != ''"
                             />
    </ItemGroup>

    <ItemGroup>
      <NonFrameworkSdkReference Include="@(RecursiveResolvedSDKReference)"
                                Condition="'%(RecursiveResolvedSDKReference.FrameworkIdentity)' == ''"
                                />
    </ItemGroup>

    <!-- Add non-framework SDK versions to manifest build metadata. -->
    <ItemGroup>
      <AppxManifestMetadata Include="@(NonFrameworkSdkReference)">
        <Name>%(NonFrameworkSdkReference.SimpleName)</Name>
        <Version>%(NonFrameworkSdkReference.Version)</Version>
      </AppxManifestMetadata>
    </ItemGroup>

    <GetFrameworkSdkPackages FrameworkSdkReferences="@(FrameworkSdkReference)"
                             TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FrameworkSdkPackages" ItemName="FrameworkSdkPackage" />
    </GetFrameworkSdkPackages>

  </Target>

  <!-- Copy overriden AppxManifest.xml to final location. -->
  <!-- Inputs: [CustomAppxManifest] Name of the manifest file override. -->
  <!-- Outputs: [FinalAppxManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_CopyCurrentProjectAppxManifestOverride"
          Condition="Exists(@(CustomAppxManifest))"
          Inputs="$(MSBuildAllProjects);@(CustomAppxManifest)"
          Outputs="$(FinalAppxManifestName)">

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(CustomAppxManifest)"
          DestinationFiles="$(FinalAppxManifestName)"
              />

  </Target>

  <!-- Copy overriden upload AppxManifest.xml to final location. -->
  <!-- Inputs: [CustomAppxManifest] Name of the manifest file override. -->
  <!-- Outputs: [FinalAppxUploadManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_CopyCurrentProjectAppxUploadManifestOverride"
          Condition="Exists(@(CustomAppxManifest)) and '$(BuildAppxUploadPackageForUap)' == 'true'"
          Inputs="$(MSBuildAllProjects);@(CustomAppxManifest)"
          Outputs="$(FinalAppxUploadManifestName)">

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(CustomAppxManifest)"
          DestinationFiles="$(FinalAppxUploadManifestName)"/>

  </Target>

  <!-- Calculates list of input for _GenerateCurrentProjectAppxManifest target. -->
  <Target Name="_CalculateInputsForGenerateCurrentProjectAppxManifest">

    <ItemGroup Condition="'$(AppxHarvestWinmdRegistration)' == 'true'">
      <_WinmdFilesFromWinmdArtifacts Include="@(PackagingOutputs)"
                                     Condition="'%(PackagingOutputs.Extension)' == '.winmd'
                                            and '%(PackagingOutputs.OutputGroup)' == 'CopyWinmdArtifactsOutputGroup'
                                            and '%(PackagingOutputs.ProjectName)' != '$(ProjectName)'
                                            and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'"/>
      <_WinmdFilesFromReferences Include="@(PackagingOutputs)"
                                 Condition="'%(PackagingOutputs.Extension)' == '.winmd'
                                        and '%(PackagingOutputs.OutputGroup)' == 'CopyLocalFilesOutputGroup'
                                        and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
      <_WinmdFilesFromOtherGroups Include="@(PackagingOutputs)"
                                  Condition="'%(PackagingOutputs.Extension)' == '.winmd'
                                         and '%(PackagingOutputs.OutputGroup)' != 'CopyWinmdArtifactsOutputGroup'
                                         and '%(PackagingOutputs.OutputGroup)' != 'CopyLocalFilesOutputGroup'
                                         and '%(PackagingOutputs.ResolvedFrom)' != 'GetSDKReferenceFiles'
                                         and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
      <_WinmdFilesFromSDKs Include="@(PackagingOutputs)"
                           Condition="'%(PackagingOutputs.Extension)' == '.winmd'
                                  and '%(PackagingOutputs.ResolvedFrom)' == 'GetSDKReferenceFiles'
                                  and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
    </ItemGroup>

    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromWinmdArtifacts)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_AppxWinmdFilesToHarvest" />
    </RemovePayloadDuplicates>

    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromReferences)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_AppxWinmdFilesToHarvest" />
    </RemovePayloadDuplicates>

    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromOtherGroups)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_AppxWinmdFilesToHarvest" />
    </RemovePayloadDuplicates>

    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromSDKs)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_AppxSDKWinmdFilesForHarvest" />
    </RemovePayloadDuplicates>


    <ItemGroup>
      <_GenerateCurrentProjectAppxManifestInput Include="@(AppxManifest)" />
      <_GenerateCurrentProjectAppxManifestInput Include="@(AppxManifestSchema)" />
      <_GenerateCurrentProjectAppxManifestInput Include="$(PackageCertificateKeyFile)" />
      <_GenerateCurrentProjectAppxManifestInput Include="@(_AppxWinmdFilesToHarvest)" />
      <_GenerateCurrentProjectAppxManifestInput Include="@(_AppxSDKWinmdFilesForHarvest)" />
      <_GenerateCurrentProjectAppxManifestInput Include="$(_QualifiersPath)" />
    </ItemGroup>

  </Target>

  <!-- Generates a final AppxManifest.xml that will be included in the appx package. -->
  <!-- The generation includes pre-processing of any tokens in the input manifest file to produce a valid appx manifest file. -->
  <!-- Input: [AppxManifest] Name of the manifest file template. -->
  <!-- Output: [FinalAppxManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_GenerateCurrentProjectAppxManifest"
          Condition="Exists(@(AppxManifest))"
          Inputs="$(MSBuildAllProjects);@(_GenerateCurrentProjectAppxManifestInput)"
          Outputs="$(FinalAppxManifestName)">

    <ItemGroup>
      <AppxManifestMetadata Include="$(MakePriExeFullPath)" />
    </ItemGroup>

    <GenerateAppxManifest AppxManifestInput="@(AppxManifest)"
                          AppxManifestOutput="$(FinalAppxManifestName)"
                          ApplicationExecutableName="$(TargetName)"
                          FrameworkSdkReferences="@(FrameworkSdkReference)"
                          NonFrameworkSdkReferences="@(NonFrameworkSdkReference)"
                          CertificateThumbprint="$(PackageCertificateThumbprint)"
                          CertificateFile="$(PackageCertificateKeyFile)"
                          CertificatePassword="$(PackageCertificatePassword)"
                          DefaultResourceLanguage="$(DefaultResourceLanguage)"
                          QualifiersPath="$(_QualifiersPath)"
                          PackageArchitecture="$(PackageArchitecture)"
                          SDKWinmdFiles="@(_AppxSDKWinmdFilesForHarvest)"
                          WinmdFiles="@(_AppxWinmdFilesToHarvest)"
                          ManagedWinmdInprocImplementation="$(ManagedWinmdInprocImplementation)"
                          OSMinVersion="$(AppxOSMinVersion)"
                          OSMaxVersionTested="$(AppxOSMaxVersionTested)"
                          OSMinVersionReplaceManifestVersion="$(AppxOSMinVersionReplaceManifestVersion)"
                          OSMaxVersionTestedReplaceManifestVersion="$(AppxOSMaxVersionTestedReplaceManifestVersion)"
                          PackageSigningEnabled="$(AppxPackageSigningEnabled)"
                          EnableSigningChecks="$(EnableSigningChecks)"
                          ManifestMetadata="@(AppxManifestMetadata)"
                          MetadataNamespaceUri="$(MetadataNamespaceUri)"
                          TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                          TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                          TargetPlatformVersion="$(TargetPlatformVersion)"
                          VsTelemetrySession="$(VsTelemetrySession)"
                          WinmdCacheEnabled="$(AppxWinMdCacheEnabled)"
                          WinmdCacheDir="$(AppxWinMdCacheDir)"
                              />

    <ItemGroup>
      <AllGeneratedManifests Include="$(FinalAppxManifestName)" />
      <FileWrites Conditon="'$(AppxWinMdCacheEnabled)' == 'true'" Include="$(AppxWinMdCacheDir)\**\*"></FileWrites>
    </ItemGroup>

    <Message Text="$(MSBuildProjectName) -> $(FinalAppxManifestName)" />

  </Target>

  <!-- In order for incremental build and clean to work correctly,       -->
  <!-- we are creating build item @(FinalAppxManifest) and @(FileWrites) -->
  <!-- in the target which always executes.                              -->
  <Target Name="_CreateFinalAppxManifestItem">

    <ItemGroup>
      <FinalAppxManifest Include="$(FinalAppxManifestName)" />
    </ItemGroup>

    <ItemGroup>
      <FileReads Include="@(CustomAppxManifest)"/>
      <FileReads Include="@(_GenerateCurrentProjectAppxManifestInput)"/>
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="@(FinalAppxManifest)"/>
    </ItemGroup>

  </Target>

  <!-- Copy overriden upload AppxManifest.xml to final location. -->
  <!-- Inputs: [CustomAppxManifest] Name of the manifest file override. -->
  <!-- Outputs: [FinalAppxUploadManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_CopyProjectAppxManifestToAppxUpload"
          Condition="('$(UseDotNetNativeToolchain)' != 'true' OR $([System.String]::Concat(',', $(AllowedPlatformsForProjectN.ToUpper()), ',').Contains(',$(PlatformTarget.ToUpper()),')) != 'true')
                     AND '$(BuildAppxUploadPackageForUap)' == 'true'"
          Inputs="$(MSBuildAllProjects);"
          Outputs="$(FinalAppxUploadManifestName)">

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SourceFiles="@(FinalAppxManifest)"
          DestinationFiles="$(FinalAppxUploadManifestName)"/>

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SourceFiles="@(ProjectPriFile)"
          DestinationFiles="$(ProjectPriUploadFullPath)"/>

    <ItemGroup>
      <FinalAppxUploadManifest Include="$(FinalAppxUploadManifestName)" />
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="@(FinalAppxUploadManifest)"/>
    </ItemGroup>

  </Target>

  <!-- Finds store association file. -->
  <Target Name="_FindStoreAssociationFile">

    <ItemGroup Condition="'@(StoreAssociationFile)' == ''">
      <StoreAssociationFile Include="@(Content)" Condition="'%(Identity)' == 'Package.StoreAssociation.xml'" />
      <StoreAssociationFile Include="@(None)" Condition="'%(Identity)' == 'Package.StoreAssociation.xml' and '$(StoreAssociationFile)' == ''" />
      <None Remove="@(None)" Condition="'%(Identity)' == 'Package.StoreAssociation.xml'" />
    </ItemGroup>

  </Target>

  <!-- Finds and validates the bundle mapping file. -->
  <Target Name="_FindAndValidateBundleMappingFile">

    <ItemGroup Condition="'@(BundleMappingFile)' == ''">
      <BundleMappingFile Include="@(BundleMapping)" Condition="'%(Identity)' == 'Bundle.Mapping.txt'" />
      <BundleMappingFile Include="@(Content)" Condition="'%(Identity)' == 'Bundle.Mapping.txt' and '$(BundleMappingFile)' == ''" />
      <BundleMappingFile Include="@(Text)" Condition="'%(Identity)' == 'Bundle.Mapping.txt' and '$(BundleMappingFile)' == ''" />
      <None Remove="@(BundleMapping)" Condition="'%(Identity)' == 'Bundle.Mapping.txt'" />
    </ItemGroup>

    <ValidateBundleMapping Condition="'@(BundleMappingFile)' != ''"
                           Input="@(BundleMappingFile)"
                           VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ExternalPackages" ItemName="_BundleMappingExternalPackages"/>
      <Output TaskParameter="OptionalProjects" ItemName="_BundleMappingOptionalProjects"/>
    </ValidateBundleMapping>

  </Target>

  <!-- Validates final Appx manifest. -->
  <Target Name="_ValidateAppxManifest"
          Condition="'$(SkipAppxManifestValidation)' != 'true'">

    <ValidateAppxManifest Input="@(FinalAppxManifest)"
                      SourceAppxManifest="@(SourceAppxManifest)"
                      AppxManifestSchema="@(AppxManifestSchema)"
                      StoreAssociationFile="@(StoreAssociationFile)"
                      TargetPlatformVersion="$(TargetPlatformVersion)"
                      TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                      OSMinVersion="$(AppxOSMinVersion)"
                      OSMaxVersionTested="$(AppxOSMaxVersionTested)"
                      PlatformVersionDescriptions="@(PlatformVersionDescription)"
                      ResolvedSDKReferences="@(RecursiveResolvedSDKReference)"
                      ValidateWinmds="$(_CustomAppxManifestUsed)"
                      StrictManifestValidationEnabled="$(AppxStrictManifestValidationEnabled)"
                      WinmdFiles="@(_AppxWinmdFilesToHarvest)"
                      SDKWinmdFiles="@(_AppxSDKWinmdFilesForHarvest)"
                      NonFrameworkSdkReferences="@(NonFrameworkSdkReference)"
                      ManagedWinmdInprocImplementation="$(ManagedWinmdInprocImplementation)"
                      ValidateManifest="$(AppxValidateAppxManifest)"
                      AppxPackagingComponentManifestPath="$(AppxPackagingComponentManifestPath)"
                      FrameworkSdkPackages="@(FrameworkSdkPackage)"
                      VsTelemetrySession="$(VsTelemetrySession)"
                      ProjectCapabilities="@(ProjectCapability)"
                      WinmdCacheEnabled="$(AppxWinMdCacheEnabled)"
                      WinMdCacheDir="$(AppxWinMdCacheDir)">
      <Output TaskParameter="Resources" ItemName="_ManifestResources" />
    </ValidateAppxManifest>

  </Target>

  <!-- Override to specify actions to happen after generating Appx manifest. -->
  <Target Name="AfterGenerateAppxManifest" />

  <!-- Validates Store manifest if it exists. -->
  <Target Name="_ValidateStoreManifest"
          Condition="'$(AppxValidateStoreManifest)' == 'true' and Exists($(StoreManifestName))">

    <ValidateStoreManifest Input="$(StoreManifestName)"
                           StoreManifestSchema="@(StoreManifestSchema)"
                           VsTelemetrySession="$(VsTelemetrySession)"/>

  </Target>

  <!-- ========================================================================================= -->
  <!-- Generating Appx package recipe.                                                           -->
  <!-- Happens after generating Appx manifest, for every project which can be packaged/deployed. -->
  <!-- ========================================================================================= -->

  <!-- Ensure Fast UpToDate check also consider the .appxrecipe file as an output -->
  <ItemGroup Condition="'$(AppxPackage)' == 'true'">
    <UpToDateCheckOutput Include="$(AppxPackageRecipe)" />
  </ItemGroup>

  <ItemGroup Condition="'$(AppxPackage)' == 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'">
    <UpToDateCheckOutput Include="$(AppxUploadPackageRecipe)" />
  </ItemGroup>

  <PropertyGroup>
    <_GenerateAppxPackageRecipeDependsOn>
      BeforeGenerateAppxPackageRecipe;
      $(_GenerateAppxPackageRecipeDependsOn);
      _CalculateInputsForGenerateAppxPackageRecipe;
      _GenerateAppxPackageRecipeFile;
      _FileReadsAndWritesForGenerateAppxPackageRecipe
    </_GenerateAppxPackageRecipeDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <_GenerateAppxUploadPackageRecipeDependsOn>
      BeforeGenerateAppxPackageRecipe;
      $(_GenerateAppxUploadPackageRecipeDependsOn);
      _CalculateInputsForGenerateAppxUploadPackageRecipe;
      _GenerateAppxUploadPackageRecipeFile;
      _FileReadsAndWritesForGenerateAppxUploadPackageRecipe
    </_GenerateAppxUploadPackageRecipeDependsOn>
  </PropertyGroup>

  <!-- Override to specify actions to happen before generating Appx manifest. -->
  <Target Name="BeforeGenerateAppxPackageRecipe"/>

  <Target Name="_GenerateAppxPackageRecipe"
          Condition="'$(AppxPackage)' == 'true' and
                     '$(AppxGeneratePackageRecipeEnabled)' == 'true'"
          DependsOnTargets="$(_GenerateAppxPackageRecipeDependsOn)"
          />

  <Target Name="_GenerateAppxUploadPackageRecipe"
          Condition="'$(AppxPackage)' == 'true' and
                     '$(AppxGeneratePackageRecipeEnabled)' == 'true' and
                     '$(BuildAppxUploadPackageForUap)' == 'true'"
          DependsOnTargets="$(_GenerateAppxUploadPackageRecipeDependsOn)"
          />

  <!-- Creates the recipe file for the the appx package -->
  <Target Name="_CalculateInputsForGenerateAppxPackageRecipe">

    <ItemGroup>
      <_GenerateAppxPackageRecipeInput Include="@(FinalAppxManifest)" />
      <_GenerateAppxPackageRecipeInput Include="@(AppxPackagePayload)" />
      <_GenerateAppxPackageRecipeInput Include="$(_ProjectArchitecturesFilePath)" />
      <_GenerateAppxPackageRecipeInput Include="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')" />
    </ItemGroup>

    <ItemGroup>
      <PDBPayload Include="@(AppxPackagePayload)" Condition="'%(Extension)'=='.pdb'" />
    </ItemGroup>

    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>

  </Target>

  <!-- Creates the recipe file for the the appx upload package -->
  <Target Name="_CalculateInputsForGenerateAppxUploadPackageRecipe">

    <ItemGroup>
      <_GenerateAppxUploadPackageRecipeInput Include="@(FinalAppxUploadManifest)" />
      <_GenerateAppxUploadPackageRecipeInput Include="@(AppxUploadPackagePayload)" />
      <_GenerateAppxUploadPackageRecipeInput Include="$(_ProjectArchitecturesFilePath)" />
    </ItemGroup>

    <ItemGroup>
      <PDBUploadPayload Include="@(AppxUploadPackagePayload)" Condition="'%(Extension)'=='.pdb'" />
    </ItemGroup>

    <!-- The uploaded .appx package should never include pdb's -->
    <ItemGroup>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>

  </Target>

  <!-- Creates the recipe file for the the appx package -->
  <Target Name="_GenerateAppxPackageRecipeFile"
          Inputs="$(MSBuildAllProjects);@(_GenerateAppxPackageRecipeInput)"
          Outputs="$(AppxPackageRecipe)"
          DependsOnTargets="_FindAppxContentGroupMap">

    <RemovePayloadDuplicates Inputs="@(AppxPackagePayload)"
                             HasSharedItems="$(HasSharedItems)"
                             MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxPackagePayloadForRecipeFile" />
    </RemovePayloadDuplicates>
    
    <!-- Set the RecipeContentGroupMap if the AppxContentGroupMap file is not already included in the payload. This happens when ProduceAppxBundle is not true. -->
    <PropertyGroup>
      <RecipeContentGroupMap Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxContentGroupMapFullPath)</RecipeContentGroupMap>
    </PropertyGroup>

    <GenerateAppxPackageRecipe
        AppxContentGroupMap="$(RecipeContentGroupMap)"
        AppxManifestXml="%(FinalAppxManifest.FullPath)"
        AppxBundleManifestXml="$(FinalAppxBundleManifestName)"
        SourceAppxManifest="@(SourceAppxManifest)"
        SolutionConfiguration="$(Configuration)|$(Platform)"
        PayloadFiles="@(_DeduplicatedAppxPackagePayloadForRecipeFile)"
        FrameworkSdkPackages="@(FrameworkSdkPackage)"
        RecipeFile="$(AppxPackageRecipe)"
        SystemBinaries="@(AppxSystemBinary)"
        ReservedFileNames="@(AppxReservedFileName)"
        AppxManifestSchemas="@(AppxManifestSchema)"
        ManifestFileNameQueries="@(AppxManifestFileNameQuery)"
        ManifestImageFileNameQueries="@(AppxManifestImageFileNameQuery)"
        AdditionalReRegisterAppIfChangedTargetPaths="@(AdditionalReRegisterAppIfChangedTargetPaths)"
        PackageArchitecture="$(PackageArchitecture)"
        ProjectDir="$(ProjectDir)"
        IntermediateOutputPath="$(IntermediateOutputPath)"
        MakePriExtensionPath="$(InProcessMakePriExtensionPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformVersion)"
        PlatformVersionDescriptions="@(PlatformVersionDescription)"
        IndexedPayloadFiles="@(IndexedPayloadFiles)"
        MrmSupportLibraryPath="$(MrmSupportLibraryPath)"
        UseResourceIndexerApi="$(AppxUseResourceIndexerApi)"
        DisableAppxManifestItemPackageContentValidation="$(DisableAppxManifestItemPackageContentValidation)"
        RemoteDeploymentType="$(RemoteDeploymentType)"
        PackageRegistrationPath="$(PackageRegistrationPath)"
        RemoveNonLayoutFiles="$(RemoveNonLayoutFiles)"
        WindowsSdkPath="$(WindowsSdkPath)"
        LayoutDir="$(LayoutDir)"
        OptionalProjectRecipeFiles="@(BundleMappingRecipes)"
        DeployOptionalPackages="$(DeployOptionalPackages)"
        VsTelemetrySession="$(VsTelemetrySession)"
        />

    <ItemGroup>
      <AllGeneratedRecipes Include="$(AppxPackageRecipe)" />
    </ItemGroup>

    <Message Text="$(MSBuildProjectName) -> $(AppxPackageRecipe)" />

  </Target>

  <!-- Creates the recipe file for the the appx upload package -->
  <Target Name="_GenerateAppxUploadPackageRecipeFile"
          Inputs="$(MSBuildAllProjects);@(_GenerateAppxUploadPackageRecipeInput)"
          Outputs="$(AppxUploadPackageRecipe)">

    <RemovePayloadDuplicates Inputs="@(AppxUploadPackagePayload)"
                             HasSharedItems="$(HasSharedItems)"
                             MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxUploadPackagePayloadForRecipeFile" />
    </RemovePayloadDuplicates>
    
    <!-- Make sure the target directory exists as GenerateAppxPackageRecipe won't create it -->
    <MakeDir Directories="$(TargetDir)$(AppxUploadPackageArtifactsDir)" />

    <GenerateAppxPackageRecipe
        AppxManifestXml="%(FinalAppxUploadManifest.FullPath)"
        AppxBundleManifestXml="$(FinalAppxBundleManifestName)"
        SourceAppxManifest="@(SourceAppxManifest)"
        SolutionConfiguration="$(Configuration)|$(Platform)"
        PayloadFiles="@(_DeduplicatedAppxUploadPackagePayloadForRecipeFile)"
        FrameworkSdkPackages="@(FrameworkSdkPackage)"
        RecipeFile="$(AppxUploadPackageRecipe)"
        SystemBinaries="@(AppxSystemBinary)"
        ReservedFileNames="@(AppxReservedFileName)"
        AppxManifestSchemas="@(AppxManifestSchema)"
        ManifestFileNameQueries=""
        ManifestImageFileNameQueries="@(AppxManifestImageFileNameQuery)"
        PackageArchitecture="$(PackageArchitecture)"
        ProjectDir="$(ProjectDir)"
        IntermediateOutputPath="$(IntermediateOutputPath)"
        MakePriExtensionPath="$(InProcessMakePriExtensionPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformVersion)"
        PlatformVersionDescriptions="@(PlatformVersionDescription)"
        IndexedPayloadFiles="@(IndexedPayloadFiles)"
        MrmSupportLibraryPath="$(MrmSupportLibraryPath)"
        UseResourceIndexerApi="$(AppxUseResourceIndexerApi)"
        DisableAppxManifestItemPackageContentValidation="$(DisableAppxManifestItemPackageContentValidation)"
        RemoteDeploymentType="$(RemoteDeploymentType)"
        PackageRegistrationPath="$(PackageRegistrationPath)"
        RemoveNonLayoutFiles="$(RemoveNonLayoutFiles)"
        WindowsSdkPath="$(WindowsSdkPath)"
        LayoutDir="$(LayoutDir)"
        DeployOptionalPackages="$(DeployOptionalPackages)"
        VsTelemetrySession="$(VsTelemetrySession)"
        />

    <Message Text="$(MSBuildProjectName) -> $(AppxUploadPackageRecipe)" />

  </Target>

  <!-- Add FileReads and FileWrites done during generation of package recipe file. -->
  <Target Name="_FileReadsAndWritesForGenerateAppxPackageRecipe">

    <ItemGroup>
      <FileReads Include="@(_GenerateAppxPackageRecipeInput)" />
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="$(AppxPackageRecipe)"/>
    </ItemGroup>

  </Target>

  <!-- Add FileReads and FileWrites done during generation of upload package recipe file. -->
  <Target Name="_FileReadsAndWritesForGenerateAppxUploadPackageRecipe">

    <ItemGroup>
      <FileReads Include="@(_GenerateAppxUploadPackageRecipeInput)" />
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackageRecipe)"/>
    </ItemGroup>

  </Target>

  <!-- ==================================================================================== -->
  <!-- Creates a .tlog file from the FileReads items so that up-to-date check works in C++. -->
  <!-- ==================================================================================== -->
  <Target Name="_AppendToReadTlogFile"
          Condition="'$(Language)' == 'C++' and '@(FileReads)' != ''">

    <ItemGroup>
      <_FileReadsWithoutPDBs Include="@(FileReads)" Condition="%(Extension) != '.pdb'" />
    </ItemGroup>

    <WriteLinesToFile
        File="$(TLogLocation)$(ProjectName).read.1u.tlog"
        Lines="^$(ProjectPath);@(_FileReadsWithoutPDBs-&gt;'%(Fullpath)')"
        Encoding="Unicode" />
  </Target>

  <!-- ============================================================================ -->
  <!-- Creates a .tlog file from the FileWrites items so Clean target works in C++. -->
  <!-- ============================================================================ -->
  <Target Name="_AppendToWriteTlogFile"
          Condition="'$(Language)' == 'C++' and '@(FileWrites)' != ''">
    <WriteLinesToFile
        File="$(TLogLocation)$(ProjectName).write.1u.tlog"
        Lines="^$(ProjectPath);@(FileWrites-&gt;'%(Fullpath)')"
        Encoding="Unicode" />
  </Target>

  <!-- Remember packaging files and directories to clean later.   -->
  <!-- We have to roll our own because targets which handle       -->
  <!-- regular FileWrites items are not considering those outside -->
  <!-- output or intermediate directory.                          -->

  <Target Name="_AppendToPackagingWriteLogs">

    <WriteLinesToFile Condition="'@(PackagingFileWrites)' != ''"
                      File="$(PackagingFileWritesLogPath)"
                      Lines="@(PackagingFileWrites->'%(Fullpath)')"
                      Encoding="Unicode"
                          />

    <WriteLinesToFile Condition="'@(PackagingDirectoryWrites)' != ''"
                      File="$(PackagingDirectoryWritesLogPath)"
                      Lines="@(PackagingDirectoryWrites->'%(Fullpath)')"
                      Encoding="Unicode"
                          />
  </Target>

  <!-- =============================== -->
  <!-- Generating Appx package.        -->
  <!-- Happens when invoked explictly. -->
  <!-- =============================== -->

  <Target Name="_CalculateXbfSupport">
    <PropertyGroup>
      <_SupportXbfAsEmbedFileResources Condition="'$(_SupportEmbedFileResources)' == 'true' and '$(DisableEmbeddedXbf)' == 'false'">true</_SupportXbfAsEmbedFileResources>
      <_SupportXbfAsEmbedFileResources Condition="'$(DisableEmbeddedXbf)' == 'true'">false</_SupportXbfAsEmbedFileResources>
      <_SupportXbfAsEmbedFileResources Condition="'$(_SupportXbfAsEmbedFileResources)' == '' AND '$(_SupportEmbedFileResources)' == 'true'">true</_SupportXbfAsEmbedFileResources>
    </PropertyGroup>
  </Target>

  <PropertyGroup>
    <_CleanArtifacts>
      _RemoveDisposableSigningCertificate;
    </_CleanArtifacts>

    <_GenerateAppxPackageBaseDependsOn>
      _ComputeAppxPackageOutput;
      _CreateAppxPackage;
      _CreateAppxBundlePlatformSpecificArtifacts;
      $(_CleanArtifacts);
    </_GenerateAppxPackageBaseDependsOn>

    <_GenerateAppxPackageDependsOn Condition="'$(GenerateAppxPackageOnBuild)' == 'true'">
      $(_GenerateAppxPackageDependsOn);
      $(_GenerateAppxPackageBaseDependsOn);
      _ContinuousStoreSubmission;
    </_GenerateAppxPackageDependsOn>

    <_GenerateAppxPackageDependsOn Condition="'$(GenerateAppxPackageOnBuild)' != 'true'">
      $(_GenerateAppxPackageDependsOn);
      _SuppressDeploymentOnlyFeatures;
      Build;
      $(_GenerateAppxPackageBaseDependsOn);
    </_GenerateAppxPackageDependsOn>
  </PropertyGroup>

  <Target Name="_GenerateAppxPackage"
          Condition="'$(AppxPackage)' == 'true'"
          DependsOnTargets="$(_GenerateAppxPackageDependsOn)"
            >

    <Delete Files="$(InstallerFileWritesLogPath)" ContinueOnError="true" TreatErrorsAsWarnings="true" />

    <WriteLinesToFile Condition="'@(InstallerFileWrites)' != ''"
                  File="$(InstallerFileWritesLogPath)"
                  Lines="@(InstallerFileWrites->'%(Fullpath)')"
                  Encoding="Unicode"
                          />
    <ItemGroup>
      <FileWrites Include="$(InstallerFileWritesLogPath)" />
    </ItemGroup>

  </Target>

  <PropertyGroup>
    <_CreateAppxPackageDependsOn>
      _ValidateAppxPackage;
      _GenerateAppxPackageFile;
      _GenerateAppxUploadPackageFile;
      _GenerateAppxSymbolPackage;
      _GenerateAppxUploadSymbolPackage;
      _CreateAppStoreContainerForUAP;
      _CreateTestLayout;

      <!-- App Installer -->
      GenerateAppInstallerForPackage;

      _AddWindowsInstallScriptToTestLayout;
    </_CreateAppxPackageDependsOn>
  </PropertyGroup>

  <!-- Computes Appx package output (file name and directory). -->
  <Target Name="_ComputeAppxPackageOutput"
          DependsOnTargets="_GetPackageFileExtensions">

    <ReadLinesFromFile File="$(_MultipleQualifiersPerDimensionFoundPath)"
                       Condition="'$(AppxBundle)' == 'Auto' and Exists($(_MultipleQualifiersPerDimensionFoundPath))"
                           >
      <Output TaskParameter="Lines" PropertyName="_MultipleQualifiersPerDimensionFound" />
    </ReadLinesFromFile>

    <PropertyGroup Condition="'$(AppxBundle)' == 'Auto'">
      <_MultipleQualifiersPerDimensionFound Condition="'$(_MultipleQualifiersPerDimensionFound)' != 'true'">false</_MultipleQualifiersPerDimensionFound>
    </PropertyGroup>

    <PropertyGroup Condition="'$(TargetPlatformVersion)' == '8.0'">
      <ProduceAppxBundle>false</ProduceAppxBundle>
    </PropertyGroup>

    <PropertyGroup Condition="'$(TargetPlatformVersion)' != '8.0'">
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Auto'">$(_MultipleQualifiersPerDimensionFound)</ProduceAppxBundle>
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Never'">false</ProduceAppxBundle>
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Always'">true</ProduceAppxBundle>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxPackageName)' != ''">
      <AppxPackageNameNeutral>$(AppxPackageName)</AppxPackageNameNeutral>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxPackageName)' == ''">
      <AppxPackageNameNeutral>$(ProjectName)_$(AppxManifestIdentityVersion)</AppxPackageNameNeutral>
      <_AppxPackageConfiguration Condition="'$(Configuration)' != 'Release'">_$(Configuration)</_AppxPackageConfiguration>
      <AppxPackageName>$(AppxPackageNameNeutral)_$(Platform)$(_AppxPackageConfiguration)</AppxPackageName>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxStoreContainer)' == '' and '$(ProduceAppxBundle)' == 'false'">
      <AppxStoreContainer>$(AppxPackageDir)$(AppxPackageName)$(AppxStoreContainerExtension)</AppxStoreContainer>
    </PropertyGroup>

    <!-- compute paths for appx -->

    <PropertyGroup Condition="'$(AppxPackageTestDir)' == ''">
      <AppxPackageTestDir Condition="'$(ProduceAppxBundle)' == 'false'">$(AppxPackageDir)$(AppxPackageName)_Test\</AppxPackageTestDir>
      <AppxPackageTestDir Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxPackageDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)_Test\</AppxPackageTestDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxPackageTestExternalPackagesDir)' == ''">
      <AppxPackageTestExternalPackagesDir Condition="'$(ProduceAppxBundle)' == 'false'">$(AppxPackageDir)$(AppxPackageName)_Test\$(ExternalPackagesDir)</AppxPackageTestExternalPackagesDir>
      <AppxPackageTestExternalPackagesDir Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxPackageDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)_Test\$(ExternalPackagesDir)</AppxPackageTestExternalPackagesDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxPackageOutput)' == ''">
      <AppxPackageOutput Condition="'$(AppxPackageEncryptionEnabled)' != 'true'">$(AppxPackageTestDir)$(AppxPackageName)$(AppxPackageExtension)</AppxPackageOutput>
      <AppxPackageOutput Condition="'$(AppxPackageEncryptionEnabled)' == 'true'">$(AppxPackageTestDir)$(AppxPackageName)$(AppxPackageEncryptedExtension)</AppxPackageOutput>
    </PropertyGroup>

    <!-- compute paths for Upload appx & symbols -->

    <PropertyGroup Condition="'$(AppxUploadPackageDir)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
      <AppxUploadPackageDir Condition="'$(ProduceAppxBundle)' == 'false'">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxPackageName)\</AppxUploadPackageDir>
      <AppxUploadPackageDir Condition="'$(ProduceAppxBundle)' == 'true'">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)\</AppxUploadPackageDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUploadPackageExternalpackagesDir)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
      <AppxUploadPackageExternalpackagesDir Condition="'$(ProduceAppxBundle)' == 'false'">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxPackageName)\$(ExternalPackagesDir)</AppxUploadPackageExternalpackagesDir>
      <AppxUploadPackageExternalpackagesDir Condition="'$(ProduceAppxBundle)' == 'true'">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)\$(ExternalPackagesDir)</AppxUploadPackageExternalpackagesDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUploadPackageOutput)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
      <AppxUploadPackageOutput>$(AppxUploadPackageDir)$(AppxPackageName)$(AppxPackageExtension)</AppxUploadPackageOutput>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxSymbolPackageIntermediate)' == ''">
      <AppxSymbolPackageIntermediate>$(AppxSymbolIntermediateDir)\$(AppxPackageName)$(AppxSymbolPackageExtension)</AppxSymbolPackageIntermediate>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxSymbolPackageOutput)' == ''">
      <AppxSymbolPackageOutput>$(AppxPackageTestDir)$(AppxPackageName)$(AppxSymbolPackageExtension)</AppxSymbolPackageOutput>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUploadSymbolPackageOutput)' == ''">
      <AppxUploadSymbolPackageOutput>$(AppxUploadPackageDir)$(AppxPackageName)$(AppxSymbolPackageExtension)</AppxUploadSymbolPackageOutput>
    </PropertyGroup>

    <PropertyGroup>
      <AppxBundleDir Condition="'$(AppxBundleDir)' == ''">$(IntermediateOutputPath)$(AppxPackageNameNeutral)$(AppxBundleFolderSuffix)\</AppxBundleDir>
      <AppxBundleDir Condition="!HasTrailingSlash('$(AppxBundleDir)')">$(AppxBundleDir)\</AppxBundleDir>
    </PropertyGroup>

    <PropertyGroup>
      <AppxUploadBundleDir Condition="'$(AppxUploadBundleDir)' == ''">$(IntermediateUploadOutputPath)$(AppxPackageNameNeutral)$(AppxBundleFolderSuffix)\</AppxUploadBundleDir>
      <AppxUploadBundleDir Condition="!HasTrailingSlash('$(AppxUploadBundleDir)')">$(AppxUploadBundleDir)\</AppxUploadBundleDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxMainPackageOutput)' == ''">
      <AppxMainPackageOutput>$(TargetDir)$(AppxPackageName)$(AppxPackageExtension)</AppxMainPackageOutput>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUploadMainPackageOutput)' == ''">
      <AppxUploadMainPackageOutput>$(TargetDir)Upload\$(AppxPackageName)$(AppxPackageExtension)</AppxUploadMainPackageOutput>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxResourcePackOutputBase)' == ''">
      <AppxResourcePackOutputBase>$(TargetDir)$(AppxPackageNameNeutral)</AppxResourcePackOutputBase>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUploadResourcePackOutputBase)' == ''">
      <AppxUploadResourcePackOutputBase>$(TargetDir)Upload\$(AppxPackageNameNeutral)</AppxUploadResourcePackOutputBase>
    </PropertyGroup>

  </Target>

  <!-- Extracts hash URI from store association file or provide default. -->
  <!-- Extracts packaging platforms, too.                                -->
  <Target Name="_ExtractStoreAssociationInformation"
          DependsOnTargets="_FindStoreAssociationFile;_ComputeAppxPackageOutput"
          BeforeTargets="_CreateAppxPackage;_CreateMainPackage;_CreateResourcePackages;_CreateBundle;_CalculateAppxBundleProperties">

    <PropertyGroup>
      <_ExtractPlatforms Condition="'$(AppxBundlePlatforms)' == '' and '$(ProduceAppxBundle)' == 'true'">true</_ExtractPlatforms>
      <_ExtractPlatforms Condition="'$(_ExtractPlatforms)' == ''">false</_ExtractPlatforms>
    </PropertyGroup>

    <ExtractStoreAssociationInformation StoreAssociationFile="@(StoreAssociationFile)"
                                        HashUris="@(AppxHashUri)"
                                        ExtractPlatforms="$(_ExtractPlatforms)"
                                        VsTelemetrySession="$(VsTelemetrySession)"
                                        Condition="'@(StoreAssociationFile)' != ''">
      <Output TaskParameter="HashAlgorithmId" PropertyName="AppxHashAlgorithmId" />
      <Output TaskParameter="Platforms" PropertyName="_Platforms" />
    </ExtractStoreAssociationInformation>

    <Warning Condition="('$(_ExtractPlatforms)' == 'true' and '@(StoreAssociationFile)' == '' and '$(AppxBundlePlatforms)' == '')
                         or ('$(_ExtractPlatforms)' == 'true' and '@(StoreAssociationFile)' != '' and '$(_Platforms)' == '')"
             Text="APPX4001: Build property AppxBundlePlatforms is not explicitly set and is calculated based on currently building architecture. Use 'Create App Package' wizard or edit project file to set it." />

    <Warning Condition="'$(_ExtractPlatforms)' == 'true' and '@(StoreAssociationFile)' != '' and '$(AppxBundlePlatforms)' == '' and '$(_Platforms)' != ''"
             Text="APPX4002: Build property AppxBundlePlatforms is not explicitly set and is calculated based on uploaded packages in the Store for currently building app. Use 'Create App Package' wizard or edit project file to set it." />

    <PropertyGroup Condition="'$(AppxHashAlgorithmId)' == ''">
      <AppxHashAlgorithmId>$(AppxDefaultHashAlgorithmId)</AppxHashAlgorithmId>
    </PropertyGroup>

    <PropertyGroup Condition="'$(_ExtractPlatforms)' == 'true'">
      <AppxBundlePlatforms>$(_Platforms.Replace(';', '|'))</AppxBundlePlatforms>
    </PropertyGroup>

  </Target>

  <!-- Executes pre-upload validation of the appx package. -->
  <Target Name="_ValidateAppxPackage"
          Condition="'$(AppxPackageValidationEnabled)' == 'true'">

    <RemovePayloadDuplicates Inputs="@(AppxPackagePayload)"
                             HasSharedItems="$(HasSharedItems)"
                             MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxPackagePayloadForValidation" />
    </RemovePayloadDuplicates>
    
    <ValidateAppxPackage
        SourceAppxManifest="@(SourceAppxManifest)"
        AppxManifest="@(FinalAppxManifest)"
        StoreAssociationFile="@(StoreAssociationFile)"
        PackageArchitecture="$(PackageArchitecture)"
        AppxPackagePayload="@(_DeduplicatedAppxPackagePayloadForValidation)"
        AppxManifestSchemas="@(AppxManifestSchema)"
        ManifestImageFileNameQueries="@(AppxManifestImageFileNameQuery)"
        ResolvedSDKReferences="@(RecursiveResolvedSDKReference)"
        AllowDebugFrameworkReferencesInManifest="$(AppxPackageAllowDebugFrameworkReferencesInManifest)"
        ProjectDir="$(ProjectDir)"
        MakePriExtensionPath="$(InProcessMakePriExtensionPath)"
        IndexedPayloadFiles="@(IndexedPayloadFiles)"
        OSMinVersion="$(AppxOSMinVersion)"
        ProduceAppxBundle="$(ProduceAppxBundle)"
        IndexedMainPayloadFiles="@(IndexedMainPayloadFiles)"
        MrmSupportLibraryPath="$(MrmSupportLibraryPath)"
        UseResourceIndexerApi="$(AppxUseResourceIndexerApi)"
        VsTelemetrySession="$(VsTelemetrySession)"
            />

  </Target>

  <Target Name="_CreateAppxPackage"
          Condition="'$(ProduceAppxBundle)' == 'false' and '$(UseAppxLayout)' != 'true'"
          DependsOnTargets="$(_CreateAppxPackageDependsOn)"
            />

  <!-- The following target generates the appx package. -->
  <Target Name="_GenerateAppxPackageFile"
          Inputs="$(MSBuildAllProjects);@(FinalAppxManifest);@(AppxPackagePayload);$(PackageCertificateKeyFile)"
          Outputs="$(AppxPackageOutput)"
          Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'"
          DependsOnTargets="_FindAppxContentGroupMap;_DeleteAppxOutputFolderIfNecessary">

    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>

    <RemovePayloadDuplicates Inputs="@(AppxPackagePayload)"
                             HasSharedItems="$(HasSharedItems)"
                             MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxPackagePayloadForPackaging" />
    </RemovePayloadDuplicates>
    
    <WriteLinesToFile File="$(AppxPackageFileMap)"
                      Lines="[Files];
                                 @(FinalAppxManifest->'%22%(Identity)%22 %22%(FileName)%(Extension)%22');
                                 @(_DeduplicatedAppxPackagePayloadForPackaging->'%22%(Identity)%22 %22%(TargetPath)%22')"
                      Overwrite="true"
                          />

    <ItemGroup>
      <FileWrites Include="$(AppxPackageFileMap)" />
    </ItemGroup>

    <!-- Package and sign the Test Appx -->

    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  AppxContentGroupMap="$(AppxContentGroupMapFullPath)"
                  AppxStreamableMainPackage="$(AppxStreamableMainPackage)"
                  AppxStreamableResourcePackages="$(AppxStreamableResourcePackages)"
                  ResourcePack="false"
                  Parameters="$(CreatePackageMakeAppxParameters)"
                  EncryptAppxPackage="$(AppxPackageEncryptionEnabled)"
                  HashAlgorithmId="$(AppxHashAlgorithmId)"
                  ValidateResourcesReferencedByManifest="false"
                  FileMap="$(AppxPackageFileMap)"
                  Output="$(AppxPackageOutput)"
                  VsTelemetrySession="$(VsTelemetrySession)"
                      />

    <ItemGroup>
      <FinalAppxPackageItem Include="$(AppxPackageOutput)" />
    </ItemGroup>

    <ItemGroup>
      <AllBuiltSideloadPackages Include="$(AppxPackageOutput)"/>
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="@(FinalAppxPackageItem)" />

      <InstallerFileWrites Include="@(FinalAppxPackageItem)" />
    </ItemGroup>

    <WriteLinesToFile File="$(AppxPackagingInfoFile)"
                      Overwrite="true"
                      Lines="%(FinalAppxPackageItem.FullPath)" />

    <ItemGroup>
      <FileWrites Include="$(AppxPackagingInfoFile)" />
    </ItemGroup>

    <Message Importance="high" Text="$(MSBuildProjectName) -> %(FinalAppxPackageItem.FullPath)" />

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="@(FinalAppxPackageItem)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     CertificatePassword="$(PackageCertificatePassword)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                     TempCertificateFilePath="$(TempCertificateFilePath)"
                     ExportCertificate="true"
                     VsTelemetrySession="$(VsTelemetrySession)"
                     SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)"
                     SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)"
                     AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)"
                     AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)"
                     AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)"
                     AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)"
                     AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)"
                     AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)"
                     AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)"
                     AzureKeyVaultUrl="$(AzureKeyVaultUrl)"
                     AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint"/>
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>

    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> $(AppxPackagePublicKeyFile)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> $(ResolvedThumbprint)" />

    <ItemGroup>
      <InstallerFileWrites Include="$(AppxPackagePublicKeyFile)" />
    </ItemGroup>
  </Target>

  <!-- The following target generates the appx Upload package. -->
  <Target Name="_GenerateAppxUploadPackageFile"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
          Inputs="$(MSBuildAllProjects);@(FinalAppxUploadManifest);@(AppxUploadPackagePayload);$(PackageCertificateKeyFile)"
          Outputs="$(AppxUploadPackageOutput)"
          DependsOnTargets="_FindAppxContentGroupMap">

    <ItemGroup>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>

    <RemovePayloadDuplicates Inputs="@(AppxUploadPackagePayload)"
                             HasSharedItems="$(HasSharedItems)"
                             MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxUploadPackagePayloadForPackaging" />
    </RemovePayloadDuplicates>
    
    <WriteLinesToFile File="$(AppxUploadPackageFileMap)"
                      Lines="[Files];
                                 @(FinalAppxUploadManifest->'%22%(Identity)%22 %22%(FileName)%(Extension)%22');
                                 @(_DeduplicatedAppxUploadPackagePayloadForPackaging->'%22%(Identity)%22 %22%(TargetPath)%22')"
                      Overwrite="true"
                          />

    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackageFileMap)" />
    </ItemGroup>

    <!-- Package and sign the Upload Appx -->

    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  AppxContentGroupMap="$(AppxContentGroupMapFullPath)"
                  AppxStreamableMainPackage="$(AppxStreamableMainPackage)"
                  AppxStreamableResourcePackages="$(AppxStreamableResourcePackages)"
                  ResourcePack="false"
                  Parameters="$(CreatePackageMakeAppxParameters)"
                  HashAlgorithmId="$(AppxHashAlgorithmId)"
                  ValidateResourcesReferencedByManifest="false"
                  FileMap="$(AppxUploadPackageFileMap)"
                  Output="$(AppxUploadPackageOutput)"
                  VsTelemetrySession="$(VsTelemetrySession)"
                  IsUploadPackageOrComponent="true"
                      />

    <ItemGroup>
      <FinalAppxUploadPackageItem Include="$(AppxUploadPackageOutput)" />
    </ItemGroup>

    <ItemGroup>
      <AllBuiltUploadPackages Include="$(AppxUploadPackageOutput)"/>
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="$(AppxPackagingInfoFile)" />
    </ItemGroup>

    <Message Importance="high" Text="$(MSBuildProjectName) -> %(FinalAppxUploadPackageItem.FullPath)" />

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="@(FinalAppxUploadPackageItem)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     CertificatePassword="$(PackageCertificatePassword)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                     TempCertificateFilePath="$(TempCertificateFilePath)"
                     ExportCertificate="true"
                     VsTelemetrySession="$(VsTelemetrySession)"
                     SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)"
                     SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)"
                     AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)"
                     AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)"
                     AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)"
                     AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)"
                     AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)"
                     AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)"
                     AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)"
                     AzureKeyVaultUrl="$(AzureKeyVaultUrl)"
                     AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint"/>
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>

    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> $(AppxPackagePublicKeyFile)" />
    <ItemGroup>
      <InstallerFileWrites Include="$(AppxPackagePublicKeyFile)" />
    </ItemGroup>
  </Target>

  <!-- The following target creates the appx symbol package. -->
  <Target Name="_GenerateAppxSymbolPackage"
          Condition="'$(AppxSymbolPackageEnabled)' == 'true' and 
                     '@(PDBPayload)' != '' and
                     '$(BuildAppxSideloadPackageForUap)' == 'true'"
          Inputs="$(MSBuildAllProjects);@(PDBPayload);@(FinalAppxManifest)"
          Outputs="$(AppxSymbolPackageIntermediate)">

    <PropertyGroup>
      <ReconstituteFastlinkPdbs Condition="'$(ReconstituteFastlinkPdbs)' == ''">true</ReconstituteFastlinkPdbs>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' != ''">$(PdbCmfx64ExeFullPath)</MsPdbCmfExeFullpath>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' == ''">$(PdbCmfx86ExeFullPath)</MsPdbCmfExeFullpath>
    </PropertyGroup>

    <GenerateAppxSymbolPackage MsPdbCmfExeFullpath="$(MsPdbCmfExeFullpath)"
                               InputPdbs="@(PDBPayload)"
                               ProjectName="$(MSBuildProjectName)"
                               StripPrivateSymbols="$(StripPrivateSymbols)"
                               IntermediateSymbolRoot="$(AppxSymbolIntermediateDir)"
                               ReconstituteFastlinkPdbs="$(ReconstituteFastlinkPdbs)"
                               AppxSymbolPackageOutput="$(AppxSymbolPackageIntermediate)"
                               VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="OutputPdbs" ItemName="OutputPdbFiles" />
    </GenerateAppxSymbolPackage>

    <ItemGroup>
      <FinalAppxSymbolPackageItem Include="$(AppxSymbolPackageIntermediate)" />
    </ItemGroup>

    <ItemGroup>
      <PackagingFileWrites Include="@(FinalAppxSymbolPackageItem)" />
      <FileWrites Include="@(OutputPdbFiles)" />
      <PackagingDirectoryWrites Include="$(AppxSymbolIntermediateDir)" />
    </ItemGroup>

  </Target>

  <!-- The following target creates the Upload appx symbol package. -->
  <Target Name="_GenerateAppxUploadSymbolPackage"
          Condition="'$(AppxSymbolPackageEnabled)' == 'true' and 
                     '@(PDBUploadPayload)' != '' and 
                     '$(BuildAppxUploadPackageForUap)' == 'true'"
          Inputs="$(MSBuildAllProjects);@(PDBUploadPayload);@(FinalAppxManifest)"
          Outputs="$(AppxUploadSymbolPackageOutput)">

    <PropertyGroup>
      <ReconstituteFastlinkPdbs Condition="'$(ReconstituteFastlinkPdbs)' == ''">true</ReconstituteFastlinkPdbs>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' != ''">$(PdbCmfx64ExeFullPath)</MsPdbCmfExeFullpath>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' == ''">$(PdbCmfx86ExeFullPath)</MsPdbCmfExeFullpath>
    </PropertyGroup>

    <GenerateAppxSymbolPackage MsPdbCmfExeFullpath="$(MsPdbCmfExeFullpath)"
                               InputPdbs="@(PDBUploadPayload)"
                               ProjectName="$(MSBuildProjectName)"
                               IntermediateSymbolRoot="$(AppxUploadSymbolIntermediateDir)"
                               StripPrivateSymbols="$(StripPrivateSymbols)"
                               ReconstituteFastlinkPdbs="$(ReconstituteFastlinkUploadPdbs)"
                               AppxSymbolPackageOutput="$(AppxUploadSymbolPackageOutput)"
                               VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="OutputPdbs" ItemName="OutputPdbUploadFiles" />
    </GenerateAppxSymbolPackage>

    <ItemGroup>
      <FinalAppxUploadSymbolPackageItem Include="$(AppxUploadSymbolPackageOutput)" />
    </ItemGroup>

    <ItemGroup>
      <PackagingFileWrites Include="@(FinalAppxUploadSymbolPackageItem)" />
      <FileWrites Include="@(OutputPdbUploadFiles)" />
      <PackagingDirectoryWrites Include="$(AppxUploadSymbolIntermediateDir)" />
    </ItemGroup>

    <Message Text="$(MSBuildProjectName) -> $(AppxUploadSymbolPackageOutput)" />

  </Target>

  <!-- Creates a test layout for testing of the appx package. -->
  <Target Name="_CreateTestLayout"
          Condition="'$(AppxTestLayoutEnabled)' == 'true' and
                     '$(BuildAppxSideloadPackageForUap)' == 'true'">

    <ItemGroup>
      <_TestLayoutSourceFiles Condition="'%(Architecture)' == 'neutral'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' == 'neutral'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(FileName)%(Extension)')" />
    </ItemGroup>

    <ItemGroup Condition="'$(AppxExcludeArmFrameworkSdkPackagesFromLayout)' != 'true'">
      <_TestLayoutSourceFiles Condition="'%(Architecture)' == 'arm'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' == 'arm'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(Architecture)\%(FileName)%(Extension)')" />
    </ItemGroup>

    <ItemGroup Condition="'$(AppxExcludeX86FrameworkSdkPackagesFromLayout)' != 'true'">
      <_TestLayoutSourceFiles Condition="'%(Architecture)' == 'x86'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' == 'x86'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(Architecture)\%(FileName)%(Extension)')" />
    </ItemGroup>

    <ItemGroup>
      <_TestLayoutSourceFiles Condition="'%(Architecture)' != 'neutral' and '%(Architecture)' != 'arm' and '%(Architecture)' != 'x86'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' != 'neutral' and '%(Architecture)' != 'arm' and '%(Architecture)' != 'x86'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(Architecture)\%(FileName)%(Extension)')" />
    </ItemGroup>

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
        SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
        SourceFiles="@(_TestLayoutSourceFiles)"
        DestinationFiles="@(_TestLayoutTargetFiles)" />

    <!-- Copy the .appxsym files to the output directory -->
    <Copy Condition="Exists('$(AppxSymbolPackageIntermediate)')"
       UseHardlinksIfPossible="false"
       SourceFiles="$(AppxSymbolPackageIntermediate)"
       DestinationFiles="$(AppxSymbolPackageOutput)" />

    <ItemGroup>
      <InstallerFileWrites Include="@(_TestLayoutTargetFiles)" />
      <PackagingFileWrites Include="@(_TestLayoutTargetFiles)"/>
      <PackagingDirectoryWrites Include="$(AppxPackageTestDir)" />
    </ItemGroup>

  </Target>

  <!-- Find the AppxContentGroupMap path. -->
  <Target Name="_FindAppxContentGroupMap">

    <ItemGroup Condition="'@(AppxContentGroupMap)' == ''">
      <AppxContentGroupMap Include="@(Content)" Condition="'%(Identity)' == 'AppxContentGroupMap.xml'" />
    </ItemGroup>

    <!-- Handle the case where the project is a VC Project -->
    <ItemGroup Condition="'@(AppxContentGroupMap)' == ''">
      <AppxContentGroupMap Include="@(Xml)" Condition="'%(Filename)%(Extension)' == 'AppxContentGroupMap.xml'" />
    </ItemGroup>

    <PropertyGroup>
      <AppxContentGroupMapFullPath>%(AppxContentGroupMap.FullPath)</AppxContentGroupMapFullPath>
    </PropertyGroup>

  </Target>

  <!-- Find the SourceAppxContentGroupMap path. -->
  <Target Name="_FindSourceAppxContentGroupMap">

    <ItemGroup Condition="'@(SourceAppxContentGroupMap)' == ''">
      <SourceAppxContentGroupMap Include="@(AppxSourceContentGroupMap)" Condition="'%(Identity)' == 'SourceAppxContentGroupMap.xml'" />
    </ItemGroup>

    <!-- Handle the case where the project is a JS project -->
    <ItemGroup Condition="'@(SourceAppxContentGroupMap)' == ''">
      <SourceAppxContentGroupMap Include="@(Content)" Condition="'%(Identity)' == 'SourceAppxContentGroupMap.xml'" />
    </ItemGroup>

    <!-- Handle the case where the project is a VC Project -->
    <ItemGroup Condition="'@(SourceAppxContentGroupMap)' == ''">
      <SourceAppxContentGroupMap Include="@(Xml)" Condition="'%(Identity)' == 'SourceAppxContentGroupMap.xml'" />
    </ItemGroup>
  </Target>

  <!-- Convert the SourceAppxContentGroupMap file into the target AppxContentGroupMap. -->
  <Target Name="_ConvertAppxContentGroupMap"
          Condition="'$(ConvertSourceAppxContentGroupMap)' == 'true'"
          DependsOnTargets="_FindAppxContentGroupMap;_FindSourceAppxContentGroupMap"
          Outputs="$(AppxMainPackageOutput)">

    <MakeAppxContentGroupMap
                  MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  Output="$(AppxContentGroupMapFullPath)"
                  SourceAppxContentGroupMap="@(SourceAppxContentGroupMap)"
                  LayoutResFile="$(_UnfilteredLayoutResfilesPath)"
                  ResourcePackFile="$(ProjectPriFullPath)"
                  VsTelemetrySession="$(VsTelemetrySession)"
                        />
  </Target>


  <!-- Add install script for Windows packages/bundles to the test layout. -->
  <Target Name="_AddWindowsInstallScriptToTestLayout"
          Condition="'$(AppxTestLayoutEnabled)' == 'true' and
                     '$(_TargetPlatformIsWindowsPhone)' != 'true' and
                     '$(BuildAppxSideloadPackageForUap)' == 'true'">

    <ItemGroup>
      <_PowerShellScriptsSource Include="$(AppxMSBuildToolsPath)Add-AppDevPackage.ps1" />
      <_PowerShellScriptsSource Include="$(AppxMSBuildToolsPath)**\Add-AppDevPackage.psd1" />
      <_PowerShellScriptsSource Include="$(AppxMSBuildToolsPath)Install.ps1" />
    </ItemGroup>

    <ItemGroup>
      <_PowerShellScriptsDestination Include="@(_PowerShellScriptsSource->'$(AppxPackageTestDir)%(RecursiveDir)%(FileName)%(Extension)')" />
    </ItemGroup>

    <!--Copy install scripts to app package location.-->
    <Copy
      UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
      SkipUnchangedFiles="true"
      SourceFiles="@(_PowerShellScriptsSource)"
      DestinationFiles="@(_PowerShellScriptsDestination)"
      ContinueOnError="$(ContinueOnError)" />

    <ItemGroup>
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)LogSideloadingTelemetry.ps1" />
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)Microsoft.Diagnostics.Tracing.EventSource.dll" />
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)Microsoft.VisualStudio.Telemetry.dll" />
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)Microsoft.VisualStudio.RemoteControl.dll" />
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)Microsoft.VisualStudio.Utilities.Internal.dll" />
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)Newtonsoft.Json.dll" />
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)System.Runtime.CompilerServices.Unsafe.dll" />
    </ItemGroup>

    <ItemGroup>
      <_PowerShellScriptTelemetryDependenciesDestination Include="@(_PowerShellScriptTelemetryDependenciesSource->'$(AppxPackageTestDir)TelemetryDependencies\%(FileName)%(Extension)')" />
    </ItemGroup>

    <!--Copy install script telemetry dependencies to app package location if necessary.-->
    <Copy
      Condition="'$(AppxLogTelemetryFromSideloadingScript)' == 'true'"
      UseHardlinksIfPossible="false"
      SkipUnchangedFiles="true"
      SourceFiles="@(_PowerShellScriptTelemetryDependenciesSource)"
      DestinationFiles="@(_PowerShellScriptTelemetryDependenciesDestination)"
      ContinueOnError="$(ContinueOnError)" />

    <ItemGroup>
      <PackagingFileWrites Include="@(_PowerShellScriptsDestination)" />
      <PackagingFileWrites Include="@(_PowerShellScriptTelemetryDependenciesDestination)" Condition="'$(AppxLogTelemetryFromSideloadingScript)' == 'true'" />
    </ItemGroup>

  </Target>

  <!-- Creates .appxupload/.msixupload file containing .appx/.msix and optional .appxsym/.msix, -->
  <!-- which is used for uploading to Windows App Store.                -->
  <!-- only gets built if the package is for the Universal App Store              -->
  <Target Name="_CreateAppStoreContainerForUAP"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
          Inputs="$(MSBuildAllProjects);@(FinalAppxUploadPackageItem);@(FinalAppxUploadSymbolPackageItem)"
          Outputs="$(AppxStoreContainer)">

    <ItemGroup>
      <!-- create temp item just to use .FullPath -->
      <_AppxStoreContainer Include="$(AppxStoreContainer)" />
    </ItemGroup>

    <MakeDir Directories="$(AppxPackageDir)" />

    <CreateAppStoreContainer
        Items="@(FinalAppxUploadPackageItem);@(FinalAppxUploadSymbolPackageItem)"
        ProjectName="$(MSBuildProjectName)"
        OutputPath="%(_AppxStoreContainer.FullPath)"
        VsTelemetrySession="$(VsTelemetrySession)"/>

    <ItemGroup>
      <PackagingFileWrites Include="$(AppxStoreContainer)"/>
    </ItemGroup>

    <WriteLinesToFile File="$(AppxUploadPackagingInfoFile)"
                      Overwrite="true"
                      Lines="$([System.IO.Path]::GetFullPath('$(AppxStoreContainer)'))" />

    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackagingInfoFile)" />
    </ItemGroup>

  </Target>

  <!-- ================================================== -->
  <!-- Create platform-specific artifacts for app bundle. -->
  <!-- ================================================== -->

  <PropertyGroup>
    <_CreateAppxBundlePlatformSpecificArtifactsDependsOn>
      $(Before_CreateAppxBundlePlatformSpecificArtifacts)

      _GetPackageProperties;

      _CreatePackageLayout_CalculateInputsAndOutputs;
      _CreatePackageLayout;
      _CreatePackageLayout_AddFileWrites;

      _CreateUploadPackageLayout_CalculateInputsAndOutputs;
      _CreateUploadPackageLayout;
      _CreateUploadPackageLayout_AddFileWrites;

      _GetDefaultResourceLanguage;

      _CreatePriConfigXmlForSplitting;
      _CreatePriConfigXmlForSplitting_AddFileWrites;

      _CreateUploadPriConfigXmlForSplitting;
      _CreateUploadPriConfigXmlForSplitting_AddFileWrites;

      _SplitResourcesPri_CalculateInputsAndOutputs;
      _SplitResourcesPri;
      _SplitResourcesPri_AddFileWrites;

      _SplitUploadResourcesPri_CalculateInputsAndOutputs;
      _SplitUploadResourcesPri;
      _SplitUploadResourcesPri_AddFileWrites;

      _ExpandMainPriFile;
      _ValidateAppxPackage;

      _CreatePriConfigXmlForMainPackageFileMap;
      _CreatePriConfigXmlForMainPackageFileMap_AddFileWrites;

      _CreateUploadPriConfigXmlForMainPackageFileMap;
      _CreateUploadPriConfigXmlForMainPackageFileMap_AddFileWrites;

      _CreateMainPackageFileMap_CalculateInputsAndOutputs;
      _CreateMainPackageFileMap;
      _CreateMainPackageFileMap_AddFileWrites;

      _CreateUploadMainPackageFileMap_CalculateInputsAndOutputs;
      _CreateUploadMainPackageFileMap;
      _CreateUploadMainPackageFileMap_AddFileWrites;

      _UpdateMainPackageFileMap;
      _UpdateMainPackageFileMap_AddFileWrites;

      _UpdateUploadMainPackageFileMap;
      _UpdateUploadMainPackageFileMap_AddFileWrites;

      _UpdateAppxManifestForBundle_CalculateInputsAndOutputs;
      _UpdateAppxManifestForBundle;
      _UpdateAppxManifestForBundle_AddFileWrites;

      _UpdateAppxUploadManifestForBundle_CalculateInputsAndOutputs;
      _UpdateAppxUploadManifestForBundle;
      _UpdateAppxUploadManifestForBundle_AddFileWrites;

      <!-- Create main app packages -->
      <!-- UAP -->
      _CreateMainPackage;
      _CreateMainPackage_AddFileWrites;

      _CreateMainUploadPackage;
      _CreateMainUploadPackage_AddFileWrites;

      <!-- Flat Bundle -->
      _HydrateAppxLayoutMainPackage;

      <!-- Create symbol packages -->
      <!-- UAP -->
      _GenerateAppxSymbolPackage;
      _GenerateAppxUploadSymbolPackage;

      <!-- Create resource packages -->
      <!-- UAP -->
      _CreateResourcePackages_CalculateInputsAndOutputs;
      _CreateResourcePackages;
      _CreateResourcePackages_AddFileWrites;

      _CreateUploadResourcePackages_CalculateInputsAndOutputs;
      _CreateUploadResourcePackages;
      _CreateUploadResourcePackages_AddFileWrites;

      <!-- Flat Bundle -->
      _HydrateAppxLayoutResourcePackage;
      _HydrateAppxLayoutAssetPackage;
      _HydrateAppxLayoutPrebuiltPackage;

      _CreatePlatformSpecificArtifactsList;
      _CreatePlatformSpecificUploadArtifactsList;

      _CreatePlatformAppxLayoutFiles;

      _CreateAppxBundleFiles;
      _CreateAppxLayoutFiles;
      _CreateTestLayout;

      <!-- App Installer -->
      GenerateAppInstallerForBundle;

      $(After_CreateAppxBundlePlatformSpecificArtifacts)
    </_CreateAppxBundlePlatformSpecificArtifactsDependsOn>
  </PropertyGroup>

  <Target Name="_CreateAppxBundlePlatformSpecificArtifacts"
          Condition="'$(ProduceAppxBundle)' == 'true' AND ('$(RequestingProject)' == '' OR '$(RequestingProject)' == '$(ProjectName)')"
          DependsOnTargets="$(_CreateAppxBundlePlatformSpecificArtifactsDependsOn)"
            />

  <!-- Create the sideload package layout -->
  <Target Name="_CreatePackageLayout_CalculateInputsAndOutputs">

    <RemovePayloadDuplicates Inputs="@(AppxPackagePayload)"
                             HasSharedItems="$(HasSharedItems)"
                             MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxPackagePayloadForPackageLayout" />
    </RemovePayloadDuplicates>
    
    <ItemGroup>
      <_PackageLayoutFileSource Include="@(_DeduplicatedAppxPackagePayloadForPackageLayout)" />
    </ItemGroup>

    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <_PackageLayoutFileSource Remove="@(_PackageLayoutFileSource)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>

    <ItemGroup>
      <_PackageLayoutFileSource Remove="$(ProjectPriFullPath)" />
    </ItemGroup>

    <ItemGroup>
      <_PackageLayoutFileTarget Include="@(_PackageLayoutFileSource->'$(AppxLayoutDir)%(TargetPath)')" />
    </ItemGroup>

  </Target>

  <!-- Create the upload package layout -->
  <Target Name="_CreateUploadPackageLayout_CalculateInputsAndOutputs"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

  <RemovePayloadDuplicates Inputs="@(AppxUploadPackagePayload)"
                             HasSharedItems="$(HasSharedItems)"
                             MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxUploadPackagePayloadForPackageLayout" />
    </RemovePayloadDuplicates>
    
    <!-- Make sure the target directory exists as GenerateAppxPackageRecipe won't create it -->
    <MakeDir Directories="$(IntermediateUploadOutputPath)" />

    <ItemGroup>
      <_UploadPackageLayoutFileSource Include="@(_DeduplicatedAppxUploadPackagePayloadForPackageLayout)" />
    </ItemGroup>

    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <_UploadPackageLayoutFileSource Remove="@(_UploadPackageLayoutFileSource)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>

    <ItemGroup>
      <_UploadPackageLayoutFileSource Remove="$(ProjectPriFullPath)" />
      <_UploadPackageLayoutFileSource Remove="$(ProjectPriUploadFullPath)" />
    </ItemGroup>

    <ItemGroup>
      <_UploadPackageLayoutFileTarget Include="@(_UploadPackageLayoutFileSource->'$(AppxUploadLayoutDir)%(TargetPath)')" />
    </ItemGroup>

  </Target>

  <!-- Create the sideload package layout -->
  <Target Name="_CreatePackageLayout">

    <RemoveDir Directories="$(AppxLayoutDir)" />

    <FilterItemGroup SourceItemGroup="@(_PackageLayoutFileSource)"
                     FilterProperty="NuGetSourceType"
                     FilterValue="Package"
                     VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FilterMatchItemGroup" ItemName="_PackageLayoutNugetContent" />
      <Output TaskParameter="FilterMismatchItemGroup" ItemName="_PackageLayoutContent" />
    </FilterItemGroup>

    <FilterItemGroup SourceItemGroup="@(_PackageLayoutFileTarget)"
                     FilterProperty="NuGetSourceType"
                     FilterValue="Package"
                     VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FilterMatchItemGroup" ItemName="_PackageLayoutNugetTarget" />
      <Output TaskParameter="FilterMismatchItemGroup" ItemName="_PackageLayoutTarget" />
    </FilterItemGroup>

    <Copy SourceFiles="@(_PackageLayoutContent)"
          DestinationFiles="@(_PackageLayoutTarget)"
          UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" />

    <Copy SourceFiles="@(_PackageLayoutNugetContent)"
          DestinationFiles="@(_PackageLayoutNugetTarget)"
          UseHardlinksIfPossible="$(AppxUseHardlinksForNugetIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" />

    <Message Text="$(MSBuildProjectName) -> $(AppxLayoutDir)" />

  </Target>

  <!-- Create the upload package layout -->
  <Target Name="_CreateUploadPackageLayout"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <RemoveDir Directories="$(AppxUploadLayoutDir)" />

    <FilterItemGroup SourceItemGroup="@(_UploadPackageLayoutFileSource)"
                     FilterProperty="NuGetSourceType"
                     FilterValue="Package"
                     VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FilterMatchItemGroup" ItemName="_PackageLayoutNugetContent" />
      <Output TaskParameter="FilterMismatchItemGroup" ItemName="_PackageLayoutContent" />
    </FilterItemGroup>

    <FilterItemGroup SourceItemGroup="@(_UploadPackageLayoutFileTarget)"
                     FilterProperty="NuGetSourceType"
                     FilterValue="Package"
                     VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FilterMatchItemGroup" ItemName="_PackageLayoutNugetTarget" />
      <Output TaskParameter="FilterMismatchItemGroup" ItemName="_PackageLayoutTarget" />
    </FilterItemGroup>

    <Copy SourceFiles="@(_PackageLayoutContent)"
          DestinationFiles="@(_PackageLayoutTarget)"
          UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" />

    <Copy SourceFiles="@(_PackageLayoutNugetContent)"
          DestinationFiles="@(_PackageLayoutNugetTarget)"
          UseHardlinksIfPossible="$(AppxUseHardlinksForNugetIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" />

    <Message Text="$(MSBuildProjectName) -> $(AppxUploadLayoutDir)" />

  </Target>

  <!-- add sideload file writes -->
  <Target Name="_CreatePackageLayout_AddFileWrites">

    <ItemGroup>
      <FileWrites Include="@(_PackageLayoutFileTarget)" />
      <PackagingDirectoryWrites Include="$(AppxLayoutDir)" />
    </ItemGroup>

  </Target>

  <!-- Add upload file writes -->
  <Target Name="_CreateUploadPackageLayout_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <FileWrites Include="@(_UploadPackageLayoutFileTarget)" />
      <PackagingUploadDirectoryWrites Include="$(AppxUploadLayoutDir)" />
    </ItemGroup>

  </Target>

  <!-- Create sideload pri config -->
  <Target Name="_CreatePriConfigXmlForSplitting"
          Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)"
          Outputs="$(AppxBundlePriConfigXmlForSplittingFileName)">

    <CreatePriConfigXmlForSplitting
        PriConfigXmlPath="$(AppxBundlePriConfigXmlForSplittingFileName)"
        ResourcesPriFilePath="$(ProjectPriFullPath)"
        PriInitialPath="$(AppxPriInitialPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
        AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
        IntermediateExtension="$(AppxIntermediateExtension)"
        PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)"
        PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformResourceVersion)"
        OmitSchemaFromResourcePacks="$(AppxOmitSchemaFromResourcePacks)"
        VsTelemetrySession="$(VsTelemetrySession)"
        />

  </Target>

  <!-- Create upload pri config -->
  <Target Name="_CreateUploadPriConfigXmlForSplitting"
          Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)"
          Outputs="$(AppxUploadBundlePriConfigXmlForSplittingFileName)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <CreatePriConfigXmlForSplitting
        PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForSplittingFileName)"
        ResourcesPriFilePath="$(ProjectPriFullPath)"
        PriInitialPath="$(AppxPriInitialPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
        AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
        IntermediateExtension="$(AppxIntermediateExtension)"
        PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)"
        PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformResourceVersion)"
        VsTelemetrySession="$(VsTelemetrySession)"
            />

  </Target>

  <!-- File writes for the sideload pri config -->
  <Target Name="_CreatePriConfigXmlForSplitting_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="$(AppxBundlePriConfigXmlForSplittingFileName)" />
      <FileWrites Include="$(AppxBundlePriConfigXmlForSplittingFileName)$(AppxIntermediateExtension)" />
    </ItemGroup>
  </Target>

  <!-- file writes for the upload pri config -->
  <Target Name="_CreateUploadPriConfigXmlForSplitting_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForSplittingFileName)" />
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForSplittingFileName)$(AppxIntermediateExtension)" />
    </ItemGroup>
  </Target>

  <!-- Prepare to split the sideload resources pri -->
  <Target Name="_SplitResourcesPri_CalculateInputsAndOutputs">

    <ItemGroup>
      <_AppxBundleSplitResourcesGeneratedFiles Remove="@(_AppxBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxBundleSplitResourcesGeneratedFilesListPath))"
                       File="$(AppxBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>

  </Target>

  <!-- Prepare to split the upload resources pri -->
  <Target Name="_SplitUploadResourcesPri_CalculateInputsAndOutputs"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <_AppxUploadBundleSplitResourcesGeneratedFiles Remove="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleSplitResourcesGeneratedFilesListPath))"
                       File="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>

  </Target>

  <!-- Split the sideload pri -->
  <Target Name="_SplitResourcesPri"
          Inputs="$(MSBuildAllProjects);$(ProjectPriFullPath)"
          Outputs="$(AppxBundleSplitResourcesGeneratedFilesListPath);@(_AppxBundleSplitResourcesGeneratedFiles)">

    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)"
                            MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                            PriConfigXmlPath="$(AppxBundlePriConfigXmlForSplittingFileName)"
                            ProjectPriIndexName="$(ProjectPriIndexName)"
                            MappingFileFormat="AppX"
                            ProjectDirectory="$(AppxLayoutDir)"
                            OutputFileName="$(AppxBundleSplitResourcesPriPath)"
                            GeneratedFilesListPath="$(AppxBundleSplitResourcesGeneratedFilesListPath)"
                            QualifiersPath="$(AppxBundleSplitResourcesQualifiersPath)"
                            IntermediateExtension="$(AppxIntermediateExtension)"
                            AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)"
                            AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
                            VsTelemetrySession="$(VsTelemetrySession)"
                            />

    <ItemGroup>
      <_AppxBundleSplitResourcesGeneratedFiles Remove="@(_AppxBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxBundleSplitResourcesGeneratedFilesListPath))"
                       File="$(AppxBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>

  </Target>

  <!-- Split the upload pri -->
  <Target Name="_SplitUploadResourcesPri"
          Inputs="$(MSBuildAllProjects);$(ProjectPriFullPath)"
          Outputs="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath);@(_AppxUploadBundleSplitResourcesGeneratedFiles)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)"
                            MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                            PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForSplittingFileName)"
                            ProjectPriIndexName="$(ProjectPriIndexName)"
                            MappingFileFormat="AppX"
                            ProjectDirectory="$(AppxUploadLayoutDir)"
                            OutputFileName="$(AppxUploadBundleSplitResourcesPriPath)"
                            GeneratedFilesListPath="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)"
                            QualifiersPath="$(AppxUploadBundleSplitResourcesQualifiersPath)"
                            IntermediateExtension="$(AppxIntermediateExtension)"
                            AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)"
                            AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
                            VsTelemetrySession="$(VsTelemetrySession)"
                            />

    <ItemGroup>
      <_AppxUploadBundleSplitResourcesGeneratedFiles Remove="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleSplitResourcesGeneratedFilesListPath))"
                       File="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>

  </Target>

  <!-- Wrap up splitting the sideload pri -->
  <Target Name="_SplitResourcesPri_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="@(_AppxBundleSplitResourcesGeneratedFiles)" />
      <FileWrites Include="$(AppxBundleSplitResourcesGeneratedFilesListPath)" />
      <FileWrites Include="$(AppxBundleSplitResourcesQualifiersPath)" />
      <FileWrites Include="$(AppxBundleSplitResourcesQualifiersPath).intermediate" />
    </ItemGroup>
  </Target>

  <!-- Wrap up splitting the upload pri -->
  <Target Name="_SplitUploadResourcesPri_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" />
      <FileWrites Include="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)" />
      <FileWrites Include="$(AppxUploadBundleSplitResourcesQualifiersPath)" />
      <FileWrites Include="$(AppxUploadBundleSplitResourcesQualifiersPath).intermediate" />
    </ItemGroup>
  </Target>

  <!-- Create the sideload pri config xml -->
  <Target Name="_CreatePriConfigXmlForMainPackageFileMap"
          Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)"
          Outputs="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)">

    <!-- Filter satellite assemblies out -->
    <GenerateMainPriConfigurationFile
        Condition="'$(_FilteredPackageLayoutFilePath)' != ''"
        FilteredPackageLayoutFilePath="$(_FilteredPackageLayoutFilePath)"
        PackageLayoutFiles="@(_PackageLayoutFileTarget)"
        ExcludedPackageLayoutFilePath="$(_ExcludedPackageLayoutFilePath)" />

    <PropertyGroup Condition="'$(_FilteredPackageLayoutFilePath)' != ''">
      <_FilteredPackageLayoutFileFullPath>$([System.IO.Path]::GetFullPath($(_FilteredPackageLayoutFilePath)))</_FilteredPackageLayoutFileFullPath>
      <_FilteredPackageLayoutUploadFileFullPath>$([System.IO.Path]::GetFullPath($(_FilteredUploadPackageLayoutFilePath)))</_FilteredPackageLayoutUploadFileFullPath>
    </PropertyGroup>

    <!-- PackageLayoutFilePath needs to be a fullpath as the ProjectRoot we use later for generating the pri file will fail to resolve the file -->
    <CreatePriConfigXmlForMainPackageFileMap
        PriConfigXmlPath="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)"
        PackageLayoutFilePath="$(_FilteredPackageLayoutFileFullPath)"
        PriInitialPath="$(AppxPriInitialPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
        AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
        IntermediateExtension="$(AppxIntermediateExtension)"
        PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)"
        PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformResourceVersion)"
        VsTelemetrySession="$(VsTelemetrySession)" />

  </Target>

  <!-- Create the upload pri config xml -->
  <Target Name="_CreateUploadPriConfigXmlForMainPackageFileMap"
          Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)"
          Outputs="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <!-- Filter satellite assemblies out -->
    <GenerateMainPriConfigurationFile
        Condition="'$(_FilteredUploadPackageLayoutFilePath)' != ''"
        FilteredPackageLayoutFilePath="$(_FilteredUploadPackageLayoutFilePath)"
        PackageLayoutFiles="@(_UploadPackageLayoutFileTarget)"
        ExcludedPackageLayoutFilePath="$(_ExcludedUploadPackageLayoutFilePath)" />

    <CreatePriConfigXmlForMainPackageFileMap
        PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)"
        PackageLayoutFilePath="$(_FilteredPackageLayoutUploadFileFullPath)"
        PriInitialPath="$(AppxPriInitialPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
        AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
        IntermediateExtension="$(AppxIntermediateExtension)"
        PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)"
        PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformResourceVersion)"
        VsTelemetrySession="$(VsTelemetrySession)" />

  </Target>

  <!-- Filewrites for sideload pri config xml -->
  <Target Name="_CreatePriConfigXmlForMainPackageFileMap_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)" />
      <FileWrites Include="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_FilteredPackageLayoutFilePath)" />
      <FileWrites Include="$(_ExcludedPackageLayoutFilePath)" />
    </ItemGroup>
  </Target>

  <!-- Filewrites for upload pri config xml -->
  <Target Name="_CreateUploadPriConfigXmlForMainPackageFileMap_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)" />
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_FilteredUploadPackageLayoutFilePath)" />
      <FileWrites Include="$(_ExcludedUploadPackageLayoutFilePath)" />
    </ItemGroup>
  </Target>

  <!-- Prepare to create the sideload package file map -->
  <Target Name="_CreateMainPackageFileMap_CalculateInputsAndOutputs">

    <ItemGroup>
      <_AppxBundleMainPackageMapInputs Include="$(AppxLayoutDir)\**\*" />
    </ItemGroup>

    <ItemGroup>
      <_AppxBundleMainPackageMapGeneratedFiles Remove="@(_AppxBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxBundleMainPackageFileMapGeneratedFilesListPath))"
                       File="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>

  </Target>

  <!-- Prepare to create the upload package file map -->
  <Target Name="_CreateUploadMainPackageFileMap_CalculateInputsAndOutputs"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <_AppxUploadBundleMainPackageMapInputs Include="$(AppxUploadLayoutDir)\**\*" />
    </ItemGroup>

    <ItemGroup>
      <_AppxUploadBundleMainPackageMapGeneratedFiles Remove="@(_AppxUploadBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath))"
                       File="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>

  </Target>

  <!-- Create the sideload package file map -->
  <Target Name="_CreateMainPackageFileMap"
          Inputs="$(MSBuildAllProjects);@(_AppxBundleMainPackageMapInputs)"
          Outputs="$(AppxBundleMainPackageFileMapIntermediatePath)">

    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)"
                            MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                            PriConfigXmlPath="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)"
                            ProjectPriIndexName="$(ProjectPriIndexName)"
                            MappingFileFormat="AppX"
                            ProjectDirectory="$(AppxLayoutDir)"
                            OutputFileName="$(AppxBundleMainPackageFileMapIntermediatePriPath)"
                            GeneratedFilesListPath="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)"
                            AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)"
                            IntermediateExtension="$(AppxIntermediateExtension)"
                            AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
                            VsTelemetrySession="$(VsTelemetrySession)"
                            />

    <ItemGroup>
      <_AppxBundleMainPackageMapGeneratedFiles Remove="@(_AppxBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxBundleMainPackageFileMapGeneratedFilesListPath))"
                       File="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>

  </Target>

  <!-- Create the upload package file map -->
  <Target Name="_CreateUploadMainPackageFileMap"
          Inputs="$(MSBuildAllProjects);@(_AppxUploadBundleMainPackageMapInputs)"
          Outputs="$(AppxUploadBundleMainPackageFileMapIntermediatePath)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)"
                            MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                            PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)"
                            ProjectPriIndexName="$(ProjectPriIndexName)"
                            MappingFileFormat="AppX"
                            ProjectDirectory="$(AppxUploadLayoutDir)"
                            OutputFileName="$(AppxUploadBundleMainPackageFileMapIntermediatePriPath)"
                            GeneratedFilesListPath="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)"
                            AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)"
                            IntermediateExtension="$(AppxIntermediateExtension)"
                            AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
                            VsTelemetrySession="$(VsTelemetrySession)"
                            />

    <ItemGroup>
      <_AppxUploadBundleMainPackageMapGeneratedFiles Remove="@(_AppxUploadBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath))"
                       File="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>

  </Target>

  <!-- Wrap up creating the sideload file map -->
  <Target Name="_CreateMainPackageFileMap_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="@(_AppxBundleMainPackageMapGeneratedFiles)" />
      <FileWrites Include="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)" />
    </ItemGroup>
  </Target>

  <!-- Wrap up creating the upload file map -->
  <Target Name="_CreateUploadMainPackageFileMap_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(_AppxUploadBundleMainPackageMapGeneratedFiles)" />
      <FileWrites Include="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)" />
    </ItemGroup>
  </Target>

  <!-- Update the sideload package file map -->
  <Target Name="_UpdateMainPackageFileMap"
          Inputs="$(MSBuildAllProjects);$(AppxBundleMainPackageFileMapIntermediatePath);$(AppxBundleSplitResourcesPriPath);$(_ExcludedLayoutResfilesPath)"
          Outputs="$(AppxBundleMainPackageFileMapPath)"
          DependsOnTargets="_FindAppxContentGroupMap">

    <ItemGroup>
      <_AppxBundleSplitResourcesPriPathItem Include="$(AppxBundleSplitResourcesPriPath)" />
    </ItemGroup>

    <ItemGroup>
      <_ExcludedFromResourceIndexFileList Include="$(_ExcludedLayoutResfilesPath)" />
      <_ExcludedFromResourceIndexFileList Include="$(_ExcludedPackageLayoutFilePath)" />
    </ItemGroup>

    <UpdateMainPackageFileMap
        AppxContentGroupMap="$(AppxContentGroupMapFullPath)"
        Input="$(AppxBundleMainPackageFileMapIntermediatePath)"
        ExcludedFromResourceIndexFileList="@(_ExcludedFromResourceIndexFileList)"
        PackageLayout="$(AppxLayoutDir)"
        InputFileList="$(FileMapInputList)"
        Output="$(AppxBundleMainPackageFileMapPath)"
        SplitResourcesPriPath="%(_AppxBundleSplitResourcesPriPathItem.FullPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
        VsTelemetrySession="$(VsTelemetrySession)"
            />

  </Target>

  <!-- Update the upload package file map -->
  <Target Name="_UpdateUploadMainPackageFileMap"
          Inputs="$(MSBuildAllProjects);$(AppxUploadBundleMainPackageFileMapIntermediatePath);$(AppxUploadBundleSplitResourcesPriPath);$(_ExcludedLayoutResfilesPath)"
          Outputs="$(AppxUploadBundleMainPackageFileMapPath)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
          DependsOnTargets="_FindAppxContentGroupMap">

    <ItemGroup>
      <_AppxUploadBundleSplitResourcesPriPathItem Include="$(AppxUploadBundleSplitResourcesPriPath)" />
    </ItemGroup>

    <ItemGroup>
      <_ExcludedUploadFromResourceIndexFileList Include="$(_ExcludedLayoutResfilesPath)" />
      <_ExcludedUploadFromResourceIndexFileList Include="$(_ExcludedUploadPackageLayoutFilePath)" />
    </ItemGroup>

    <UpdateMainPackageFileMap
        AppxContentGroupMap="$(AppxContentGroupMapFullPath)"
        Input="$(AppxUploadBundleMainPackageFileMapIntermediatePath)"
        ExcludedFromResourceIndexFileList="@(_ExcludedUploadFromResourceIndexFileList)"
        PackageLayout="$(AppxUploadLayoutDir)"
        InputFileList="$(UploadFileMapInputList)"
        Output="$(AppxUploadBundleMainPackageFileMapPath)"
        SplitResourcesPriPath="%(_AppxUploadBundleSplitResourcesPriPathItem.FullPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
        VsTelemetrySession="$(VsTelemetrySession)"
            />

  </Target>

  <!-- Wrap up updating the sideload package file map -->
  <Target Name="_UpdateMainPackageFileMap_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="$(AppxBundleMainPackageFileMapPath)" />
    </ItemGroup>
  </Target>

  <!--Wrap up updating the upload package file map -->
  <Target Name="_UpdateUploadMainPackageFileMap_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadBundleMainPackageFileMapPath)" />
    </ItemGroup>
  </Target>

  <!-- Prepare to update the sideload manifest -->
  <Target Name="_UpdateAppxManifestForBundle_CalculateInputsAndOutputs">

    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' == 'true'">
      <AppxManifestForBundle Include="@(FinalAppxManifest)" />
    </ItemGroup>

    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' != 'true'">
      <AppxManifestForBundle Include="@(FinalAppxManifest->'%(RootDir)%(Directory)ForBundle\%(Filename)%(Extension)')" />
    </ItemGroup>

  </Target>

  <!-- Prepare to update the upload manifest -->
  <Target Name="_UpdateAppxUploadManifestForBundle_CalculateInputsAndOutputs"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' == 'true'">
      <AppxUploadManifestForBundle Include="@(FinalAppxUploadManifest)" />
    </ItemGroup>

    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' != 'true'">
      <!-- split.pri gets added in a previous step and should not be re-added here -->
      <AppxUploadManifestForBundle Include="@(FinalAppxUploadManifest->'%(RootDir)%(Directory)ForUploadBundle\%(Filename)%(Extension)')" Condition="'%(FinalAppxUploadManifest.TargetPath)' != 'split.pri'" />
    </ItemGroup>

  </Target>

  <!-- Update the sideload manifest -->
  <Target Name="_UpdateAppxManifestForBundle"
          Inputs="$(MSBuildAllProjects);@(FinalAppxManifest)"
          Outputs="@(AppxManifestForBundle)">

    <MakeDir Directories="@(AppxManifestForBundle->'%(RootDir)%(Directory)')" />

    <UpdateAppxManifestForBundle FinalAppxManifest="@(FinalAppxManifest)"
                                 AppxManifestForBundle="@(AppxManifestForBundle)"
                                 TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                                 VsTelemetrySession="$(VsTelemetrySession)"
                                     />

  </Target>

  <!-- Update the upload manifest -->
  <Target Name="_UpdateAppxUploadManifestForBundle"
          Inputs="$(MSBuildAllProjects);@(FinalAppxUploadManifest)"
          Outputs="@(AppxUploadManifestForBundle)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <MakeDir Directories="@(AppxUploadManifestForBundle->'%(RootDir)%(Directory)')" />

    <UpdateAppxManifestForBundle FinalAppxManifest="@(FinalAppxUploadManifest)"
                                 AppxManifestForBundle="@(AppxUploadManifestForBundle)"
                                 TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                                 VsTelemetrySession="$(VsTelemetrySession)"
                                     />

  </Target>

  <!-- Wrap up updating the sideload manifest -->
  <Target Name="_UpdateAppxManifestForBundle_AddFileWrites">

    <ItemGroup>
      <FileWrites Include="@(AppxManifestForBundle)" />
      <PackagingDirectoryWrites Include="@(AppxManifestForBundle->'%(RootDir)%(Directory)')" />
    </ItemGroup>

  </Target>

  <!-- Wrap up updating the upload manifest -->
  <Target Name="_UpdateAppxUploadManifestForBundle_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <FileWrites Include="@(AppxUploadManifestForBundle)" />
      <PackagingUploadDirectoryWrites Include="@(AppxUploadManifestForBundle->'%(RootDir)%(Directory)')" />
    </ItemGroup>

  </Target>

  <!-- Create the sideload appx -->
  <Target Name="_CreateMainPackage"
          Inputs="$(MSBuildAllProjects);@(AppxManifestForBundle);$(AppxBundleMainPackageFileMapPath);$(PackageCertificateKeyFile)"
          Outputs="$(AppxMainPackageOutput)"
          Condition="'$(BuildAppxSideloadPackageForUap)' == 'true' and
                     '$(UseAppxLayout)' != 'true'"
          DependsOnTargets="_FindAppxContentGroupMap;_DeleteAppxOutputFolderIfNecessary">

    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  AppxContentGroupMap="$(AppxContentGroupMapFullPath)"
                  AppxStreamableMainPackage="$(AppxStreamableMainPackage)"
                  AppxStreamableResourcePackages="$(AppxStreamableResourcePackages)"
                  ResourcePack="false"
                  Parameters="$(CreatePackageMakeAppxParameters)"
                  HashAlgorithmId="$(AppxHashAlgorithmId)"
                  ValidateResourcesReferencedByManifest="false"
                  AppxManifest="@(AppxManifestForBundle)"
                  FileMap="$(AppxBundleMainPackageFileMapPath)"
                  Output="$(AppxMainPackageOutput)"
                  VsTelemetrySession="$(VsTelemetrySession)"
                      />

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="$(AppxMainPackageOutput)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     CertificatePassword="$(PackageCertificatePassword)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                     TempCertificateFilePath="$(TempCertificateFilePath)"
                     VsTelemetrySession="$(VsTelemetrySession)"
                     SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)"
                     SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)"
                     AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)"
                     AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)"
                     AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)"
                     AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)"
                     AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)"
                     AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)"
                     AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)"
                     AzureKeyVaultUrl="$(AzureKeyVaultUrl)"
                     AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)"/>

    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> $(AppxMainPackageOutput)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(MSBuildProjectName) -> $(AppxMainPackageOutput) (unsigned)" />


    <ItemGroup>
      <InstallerFileWrites Include="@(AppxMainPackageOutput)" />
    </ItemGroup>
  </Target>

  <!-- Create the upload appx -->
  <Target Name="_CreateMainUploadPackage"
          Inputs="$(MSBuildAllProjects);@(AppxUploadManifestForBundle);$(AppxUploadBundleMainPackageFileMapPath);$(PackageCertificateKeyFile)"
          Outputs="$(AppxUploadMainPackageOutput)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true' and
                     '$(UseAppxLayout)' != 'true'"
          DependsOnTargets="_FindAppxContentGroupMap">

    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  AppxContentGroupMap="$(AppxContentGroupMapFullPath)"
                  AppxStreamableMainPackage="$(AppxStreamableMainPackage)"
                  AppxStreamableResourcePackages="$(AppxStreamableResourcePackages)"
                  ResourcePack="false"
                  Parameters="$(CreatePackageMakeAppxParameters)"
                  HashAlgorithmId="$(AppxHashAlgorithmId)"
                  ValidateResourcesReferencedByManifest="false"
                  AppxManifest="@(AppxUploadManifestForBundle)"
                  FileMap="$(AppxUploadBundleMainPackageFileMapPath)"
                  Output="$(AppxUploadMainPackageOutput)"
                  VsTelemetrySession="$(VsTelemetrySession)"
                  IsUploadPackageOrComponent="true"
                      />

  </Target>

  <!-- Wrap up creating the sideload package -->
  <Target Name="_CreateMainPackage_AddFileWrites"
          Condition="'$(BuildAppxSideloadPackageForUap)' == 'true' and
                     '$(UseAppxLayout)' != 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxMainPackageOutput)" />
      <PackagingDirectoryWrites Include="$(AppxBundleDir)" />
    </ItemGroup>
  </Target>

  <!-- Wrap up creating the upload package -->
  <Target Name="_CreateMainUploadPackage_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true' and
                     '$(UseAppxLayout)' != 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadMainPackageOutput)" />
      <PackagingUploadDirectoryWrites Include="$(AppxUploadBundleDir)" />
    </ItemGroup>
  </Target>

  <!-- Resource packages are created during the build of the platform which will produce the bundle.               -->
  <!-- There is a work item to validate that assumption which will move resource pack generation to target Bundle. -->
  <!-- 635606: Resource Packs: Validate generated resource packs file maps across architectures                   -->

  <!-- Prep to create the sideload resource packages -->
  <Target Name="_CreateResourcePackages_CalculateInputsAndOutputs"
          Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)'">

    <PropertyGroup>
      <_FileNameToRemove>%(_AppxBundleSplitResourcesPriPathItem.FileName)$(AppxBundleMainPackageFileMapSuffix)</_FileNameToRemove>
    </PropertyGroup>

    <ItemGroup>
      <_AppxBundleResourceFileMapsIntermediate Include="@(_AppxBundleSplitResourcesGeneratedFiles)"
                                               Condition="'%(Extension)' == '.txt' and '%(FileName)' != '$(_FileNameToRemove)'">
        <ResourcePack>$(AppxResourcePackOutputBase)$([System.String]::Copy('%(Filename)').Replace('$(AppxBundleSplitResourcesPriPrefix).','_').Replace('$(AppxBundleMainPackageFileMapSuffix)',''))$(AppxPackageExtension)</ResourcePack>
      </_AppxBundleResourceFileMapsIntermediate>
    </ItemGroup>

    <FilterOutUnusedLanguagesResourceFileMaps FileMaps="@(_AppxBundleResourceFileMapsIntermediate)"
                                              FileNamePrefix="$(AppxBundleSplitResourcesPriPrefix)"
                                              MapSuffix="$(AppxBundleMainPackageFileMapSuffix)"
                                              Languages="@(_ManifestResources->WithMetadataValue('Dimension', 'Language')->'%(Value)')"
                                              VsTelemetrySession="$(VsTelemetrySession)"
                                              Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' == 'true'"
                                                  >
      <Output TaskParameter="FilteredFileMaps" ItemName="_AppxBundleResourceFileMaps" />
    </FilterOutUnusedLanguagesResourceFileMaps>

    <ItemGroup Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' != 'true'">
      <_AppxBundleResourceFileMaps Include="@(_AppxBundleResourceFileMapsIntermediate)" />
    </ItemGroup>

  </Target>

  <!-- Prep to create the upload resource packages -->
  <Target Name="_CreateUploadResourcePackages_CalculateInputsAndOutputs"
          Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and
                     '$(BuildAppxUploadPackageForUap)' == 'true'">

    <PropertyGroup>
      <_FileNameToRemove>%(_AppxBundleSplitResourcesPriPathItem.FileName)$(AppxBundleMainPackageFileMapSuffix)</_FileNameToRemove>
    </PropertyGroup>

    <ItemGroup Condition="'$(UseAppxLayout)' != 'true'" >
      <_AppxUploadBundleResourceFileMapsIntermediate Include="@(_AppxUploadBundleSplitResourcesGeneratedFiles)"
                                                     Condition="'%(Extension)' == '.txt' and '%(FileName)' != '$(_FileNameToRemove)'">
        <ResourcePack>$(AppxUploadResourcePackOutputBase)$([System.String]::Copy('%(Filename)').Replace('$(AppxBundleSplitResourcesPriPrefix).','_').Replace('$(AppxBundleMainPackageFileMapSuffix)',''))$(AppxPackageExtension)</ResourcePack>
      </_AppxUploadBundleResourceFileMapsIntermediate>
    </ItemGroup>

    <ItemGroup Condition="'$(UseAppxLayout)' == 'true'" >
      <_AppxUploadBundleResourceFileMapsIntermediate Include="@(_AppxUploadBundleSplitResourcesGeneratedFiles)"
                                                     Condition="'%(Extension)' == '.txt' and '%(FileName)' != '$(_FileNameToRemove)'">
        <ResourcePack>$(AppxUploadResourcePackOutputBase)\$(AppxPackageNameNeutral)$([System.String]::Copy('%(Filename)').Replace('$(AppxBundleSplitResourcesPriPrefix).','-').Replace('$(AppxBundleMainPackageFileMapSuffix)',''))$(AppxPackageExtension)</ResourcePack>
      </_AppxUploadBundleResourceFileMapsIntermediate>
    </ItemGroup>

    <FilterOutUnusedLanguagesResourceFileMaps FileMaps="@(_AppxUploadBundleResourceFileMapsIntermediate)"
                                              FileNamePrefix="$(AppxBundleSplitResourcesPriPrefix)"
                                              MapSuffix="$(AppxBundleMainPackageFileMapSuffix)"
                                              Languages="@(_ManifestResources->WithMetadataValue('Dimension', 'Language')->'%(Value)')"
                                              VsTelemetrySession="$(VsTelemetrySession)"
                                              Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' == 'true'"
                                                  >
      <Output TaskParameter="FilteredFileMaps" ItemName="_AppxUploadBundleResourceFileMaps" />
    </FilterOutUnusedLanguagesResourceFileMaps>

    <ItemGroup Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' != 'true'">
      <_AppxUploadBundleResourceFileMaps Include="@(_AppxUploadBundleResourceFileMapsIntermediate)" />
    </ItemGroup>

  </Target>

  <Target Name="_CreateResourcePackages"
          Inputs="@(_AppxBundleResourceFileMaps)"
          Outputs="%(ResourcePack)"
          Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and
                     '$(BuildAppxSideloadPackageForUap)' == 'true' and
                     '$(UseAppxLayout)' != 'true'"
          DependsOnTargets="_FindAppxContentGroupMap">

    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  AppxContentGroupMap="$(AppxContentGroupMapFullPath)"
                  AppxStreamableMainPackage="$(AppxStreamableMainPackage)"
                  AppxStreamableResourcePackages="$(AppxStreamableResourcePackages)"
                  ResourcePack="true"
                  Parameters="$(CreateResourcePackageMakeAppxParameters)"
                  EncryptAppxPackage="$(AppxPackageEncryptionEnabled)"
                  HashAlgorithmId="$(AppxHashAlgorithmId)"
                  ValidateResourcesReferencedByManifest="false"
                  AppxManifest="@(AppxManifestForBundle)"
                  FileMap="%(_AppxBundleResourceFileMaps.Identity)"
                  Output="%(_AppxBundleResourceFileMaps.ResourcePack)"
                  VsTelemetrySession="$(VsTelemetrySession)"
                  />

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="%(_AppxBundleResourceFileMaps.ResourcePack)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     CertificatePassword="$(PackageCertificatePassword)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                     TempCertificateFilePath="$(TempCertificateFilePath)"
                     VsTelemetrySession="$(VsTelemetrySession)"
                     SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)"
                     SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)"
                     AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)"
                     AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)"
                     AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)"
                     AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)"
                     AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)"
                     AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)"
                     AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)"
                     AzureKeyVaultUrl="$(AzureKeyVaultUrl)"
                     AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)"/>

    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> %(_AppxBundleResourceFileMaps.ResourcePack)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(MSBuildProjectName) -> %(_AppxBundleResourceFileMaps.ResourcePack) (unsigned)" />

    <ItemGroup>
      <InstallerFileWrites Include="$(AppxPackagePublicKeyFile)" />
    </ItemGroup>
  </Target>

  <Target Name="_CreateUploadResourcePackages"
          Inputs="@(_AppxUploadBundleResourceFileMaps)"
          Outputs="%(ResourcePack)"
          Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and
                     '$(BuildAppxUploadPackageForUap)' == 'true' and
                     '$(UseAppxLayout)' != 'true'"
          DependsOnTargets="_FindAppxContentGroupMap">

    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  AppxContentGroupMap="$(AppxContentGroupMapFullPath)"
                  AppxStreamableMainPackage="$(AppxStreamableMainPackage)"
                  AppxStreamableResourcePackages="$(AppxStreamableResourcePackages)"
                  ResourcePack="true"
                  Parameters="$(CreateResourcePackageMakeAppxParameters)"
                  HashAlgorithmId="$(AppxHashAlgorithmId)"
                  ValidateResourcesReferencedByManifest="false"
                  AppxManifest="@(AppxUploadManifestForBundle)"
                  FileMap="%(_AppxUploadBundleResourceFileMaps.Identity)"
                  Output="%(_AppxUploadBundleResourceFileMaps.ResourcePack)"
                  VsTelemetrySession="$(VsTelemetrySession)"
                  IsUploadPackageOrComponent="true"
                      />

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="%(_AppxUploadBundleResourceFileMaps.ResourcePack)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     CertificatePassword="$(PackageCertificatePassword)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                     TempCertificateFilePath="$(TempCertificateFilePath)"
                     VsTelemetrySession="$(VsTelemetrySession)"
                     SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)"
                     SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)"
                     AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)"
                     AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)"
                     AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)"
                     AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)"
                     AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)"
                     AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)"
                     AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)"
                     AzureKeyVaultUrl="$(AzureKeyVaultUrl)"
                     AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)"/>

    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> %(_AppxUploadBundleResourceFileMaps.ResourcePack)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(MSBuildProjectName) -> %(_AppxUploadBundleResourceFileMaps.ResourcePack) (unsigned)" />

  </Target>

  <Target Name="_CreateResourcePackages_AddFileWrites"
          Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)'">

    <ItemGroup>
      <FileWrites Include="@(_AppxBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>

  </Target>

  <Target Name="_CreateUploadResourcePackages_AddFileWrites"
          Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and
                     '$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <FileWrites Include="@(_AppxUploadBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>

  </Target>

  <!-- Create sideload artifacts list -->
  <Target Name="_CreatePlatformSpecificArtifactsList">

    <MakeDir Directories="$(PlatformSpecificBundleArtifactsListDir)" />

    <ItemGroup>
      <_AppxBundleResourcePack Include="@(_AppxBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>

    <ItemGroup>
      <_PlatformSpecificBundleArtifact Include="MainPackage=$([System.IO.Path]::GetFullPath('$(AppxMainPackageOutput)'))"     Condition="Exists($(AppxMainPackageOutput))" />
      <_PlatformSpecificBundleArtifact Include="SymbolPackage=$([System.IO.Path]::GetFullPath('$(AppxSymbolPackageIntermediate)'))" Condition="Exists($(AppxSymbolPackageIntermediate))" />
      <_PlatformSpecificBundleArtifact Include="ResourcePack=%(_AppxBundleResourcePack.FullPath)"                             Condition="'@(_AppxBundleResourcePack)' != ''" />
    </ItemGroup>

    <Delete Files="$(AppxBundlePlatformSpecificArtifactsListPath)" />

    <WriteLinesToFile File="$(AppxBundlePlatformSpecificArtifactsListPath)"
                      Lines="@(_PlatformSpecificBundleArtifact)"
                          />

    <!-- Creating packaging info file for every architecture we are building. -->
    <!-- That way, wizard completion page can know which architectures are    -->
    <!-- included in the bundle.                                              -->

    <PropertyGroup Condition="'$(AppxBundleNameForOutput)' == ''">
      <AppxBundleNameForOutput>$(AppxPackageNameNeutral)_$(AppxBundlePlatformsForNaming)</AppxBundleNameForOutput>
      <AppxBundleNameForOutput Condition="'$(UseAppxLayout)' == 'true'">$(AppxBundleNameForOutput)</AppxBundleNameForOutput>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxBundleOutput)' == ''">
      <AppxBundleOutput Condition="'$(AppxPackageEncryptionEnabled)' != 'true'">$(AppxPackageTestDir)$(AppxBundleNameForOutput)$(_AppxPackageConfiguration)$(AppxBundleExtension)</AppxBundleOutput>
      <AppxBundleOutput Condition="'$(AppxPackageEncryptionEnabled)' == 'true'">$(AppxPackageTestDir)$(AppxBundleNameForOutput)$(_AppxPackageConfiguration)$(AppxBundleEncryptedExtension)</AppxBundleOutput>
    </PropertyGroup>

    <WriteLinesToFile File="$(AppxPackagingInfoFile)"
                      Overwrite="true"
                      Lines="$([System.IO.Path]::GetFullPath('$(AppxBundleOutput)'))" />

    <ItemGroup>
      <FileWrites Include="$(AppxPackagingInfoFile)" />
    </ItemGroup>

  </Target>

  <!-- Create upload artifacts list -->
  <Target Name="_CreatePlatformSpecificUploadArtifactsList"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <MakeDir Directories="$(PlatformSpecificUploadBundleArtifactsListDir)" />

    <ItemGroup>
      <_AppxUploadBundleResourcePack Include="@(_AppxUploadBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>

    <ItemGroup>
      <_PlatformSpecificUploadBundleArtifact Include="MainPackage=$([System.IO.Path]::GetFullPath('$(AppxUploadMainPackageOutput)'))" Condition="Exists($(AppxUploadMainPackageOutput)) and '$(UseAppxLayout)' != 'true'" />
      <_PlatformSpecificUploadBundleArtifact Include="SymbolPackage=$([System.IO.Path]::GetFullPath('$(AppxUploadSymbolPackageOutput)'))" Condition="Exists($(AppxUploadSymbolPackageOutput))" />
      <_PlatformSpecificUploadBundleArtifact Include="ResourcePack=%(_AppxUploadBundleResourcePack.FullPath)" Condition="'@(_AppxUploadBundleResourcePack)' != ''" />
    </ItemGroup>

    <Delete Files="$(AppxBundlePlatformSpecificUploadArtifactsListPath)" />

    <WriteLinesToFile File="$(AppxBundlePlatformSpecificUploadArtifactsListPath)"
                      Lines="@(_PlatformSpecificUploadBundleArtifact)"
                          />

    <PropertyGroup Condition="'$(AppxUploadBundleOutput)' == '' and '$(UseAppxLayout)' != 'true'">
      <AppxUploadBundleOutput>$(AppxUploadPackageDir)$(AppxPackageNameNeutral)_$(AppxBundlePlatformsForNaming)$(_AppxPackageConfiguration)$(AppxBundleExtension)</AppxUploadBundleOutput>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUploadBundleOutput)' == '' and '$(UseAppxLayout)' == 'true'">
      <AppxUploadBundleOutput>$(AppxUploadPackageDir)$(AppxPackageNameNeutralFlatBundle)$(AppxBundleExtension)</AppxUploadBundleOutput>
    </PropertyGroup>

  </Target>

  <!-- ============================= -->
  <!-- Produce the app bundle files. -->
  <!-- ============================= -->

  <PropertyGroup>

    <_CreateAppxBundleFilesDependsOn>
      $(BeforeCreateAppxBundleFiles);

      _GetSdkToolPaths;
      _ValidatePresenceOfAppxManifestItems;
      _GetPackageProperties;

      _GetOtherPlatformsToBundle;
      _ProducePlatformSpecificBundleArtifactsForOtherPlatforms;

      _GetPlatformSpecificBundleArtifacts;

      _CreateBundle_CalculateInputsAndOutputs;
      _CreateBundle_GenerateBundleMappingFile;
      _CreateBundle_CopyExternalPackages;
      _CreateBundle;
      _CreateBundle_AddFileWrites;
      _CopyAppxSymToOutput;

      _CreateUploadBundle_CalculateInputsAndOutputs;
      _CreateUploadBundle_GenerateBundleMappingFile;
      _CreateUploadBundle_CopyExternalPackages;
      _CreateUploadBundle;
      _CreateUploadBundle_AddFileWrites;

      _CreateAppStoreBundleContainer_CalculateInputsAndOutputs;
      _CreateAppStoreBundleContainer;
      _CreateAppStoreBundleContainer_AddFileWrites;

      _AddWindowsInstallScriptToTestLayout;

      $(AfterCreateAppxBundleFiles)
    </_CreateAppxBundleFilesDependsOn>

  </PropertyGroup>

  <Target Name="_CreateAppxBundleFiles"
          Condition="('$(AppxBundleProducingPlatform)' == '$(PackageArchitecture)' or '$(GenerateAppxPackageOnBuild)' == 'true') and
                     '$(_SkipBundleCreation)' != 'true' and
                     '$(UseAppxLayout)' != 'true'"
          DependsOnTargets="$(_CreateAppxBundleFilesDependsOn)"
            />

  <PropertyGroup>

    <_CreateAppxLayoutFilesDependsOn>
      $(BeforeCreateAppxLayoutFiles);

      _GetSdkToolPaths;
      _ValidatePresenceOfAppxManifestItems;
      _GetPackageProperties;

      _GetOtherPlatformsToBundle;
      _ProducePlatformSpecificBundleArtifactsForOtherPlatforms;

      _GetPlatformSpecificBundleArtifacts;

      _CreateAppxLayoutPackage;
      _CreateAppxLayoutUploadPackage;

      _CreateAppStoreBundleContainer_CalculateInputsAndOutputs;
      _CreateAppStoreBundleContainer;
      _CreateAppStoreBundleContainer_AddFileWrites;

      _AddWindowsInstallScriptToTestLayout;

      $(AfterCreateAppxLayoutFiles)
    </_CreateAppxLayoutFilesDependsOn>

  </PropertyGroup>

  <Target Name="_CreateAppxLayoutFiles"
          Condition="('$(AppxBundleProducingPlatform)' == '$(PackageArchitecture)' or '$(GenerateAppxPackageOnBuild)' == 'true') and
                     '$(_SkipBundleCreation)' != 'true' and
                     '$(UseAppxLayout)' == 'true'"
          DependsOnTargets="$(_CreateAppxLayoutFilesDependsOn)"
            />

  <Target Name="_GetOtherPlatformsToBundle"
          Condition="'$(GenerateAppxPackageOnBuild)' == 'true'">

    <PropertyGroup>
      <_AdjustedPlatform Condition="'$(Platform)' != 'Win32'">$(Platform)</_AdjustedPlatform>
      <_AdjustedPlatform Condition="'$(Platform)' == 'Win32'">x86</_AdjustedPlatform>
    </PropertyGroup>

    <ItemGroup>
      <_OtherPlatformToBundle Condition="'%(Identity)' != '$(_AdjustedPlatform)'" Include="@(AppxBundlePlatformWithAnyCPU)" />
    </ItemGroup>

  </Target>

  <Target Name="_ProducePlatformSpecificBundleArtifactsForOtherPlatforms"
          Condition="'@(_OtherPlatformToBundle)' != ''"
          Inputs="@(_OtherPlatformToBundle)"
          Outputs="%(Identity).AlwaysRun">

    <PropertyGroup>
      <_TargetToBuild Condition="'$(_Rebuilding)' == 'true'">Rebuild</_TargetToBuild>
      <_TargetToBuild Condition="'$(_Rebuilding)' != 'true'">Build</_TargetToBuild>
    </PropertyGroup>

    <PropertyGroup Condition="'$(SolutionPath)' == '' or '$(SolutionPath)' == '*Undefined*'">
      <_FileToBuild>$(MSBuildProjectFullPath)</_FileToBuild>
      <_ShouldUnsetParentConfigurationAndPlatform>false</_ShouldUnsetParentConfigurationAndPlatform>
      <_SolutionConfigurationContentsToUse></_SolutionConfigurationContentsToUse>
    </PropertyGroup>

    <MSBuild Projects="$(SolutionPath)"
             Condition="'$(SolutionPath)' != '' and '$(SolutionPath)' != '*Undefined*'"
             Targets="GetSolutionConfigurationContents"
             Properties="Configuration=$(Configuration);Platform=%(_OtherPlatformToBundle.Identity)"
             ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="TargetOutputs" PropertyName="_SolutionConfigurationContentsToUse"/>
    </MSBuild>

    <PropertyGroup Condition="'$(SolutionPath)' != '' and '$(SolutionPath)' != '*Undefined*' and '$(IsOptionalProject)' != 'true'">
      <_FileToBuild>$(SolutionPath)</_FileToBuild>
      <_ShouldUnsetParentConfigurationAndPlatform>true</_ShouldUnsetParentConfigurationAndPlatform>
    </PropertyGroup>

    <PropertyGroup Condition="'$(IsOptionalProject)' == 'true'">
      <_FileToBuild>$(MSBuildProjectFullPath)</_FileToBuild>
      <_ShouldUnsetParentConfigurationAndPlatform>true</_ShouldUnsetParentConfigurationAndPlatform>
      <_SolutionConfigurationContentsToUse></_SolutionConfigurationContentsToUse>
    </PropertyGroup>

    <ItemGroup>
      <_InternalBuildProperties Include="ShouldUnsetParentConfigurationAndPlatform=$(_ShouldUnsetParentConfigurationAndPlatform)" />
      <_InternalBuildProperties Include="CurrentSolutionConfigurationContents=$(_SolutionConfigurationContentsToUse)" />
      <_InternalBuildProperties Include="Configuration=$(Configuration)" />
      <_InternalBuildProperties Include="Platform=%(_OtherPlatformToBundle.Identity)" />
      <_InternalBuildProperties Include="_SkipBundleCreation=true" />
      <_InternalBuildProperties Include="PlatformSpecificBundleArtifactsListDir=$(PlatformSpecificBundleArtifactsListDir)" />
      <_InternalBuildProperties Include="AppxPackageDir=$(AppxPackageDir)" />
      <_InternalBuildProperties Include="OriginalTargetDir=$(TargetDir)" />
      <_InternalBuildProperties Include="RequestingProject=$(ProjectName)" />
    </ItemGroup>

    <PropertyGroup Condition="'$(UseSubFolderForOutputDirDuringMultiPlatformBuild)' == 'true'">
      <InternalBuildOutputPath>$(OutputPath)</InternalBuildOutputPath>
      <InternalBuildOutputPath Condition="!HasTrailingSlash('$(InternalBuildOutputPath)')">$(InternalBuildOutputPath)\</InternalBuildOutputPath>
      <InternalBuildOutputPath>$(InternalBuildOutputPath)%(_OtherPlatformToBundle.Identity)\</InternalBuildOutputPath>
      <InternalBuildOutDir>$(OutDir)</InternalBuildOutDir>
      <InternalBuildOutDir Condition="!HasTrailingSlash('$(InternalBuildOutDir)')">$(InternalBuildOutDir)\</InternalBuildOutDir>
      <InternalBuildOutDir>$(InternalBuildOutDir)%(_OtherPlatformToBundle.Identity)\</InternalBuildOutDir>
    </PropertyGroup>

    <ItemGroup Condition="'$(UseSubFolderForOutputDirDuringMultiPlatformBuild)' == 'true'">
      <_InternalBuildProperties Include="OutputPath=$(InternalBuildOutputPath)" />
      <_InternalBuildProperties Include="OutDir=$(InternalBuildOutDir)" />
    </ItemGroup>

    <!-- Build the package(s) for other platforms that will be included in the bundle. -->
    <MSBuild Projects="$(_FileToBuild)"
             Targets="$(_TargetToBuild)"
             Properties="@(_InternalBuildProperties)"
             ContinueOnError="$(ContinueOnError)"/>

  </Target>

  <Target Name="_GetPlatformSpecificBundleArtifacts">

    <ItemGroup>
      <_PlatformSpecificBundleArtifact Remove="@(_PlatformSpecificBundleArtifact)" />
    </ItemGroup>

    <ItemGroup>
      <_PlatformSpecificUploadBundleArtifact Remove="@(_PlatformSpecificUploadBundleArtifact)" />
    </ItemGroup>

    <ParsePlatformSpecificBundleArtifactsLists Files="$(PlatformSpecificBundleArtifactsListDir)%(AppxBundlePlatform.Identity).txt" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Artifacts" ItemName="_PlatformSpecificBundleArtifact" />
    </ParsePlatformSpecificBundleArtifactsLists>

    <ParsePlatformSpecificBundleArtifactsLists Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
                                               Files="$(PlatformSpecificUploadBundleArtifactsListDir)%(AppxBundlePlatform.Identity).txt" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Artifacts" ItemName="_PlatformSpecificUploadBundleArtifact" />
    </ParsePlatformSpecificBundleArtifactsLists>

    <ItemGroup>
      <_MainPackageToBundle   Include="@(_PlatformSpecificBundleArtifact)" Condition="'%(Name)' == 'MainPackage'" />
      <_SymbolPackageToBundle Include="@(_PlatformSpecificBundleArtifact)" Condition="'%(Name)' == 'SymbolPackage'" />
      <_ResourcePackToBundle  Include="@(_PlatformSpecificBundleArtifact)" Condition="'%(Name)' == 'ResourcePack'" />
    </ItemGroup>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_MainUploadPackageToBundle Include="@(_PlatformSpecificUploadBundleArtifact)" Condition="'%(Name)' == 'MainPackage'"/>
      <_SymbolUploadPackageToBundle Include="@(_PlatformSpecificUploadBundleArtifact)" Condition="'%(Name)' == 'SymbolPackage'" />
      <_ResourceUploadPackToBundle  Include="@(_PlatformSpecificUploadBundleArtifact)" Condition="'%(Name)' == 'ResourcePack'" />
    </ItemGroup>

  </Target>

  <!-- Prep to create the sideload bundle -->
  <Target Name="_CreateBundle_CalculateInputsAndOutputs">

    <ItemGroup>
      <_CreateBundleInputs Include="@(_MainPackageToBundle)" />
      <_CreateBundleInputs Include="@(_ResourcePackToBundle)" />
    </ItemGroup>

  </Target>

  <!-- Prep the sideload bundle mapping file -->
  <Target Name="_CreateBundle_GenerateBundleMappingFile"
          Condition="'@(BundleMappingFile)' != ''">

    <!--Include the list of External Packages in the appropriate ItemGroup-->
    <ItemGroup>
      <BundleMappingSideloadExternalPackages Include="@(_BundleMappingExternalPackages)" />
    </ItemGroup>

    <GenerateMappingFile Files="@(_CreateBundleInputs)"
                         ExternalPackages="@(BundleMappingSideloadExternalPackages)"
                         TargetDirectory="$(AppxMappingFileDir)"
                         VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="MappingFile" PropertyName="AppxBundleMappingFile" />
    </GenerateMappingFile>

  </Target>

  <Target Name="_CreateBundle_CopyExternalPackages"
          Condition="'@(BundleMappingFile)' != ''">

    <RemoveDir Directories="$(AppxPackageTestExternalPackagesDir)" />

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(BundleMappingSideloadExternalPackages)"
          DestinationFolder="$(AppxPackageTestExternalPackagesDir)"
              />

  </Target>

  <!-- Prep to create the upload bundle -->
  <Target Name="_CreateUploadBundle_CalculateInputsAndOutputs"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <_CreateUploadBundleInputs Include="@(_MainUploadPackageToBundle)" />
      <_CreateUploadBundleInputs Include="@(_ResourceUploadPackToBundle)" />
    </ItemGroup>

  </Target>

  <!-- Prep the upload bundle mapping file -->
  <Target Name="_CreateUploadBundle_GenerateBundleMappingFile"
          Condition="'@(BundleMappingFile)' != ''">

    <!--Include the list of External Packages in the appropriate ItemGroup-->
    <ItemGroup>
      <BundleMappingUploadExternalPackages Include="@(_BundleMappingExternalPackages)" />
    </ItemGroup>

    <GenerateMappingFile Files="@(_CreateUploadBundleInputs)"
                         ExternalPackages="@(BundleMappingUploadExternalPackages)"
                         TargetDirectory="$(AppxUploadMappingFileDir)"
                         VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="MappingFile" PropertyName="AppxUploadBundleMappingFile" />
    </GenerateMappingFile>

  </Target>

  <Target Name="_CreateUploadBundle_CopyExternalPackages"
          Condition="'@(BundleMappingFile)' != ''">

    <RemoveDir Directories="$(AppxUploadPackageExternalpackagesDir)" />

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(BundleMappingUploadExternalPackages)"
          DestinationFolder="$(AppxUploadPackageExternalpackagesDir)"
              />

  </Target>

  <!-- Create the sideload bundle -->
  <Target Name="_CreateBundle"
          Inputs="$(MSBuildAllProjects);@(_CreateBundleInputs);$(PackageCertificateKeyFile)"
          Outputs="$(AppxBundleOutput)"
          Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">

    <VerifyAppxBundlePlatforms PackageArchitecture="$(PackageArchitecture)"
                               AppxBundlePlatforms="@(AppxBundlePlatform)"
                                   />

    <RemoveDir Directories="$(AppxBundleDir)" />

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(_CreateBundleInputs)"
          DestinationFolder="$(AppxBundleDir)"
              />

    <ItemGroup>
      <_AppxBundleContent Include="$(AppxBundleDir)*" />
    </ItemGroup>

    <PropertyGroup Condition="'$(AppxBundleManifestVersion)' == '' and '$(SDKIdentifier)' != ''">
      <AppxBundleManifestVersion>$(AppxManifestIdentityVersion)</AppxBundleManifestVersion>
    </PropertyGroup>

    <MakeAppxBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                    EncryptAppxPackage="$(AppxPackageEncryptionEnabled)"
                    AppxBundleManifestVersion="$(AppxBundleManifestVersion)"
                    BundleDir="$(AppxBundleDir)"
                    Output="$(AppxBundleOutput)"
                    BundleMappingFile="$(AppxBundleMappingFile)"
                    VsTelemetrySession="$(VsTelemetrySession)"
                        />

    <ItemGroup>
      <AllBuiltSideloadPackages Include="$(AppxBundleOutput)"/>
    </ItemGroup>

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="$(AppxBundleOutput)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     CertificatePassword="$(PackageCertificatePassword)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                     TempCertificateFilePath="$(TempCertificateFilePath)"
                     ExportCertificate="true"
                     VsTelemetrySession="$(VsTelemetrySession)"
                     SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)"
                     SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)"
                     AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)"
                     AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)"
                     AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)"
                     AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)"
                     AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)"
                     AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)"
                     AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)"
                     AzureKeyVaultUrl="$(AzureKeyVaultUrl)"
                     AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint"/>
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>

    <Message Importance="high" Text="$(MSBuildProjectName) -> $(AppxBundleOutput)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> $(AppxPackagePublicKeyFile)" />

    <ItemGroup>
      <InstallerFileWrites Include="$(AppxPackagePublicKeyFile)" />
    </ItemGroup>
  </Target>

  <!-- Create the upload bundle -->
  <Target Name="_CreateUploadBundle"
          Inputs="$(MSBuildAllProjects);@(_CreateUploadBundleInputs);$(PackageCertificateKeyFile)"
          Outputs="$(AppxUploadBundleOutput)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <VerifyAppxBundlePlatforms PackageArchitecture="$(PackageArchitecture)"
                               AppxBundlePlatforms="@(AppxBundlePlatform)"
                                   />

    <RemoveDir Directories="$(AppxUploadBundleDir)" />

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(_CreateUploadBundleInputs)"
          DestinationFolder="$(AppxUploadBundleDir)"
              />

    <ItemGroup>
      <_AppxUploadBundleContent Include="$(AppxUploadBundleDir)*" />
    </ItemGroup>

    <PropertyGroup Condition="'$(AppxBundleManifestVersion)' == '' and '$(SDKIdentifier)' != ''">
      <AppxBundleManifestVersion>$(AppxManifestIdentityVersion)</AppxBundleManifestVersion>
    </PropertyGroup>

    <MakeAppxBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                    AppxBundleManifestVersion="$(AppxBundleManifestVersion)"
                    BundleDir="$(AppxUploadBundleDir)"
                    Output="$(AppxUploadBundleOutput)"
                    BundleMappingFile="$(AppxUploadBundleMappingFile)"
                    VsTelemetrySession="$(VsTelemetrySession)"
                    IsUploadPackageOrComponent="true"
                        />

    <!-- Validate that all Optional Packages are store associated. -->
    <ValidateAppxOptionalPackageUploadBundle Condition="'@(BundleMappingSideloadExternalPackages)' != ''"
                                             SideloadOptionalPackages="@(BundleMappingSideloadExternalPackages)"
                                             StoreAssociatedOptionalPackages="@(BundleMappingUploadExternalPackages)"
                                             VsTelemetrySession="$(VsTelemetrySession)">
    </ValidateAppxOptionalPackageUploadBundle>


    <ItemGroup>
      <AllBuiltUploadPackages Include="$(AppxUploadBundleOutput)"/>
    </ItemGroup>

  </Target>

  <!-- wrap up creating the sideload bundle -->
  <Target Name="_CreateBundle_AddFileWrites"
          Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxBundleOutput)" />
      <InstallerFileWrites Include="$(AppxBundleOutput)" />
      <PackagingDirectoryWrites Include="$(AppxBundleDir)" />
    </ItemGroup>
  </Target>

  <!-- Copy the .appxsym files to the output directory -->
  <Target Name="_CopyAppxSymToOutput"
          Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
    <Copy UseHardlinksIfPossible="false"
          SourceFiles="@(_SymbolPackageToBundle)"
          DestinationFolder="$(AppxPackageTestDir)"
              />
  </Target>

  <!-- wrap up creating the upload bundle -->
  <Target Name="_CreateUploadBundle_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxUploadBundleOutput)" />
      <PackagingUploadDirectoryWrites Include="$(AppxUploadBundleDir)" />
    </ItemGroup>
  </Target>


  <!--create the final appxupload bundle inputs-->
  <Target Name="_CreateAppStoreBundleContainer_CalculateInputsAndOutputs"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup Condition="'$(UseAppxLayout)' != 'true'">
      <_CreateAppStoreBundleContainerInputs Include="$(AppxUploadBundleOutput)" />
      <_CreateAppStoreBundleContainerInputs Include="@(_SymbolUploadPackageToBundle)" />
    </ItemGroup>

    <ItemGroup Condition="'$(UseAppxLayout)' == 'true'">
      <_CreateAppStoreBundleContainerInputs Include="@(AppxLayoutUploadContents)" />
      <_CreateAppStoreBundleContainerInputs Include="@(_SymbolUploadPackageToBundle)" />
    </ItemGroup>

    <PropertyGroup Condition="'$(AppxStoreContainer)' == ''">
      <AppxStoreContainer>$(AppxPackageDir)$(AppxPackageNameNeutral)_$(AppxBundlePlatformsForNaming)_bundle$(_AppxPackageConfiguration)$(AppxStoreContainerExtension)</AppxStoreContainer>
    </PropertyGroup>

  </Target>

  <Target Name="_CreateAppStoreBundleContainer"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
          Inputs="$(MSBuildAllProjects);@(_CreateAppStoreBundleContainerInputs)"
          Outputs="$(AppxStoreContainer)">

    <MakeDir Directories="$(AppxPackageDir)" />

    <CreateAppStoreContainer
        Items="@(_CreateAppStoreBundleContainerInputs)"
        ProjectName="$(MSBuildProjectName)"
        OutputPath="$(AppxStoreContainer)"
        VsTelemetrySession="$(VsTelemetrySession)"
            />

    <WriteLinesToFile File="$(AppxUploadPackagingInfoFile)"
                      Overwrite="true"
                      Lines="$([System.IO.Path]::GetFullPath('$(AppxStoreContainer)'))" />

    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackagingInfoFile)" />
    </ItemGroup>

  </Target>

  <Target Name="_CreateAppStoreBundleContainer_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxStoreContainer)" />
    </ItemGroup>
  </Target>

  <!-- =============================== -->
  <!-- Atomic set creation support.    -->
  <!-- =============================== -->

  <Target Name="_BuildOptionalProjects"
          Condition="'$(BuildOptionalProjects)' == 'true' and
                     ('$(AppxBundlePlatforms)' == '' or '$(AppxBundleProducingPlatform)' == '$(PackageArchitecture)') and
                     (('@(BundleMappingFile)' != '' and '@(_BundleMappingOptionalProjects)' != '') or '@(_AppxLayoutOptionalPackages)' != '')">

    <!--Combine the target to build with GetOptionalProjectOutputs to get back the details we need.-->
    <PropertyGroup>
      <_TargetsToBuild Condition="'$(_Rebuilding)' == 'true'">Rebuild</_TargetsToBuild>
      <_TargetsToBuild Condition="'$(_Rebuilding)' != 'true'">Build</_TargetsToBuild>
      <_TargetsToBuild>$(_TargetsToBuild);GetOptionalProjectOutputs</_TargetsToBuild>
    </PropertyGroup>

    <PropertyGroup>
      <_ContinueOnError Condition="'$(BuildingProject)' == 'true'">false</_ContinueOnError>
      <_ContinueOnError Condition="'$(BuildingProject)' != 'true'">true</_ContinueOnError>
    </PropertyGroup>

    <!--Build the properties list. Split over multiple lines so it's a bit easier to read.-->
    <PropertyGroup>
      <_BuildProperties>Platform=$(Platform);Configuration=$(Configuration)</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);UAPAppxPackageBuildMode=$(UAPAppxPackageBuildMode)</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);AppxPackageIsForStore=$(AppxPackageIsForStore)</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);IncludeOptionalProjectsOutputGroup=true</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);IsOptionalProject=true</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);BuildingInsideVisualStudio=false</_BuildProperties>
      <_BuildProperties Condition="'$(BuildingInsideVisualStudio)' == 'true'">$(_BuildProperties);GenerateAppxPackageOnBuild=$(PackageOptionalProjectsInIdeBuilds)</_BuildProperties>
      <_BuildProperties Condition="'$(BuildingInsideVisualStudio)' != 'true'">$(_BuildProperties);GenerateAppxPackageOnBuild=$(GenerateAppxPackageOnBuild)</_BuildProperties>
    </PropertyGroup>

    <!--Create the project references for the build.-->
    <ItemGroup>
      <OptionalProjectBuildReferences Include="@(_BundleMappingOptionalProjects)" Condition="'@(_BundleMappingOptionalProjects)' != ''">
        <Properties>$(_BuildProperties)</Properties>
      </OptionalProjectBuildReferences>
      <OptionalProjectBuildReferences Include="@(_AppxLayoutOptionalPackages)" Condition="'@(_AppxLayoutOptionalPackages)' != ''">
        <Properties>$(_BuildProperties)</Properties>
      </OptionalProjectBuildReferences>
    </ItemGroup>

    <!--Build the list of Optional Projects and capture the output from each.-->
    <MSBuild Condition="'$(BuildingInsideVisualStudio)' == 'true'"
             Projects="@(OptionalProjectBuildReferences)"
             BuildInParallel="false"
             ContinueOnError="$(_ContinueOnError)"
             Targets="$(_TargetsToBuild)" >
      <Output TaskParameter="TargetOutputs" ItemName="_OptionalProjectOutputs"/>
    </MSBuild>

    <MSBuild Condition="'$(BuildingInsideVisualStudio)' != 'true'"
             Projects="@(OptionalProjectBuildReferences)"
             BuildInParallel="$(BuildInParallel)"
             ContinueOnError="$(_ContinueOnError)"
             RemoveProperties="AppxPackageDir;OutputPath"
             Targets="$(_TargetsToBuild)" >
      <Output TaskParameter="TargetOutputs" ItemName="_OptionalProjectOutputs"/>
    </MSBuild>

    <!--For Deployment (i.e. debug) builds we just want recipes, manifests, and any external packages.-->
    <ItemGroup>
      <BundleMappingRecipes Include="@(_OptionalProjectOutputs)" Condition="'%(_OptionalProjectOutputs.FileType)'=='Recipe'" />
      <BundleMappingExternalPackages Include="@(_OptionalProjectOutputs)" Condition="'%(_OptionalProjectOutputs.FileType)'=='Manifest'" />
    </ItemGroup>

    <!--For packaging builds, split sideload and upload into their own groups. Both get the same list of External Packages.-->
    <ItemGroup>
      <BundleMappingSideloadExternalPackages Include="@(_OptionalProjectOutputs)" Condition="'%(_OptionalProjectOutputs.FileType)'=='SideloadPackage'" />
    </ItemGroup>

    <ItemGroup>
      <BundleMappingUploadExternalPackages Include="@(_OptionalProjectOutputs)" Condition="'%(_OptionalProjectOutputs.FileType)'=='UploadPackage'" />
    </ItemGroup>

  </Target>

  <!-- Prep the deployable bundle mapping file -->
  <Target Name="_GenerateBundleMappingFile"
          Condition="'@(BundleMappingFile)' != '' and
                     '$(UseAppxLayout)' != 'true'">

    <!--Include the list of External Packages in the appropriate ItemGroup-->
    <ItemGroup>
      <BundleMappingExternalPackages Include="@(_BundleMappingExternalPackages)" />
    </ItemGroup>

    <GenerateMappingFile Files="$(FinalAppxManifestName)"
                         ExternalPackages="@(BundleMappingExternalPackages)"
                         TargetDirectory="$(AppxMappingFileDir)"
                         VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="MappingFile" PropertyName="AppxBundleMappingFile" />
    </GenerateMappingFile>

  </Target>

  <Target Name="_GenerateBundleManifest"
          Condition="'@(BundleMappingFile)' != '' and
                     '@(_BundleMappingOptionalProjects)' != '' and
                     '$(UseAppxLayout)' != 'true'">

    <MakeAppxBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                    Output="$(FinalAppxBundleManifestName)"
                    BundleDir="$(AppxBundleDir)"
                    GenerateBundleManifestOnly="true"
                    BundleMappingFile="$(AppxBundleMappingFile)"
                    VsTelemetrySession="$(VsTelemetrySession)"
                    />

  </Target>

  <!-- =============================== -->
  <!-- Clean/Rebuild support.          -->
  <!-- =============================== -->

  <!-- Cleans current project and any referenced projects' appx package artifacts. -->
  <Target Name="_CleanAppxPackage"
          Condition="'$(AppxPackage)' == 'true' and '$(GenerateAppxPackageOnBuild)' == 'true'"
          DependsOnTargets="$(_CleanAppxPackageDependsOn)"
          AfterTargets="Clean">

    <ReadLinesFromFile File="$(PackagingDirectoryWritesLogPath)"
                       Condition="Exists($(PackagingDirectoryWritesLogPath))">
      <Output TaskParameter="Lines" ItemName="_DirectoriesToRemove" />
    </ReadLinesFromFile>

    <RemoveDir Directories="@(_DirectoriesToRemove)" ContinueOnError="true" />
    <Delete Files="$(PackagingDirectoryWritesLogPath)" ContinueOnError="true" TreatErrorsAsWarnings="true" />

    <ReadLinesFromFile File="$(PackagingFileWritesLogPath)"
                       Condition="Exists($(PackagingFileWritesLogPath))">
      <Output TaskParameter="Lines" ItemName="_FilesToRemove" />
    </ReadLinesFromFile>

    <Delete Files="@(_FilesToRemove)" ContinueOnError="true" TreatErrorsAsWarnings="true" />
    <Delete Files="$(PackagingFileWritesLogPath)" ContinueOnError="true" TreatErrorsAsWarnings="true" />

  </Target>

  <!-- Rebuild appx package target and entry point. -->
  <Target Name="_RebuildAppxPackage"
          Condition="'$(AppxPackage)' == 'true'"
          DependsOnTargets="$(CleanPackageAction);$(PackageAction)"
            />

  <!-- ========================================== -->
  <!-- Returns Architecture for given Platform.   -->
  <!-- ========================================== -->

  <Target Name="_GetProjectArchitecture"
          Returns="@(ProjectArchitecture)">

    <PropertyGroup>
      <_ProjectArchitectureOutput>Invalid</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'AnyCPU'">neutral</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'x86'">x86</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'Win32'">x86</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'x64'">x64</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'arm'">arm</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'arm64'">arm64</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'arm64ec'">arm64ec</_ProjectArchitectureOutput>
    </PropertyGroup>

    <ItemGroup>
      <ProjectArchitecture Include="$(_ProjectArchitectureOutput)" />
    </ItemGroup>

  </Target>

  <!-- ========================================== -->
  <!-- Getting all packaging outputs.             -->
  <!-- Returns items that packaging targets need. -->
  <!-- ========================================== -->

  <PropertyGroup>
    <GetPackagingOutputsDependsOn>
      $(GetPackagingOutputsDependsOn);
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence;
      _CalculateXbfSupport;
    </GetPackagingOutputsDependsOn>
  </PropertyGroup>

  <Target Name="GetPackagingOutputs"
          Returns="@(PackagingOutputs)"
          DependsOnTargets="$(GetPackagingOutputsDependsOn)">

    <CallTarget Targets="BuiltProjectOutputGroup" Condition="'$(IncludeBuiltProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_BuiltProjectOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="%(_BuiltProjectOutputGroupOutput.FinalOutputPath)">
        <TargetPath>%(_BuiltProjectOutputGroupOutput.TargetPath)</TargetPath>
        <OutputGroup>BuiltProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="DebugSymbolsProjectOutputGroup" Condition="'$(IncludeDebugSymbolsProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_DebugSymbolsProjectOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="%(_DebugSymbolsProjectOutputGroupOutput.FinalOutputPath)">
        <OutputGroup>DebugSymbolsProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="DocumentationProjectOutputGroup" Condition="'$(IncludeDocumentationProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_DocumentationProjectOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_DocumentationProjectOutputGroupOutput)">
        <OutputGroup>DocumentationProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="SatelliteDllsProjectOutputGroup" Condition="'$(IncludeSatelliteDllsProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SatelliteDllsProjectOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SatelliteDllsProjectOutputGroupOutput)">
        <OutputGroup>SatelliteDllsProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="SourceFilesProjectOutputGroup" Condition="'$(IncludeSourceFilesProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SourceFilesProjectOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SourceFilesProjectOutputGroupOutput)">
        <OutputGroup>SourceFilesProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="SGenFilesOutputGroup" Condition="'$(IncludeSGenFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SGenFilesOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SGenFilesOutputGroupOutput)">
        <OutputGroup>SGenFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="CopyLocalFilesOutputGroup" Condition="'$(IncludeCopyLocalFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CopyLocalFilesOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_CopyLocalFilesOutputGroupOutput)">
        <OutputGroup>CopyLocalFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="GetCopyToOutputDirectoryItemsOutputGroup" Condition="'$(IncludeGetCopyToOutputDirectoryItemsOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_GetCopyToOutputDirectoryItemsOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_GetCopyToOutputDirectoryItemsOutputGroupOutput)">
        <OutputGroup>GetCopyToOutputDirectoryItemsOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="ComFilesOutputGroup" Condition="'$(IncludeComFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_ComFilesOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_ComFilesOutputGroupOutput)">
        <OutputGroup>ComFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="CopyWinmdArtifactsOutputGroup" Condition="'$(IncludeCopyWinmdArtifactsOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CopyWinmdArtifactsOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_CopyWinmdArtifactsOutputGroupOutput)">
        <OutputGroup>CopyWinmdArtifactsOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="SDKRedistOutputGroup" Condition="'$(IncludeSDKRedistOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SDKRedistOutputGroupOutput"/>
    </CallTarget>

    <ItemGroup Condition="'$(AppxExcludeXbfFromSdkPayloadWhenXamlIsPresent)' == 'true'">
      <!-- If extension SDK contains both XAML and XBF files, do not package XBF files from SDK -->
      <_SDKRedistRedundantXBF Include="@(_SDKRedistOutputGroupOutput->'%(RootDir)%(Directory)%(Filename).xbf')"
                              Condition="'%(Extension)'=='.xaml'" />
      <_SDKRedistOutputGroupOutput Remove="@(_SDKRedistRedundantXBF)" />
    </ItemGroup>

    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SDKRedistOutputGroupOutput)">
        <OutputGroup>SDKRedistOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
      <_PackagingOutputsUnexpanded Remove="@(RemoveSdkFilesFromAppxPackage)" />
    </ItemGroup>

    <CallTarget Targets="PriFilesOutputGroup" Condition="'$(IncludePriFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_PriFilesOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_PriFilesOutputGroupOutput)">
        <OutputGroup>PriFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="ContentFilesProjectOutputGroup" Condition="'$(IncludeContentFilesProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_ContentFilesProjectOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_ContentFilesProjectOutputGroupOutput)">
        <OutputGroup>ContentFilesProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)\%(_ContentFilesProjectOutputGroupOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="CustomOutputGroupForPackaging" Condition="'$(IncludeCustomOutputGroupForPackaging)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CustomOutputGroupForPackagingOutput"/>
    </CallTarget>

    <ItemGroup Condition="'$(DisableEmbeddedXbf)' != 'true'">
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(_CustomOutputGroupForPackagingOutput.ReferenceSourceTarget)' == 'ExpandSDKReference'">
        <OutputGroup>SDKRedistOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
      <_CustomOutputGroupForPackagingOutput Remove="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(_CustomOutputGroupForPackagingOutput.ReferenceSourceTarget)' == 'ExpandSDKReference'"/>
    </ItemGroup>

    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(Extension)' != '.xbf'">
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(Extension)' == '.xbf' AND '$(_SupportXbfAsEmbedFileResources)' != 'true'">
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(Extension)' == '.xbf' AND '$(_SupportXbfAsEmbedFileResources)' == 'true'">
        <OutputGroup>EmbedOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <ExpandPayloadDirectories Inputs="@(_PackagingOutputsUnexpanded)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Expanded" ItemName="_PackagingOutputsExpanded" />
    </ExpandPayloadDirectories>

    <CallTarget Targets="GetResolvedSDKReferences" Condition="'$(IncludeGetResolvedSDKReferences)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_GetResolvedSDKReferencesOutputWithoutMetadata"/>
    </CallTarget>
    <ItemGroup>
      <_GetResolvedSDKReferencesOutput Include="@(_GetResolvedSDKReferencesOutputWithoutMetadata)">
        <OutputGroup>GetResolvedSDKReferences</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_GetResolvedSDKReferencesOutput>
    </ItemGroup>

    <CallTarget Targets="_GetProjectArchitecture">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectArchitecture" />
    </CallTarget>

    <ItemGroup>
      <_ProjectArchitectureItem Include="@(_ProjectArchitecture)">
        <OutputGroup>_GetProjectArchitecture</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_ProjectArchitectureItem>
    </ItemGroup>

    <ItemGroup>
      <ProjectPriFile Include="$(ProjectPriFullPath)" Condition="'$(IncludeProjectPriFile)' == 'true'">
        <OutputGroup>ProjectPriFile</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </ProjectPriFile>
    </ItemGroup>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <ProjectPriUploadFile Include="$(ProjectPriUploadFullPath)" Condition="'$(IncludeProjectPriFile)' == 'true'">
        <OutputGroup>ProjectPriUploadFile</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </ProjectPriUploadFile>
    </ItemGroup>

    <PropertyGroup>
      <_ContinueOnError Condition="'$(BuildingProject)' == 'true'">false</_ContinueOnError>
      <_ContinueOnError Condition="'$(BuildingProject)' != 'true'">true</_ContinueOnError>
    </PropertyGroup>

    <MSBuild
      Projects="@(ProjectReferenceWithConfiguration)"
      Targets="GetPackagingOutputs"
      BuildInParallel="$(BuildInParallel)"
      Properties="%(ProjectReferenceWithConfiguration.SetConfiguration); %(ProjectReferenceWithConfiguration.SetPlatform)"
      Condition="'@(ProjectReferenceWithConfiguration)' != ''
                 and '%(ProjectReferenceWithConfiguration.BuildReference)' == 'true'
                 and '%(ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == 'true'"
      ContinueOnError="$(_ContinueOnError)">
      <Output TaskParameter="TargetOutputs" ItemName="_PackagingOutputsFromOtherProjects"/>
    </MSBuild>

    <ItemGroup>
      <_PackagingOutputsOutsideLayout Include="@(ProjectPriFile)" />
      <_PackagingOutputsOutsideLayout Include="@(_PackagingOutputsExpanded)" />
      <_PackagingOutputsOutsideLayout Include="@(_GetResolvedSDKReferencesOutput)" />
      <_PackagingOutputsOutsideLayout Include="@(_PackagingOutputsFromOtherProjects)" />
    </ItemGroup>

    <ItemGroup>
      <PathsToExcludeFromLayoutOutputGroup Include="@(_PackagingOutputsOutsideLayout->'%(TargetPath)')" />
      <PathsToExcludeFromLayoutOutputGroup Include="$(AppxManifestTargetPath)" />
      <PathsToExcludeFromLayoutOutputGroup Include="$(DeploymentRecipeTargetPath)" />
    </ItemGroup>

    <ItemGroup>
      <DirsToExcludeFromLayoutOutputGroup Include="$(WinMetadataDir)" />
      <DirsToExcludeFromLayoutOutputGroup Include="$(EntryPointDir)" />
    </ItemGroup>

    <ExpandPayloadDirectories
        Condition="'$(IncludeLayoutFilesInPackage)' == 'true'"
        Inputs="$(LayoutDir)"
        TargetDirsToExclude="@(DirsToExcludeFromLayoutOutputGroup)"
        TargetFilesToExclude="@(PathsToExcludeFromLayoutOutputGroup)"
        VsTelemetrySession="$(VsTelemetrySession)"
        >
      <Output TaskParameter="Expanded" ItemName="_PackagingOutputsFromLayout" />
    </ExpandPayloadDirectories>

    <ItemGroup>
      <PackagingOutputs Include="@(_PackagingOutputsFromLayout)">
        <ProjectName>$(ProjectName)</ProjectName>
        <OutputGroup>LayoutOutputGroup</OutputGroup>
      </PackagingOutputs>
      <PackagingOutputs Include="@(_PackagingOutputsOutsideLayout)" />
      <PackagingOutputs Include="@(_ProjectArchitectureItem)" />
    </ItemGroup>

    <!-- Remove all .xaml files from the payload that correlate with a .xbf file -->
    <ItemGroup>
      <_PackagingOutputsXbfXaml Include="$([System.IO.Path]::ChangeExtension('%(PackagingOutputs.Identity)','.xaml'))" Condition="'%(Extension)' == '.xbf'" />
      <PackagingOutputs Remove="@(_PackagingOutputsXbfXaml)" />
    </ItemGroup>

  </Target>

  <!-- ========================================== -->
  <!-- Getting all Optional Project outputs.      -->
  <!-- Returns items that packaging targets need. -->
  <!-- ========================================== -->

  <PropertyGroup>
    <GetOptionalProjectOutputsDependsOn>
      $(GetOptionalProjectOutputsDependsOn);
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence
    </GetOptionalProjectOutputsDependsOn>
  </PropertyGroup>

  <Target Name="GetOptionalProjectOutputs"
          Returns="@(OptionalProjectOutputs)"
          DependsOnTargets="$(GetOptionalProjectOutputsDependsOn)">

    <CallTarget Targets="OptionalProjectsOutputGroup" Condition="'$(IncludeOptionalProjectsOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_OptionalProjectsOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_OptionalProjectsOutputs Include="@(_OptionalProjectsOutputGroupOutput)">
        <OutputGroup>OptionalProjectsOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_OptionalProjectsOutputs>
    </ItemGroup>

    <PropertyGroup>
      <_ContinueOnError Condition="'$(BuildingProject)' == 'true'">true</_ContinueOnError>
      <_ContinueOnError Condition="'$(BuildingProject)' != 'true'">false</_ContinueOnError>
    </PropertyGroup>

    <MSBuild
      Projects="@(OptionalProjectBuildReferences)"
      Targets="GetOptionalProjectOutputs"
      BuildInParallel="$(BuildInParallel)"
      Properties="%(OptionalProjectBuildReferences.SetConfiguration); %(OptionalProjectBuildReferences.SetPlatform)"
      ContinueOnError="$(_ContinueOnError)">
      <Output TaskParameter="TargetOutputs" ItemName="_OptionalProjectOutputsFromOtherProjects"/>
    </MSBuild>

    <ItemGroup>
      <_AllOptionalProjectOutputs Include="@(_OptionalProjectsOutputs)"/>
      <_AllOptionalProjectOutputs Include="@(_OptionalProjectOutputsFromOtherProjects)"/>
    </ItemGroup>

    <ItemGroup>
      <OptionalProjectOutputs Include="@(_AllOptionalProjectOutputs)">
        <ProjectName>$(ProjectName)</ProjectName>
        <OutputGroup>OptionalProjectOutputGroup</OutputGroup>
      </OptionalProjectOutputs>
    </ItemGroup>

  </Target>

  <!-- ============================== -->
  <!-- Getting package architecture.  -->
  <!-- ============================== -->

  <PropertyGroup>
    <_GetPackagePropertiesDependsOn>
      $(_GetPackagePropertiesDependsOn);
      _GetProjectArchitecture;
      _GetRecursiveProjectArchitecture;
      _GetPackageArchitecture;
      _GetDefaultResourceLanguage;
      _CalculateAppxBundleProperties;
    </_GetPackagePropertiesDependsOn>
  </PropertyGroup>

  <!-- Gets some package properties. -->
  <Target Name="_GetPackageProperties"
          Condition="'$(AppxGetPackagePropertiesEnabled)' == 'true'"
          DependsOnTargets="$(_GetPackagePropertiesDependsOn)"
            />

  <!-- Extract Project Architecture from the payload -->
  <Target Name="_GetRecursiveProjectArchitecture">

    <ItemGroup>
      <_RecursiveProjectArchitecture Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == '_GetProjectArchitecture'" />
      <_RecursiveProjectArchitecture Remove="@(_RecursiveProjectArchitecture)" Condition="'%(ProjectName)' == '$(ProjectName)'" />
    </ItemGroup>

  </Target>

  <!-- Gets package architecture. -->
  <Target Name="_GetPackageArchitecture">

    <GetPackageArchitecture
        Platform="$(Platform)"
        ProjectArchitecture="@(ProjectArchitecture)"
        RecursiveProjectArchitecture="@(_RecursiveProjectArchitecture)"
        VsTelemetrySession="$(VsTelemetrySession)"
            >
      <Output TaskParameter="PackageArchitecture" PropertyName="PackageArchitecture" />
    </GetPackageArchitecture>

  </Target>

  <!-- Gets default resource language for the package. -->
  <Target Name="_GetDefaultResourceLanguage">

    <GetDefaultResourceLanguage
        DefaultLanguage="$(DefaultLanguage)"
        SourceAppxManifest="@(SourceAppxManifest)"
        VsTelemetrySession="$(VsTelemetrySession)"
            >
      <Output TaskParameter="DefaultResourceLanguage" PropertyName="DefaultResourceLanguage" />
    </GetDefaultResourceLanguage>

  </Target>

  <Target Name="_CalculateAppxBundleProperties"
          Condition="'$(AppxBundle)' != 'Never'">

    <PropertyGroup>
      <AppxBundlePlatforms Condition="'$(AppxBundlePlatforms)' == ''">$(PackageArchitecture)</AppxBundlePlatforms>
    </PropertyGroup>

    <GetAppxBundlePlatforms Input="$(AppxBundlePlatforms)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Platforms" ItemName="AppxBundlePlatform" />
      <Output TaskParameter="Last" PropertyName="AppxBundleLastPlatform" />
    </GetAppxBundlePlatforms>

    <ItemGroup>
      <AppxBundlePlatformWithAnyCPU Condition="'%(Identity)' == 'neutral'" Include="@(AppxBundlePlatform -> 'AnyCPU')" />
      <AppxBundlePlatformWithAnyCPU Condition="'%(Identity)' != 'neutral'" Include="@(AppxBundlePlatform)" />
    </ItemGroup>

    <PropertyGroup>
      <_AppxBundlePlatformsForNamingIntermediate>@(AppxBundlePlatformWithAnyCPU)</_AppxBundlePlatformsForNamingIntermediate>
    </PropertyGroup>

    <PropertyGroup>
      <AppxBundlePlatformsForNaming>$(_AppxBundlePlatformsForNamingIntermediate.Replace(';','_'))</AppxBundlePlatformsForNaming>
    </PropertyGroup>

    <PropertyGroup>
      <AppxBundleProducingPlatform Condition="'$(AppxBundleProducingPlatform)' == ''">$(AppxBundleLastPlatform)</AppxBundleProducingPlatform>
      <AppxBundleResourcePacksProducingPlatform Condition="'$(AppxBundleResourcePacksProducingPlatform)' == ''">$(AppxBundleLastPlatform)</AppxBundleResourcePacksProducingPlatform>
    </PropertyGroup>


    <PropertyGroup Condition="'$(OutDirWasSpecified)' == 'true'
                              and '$(BuildingInsideVisualStudio)' == 'true'
                              and  $(AppxBundlePlatformsForNaming.Contains('_'))">

      <AppxPackageDir Condition="'$(AppxPackageDirWasSpecified)' != 'true'">$(AppxPackageDirInProjectDir)</AppxPackageDir>
      <PlatformSpecificBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDirWasSpecified)' != 'true'">$(PlatformSpecificBundleArtifactsListDirInProjectDir)</PlatformSpecificBundleArtifactsListDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(OutDirWasSpecified)' == 'true'
                              and '$(BuildingInsideVisualStudio)' == 'true'
                              and  $(AppxBundlePlatformsForNaming.Contains('_'))
                              and '$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxUploadPackageDir Condition="'$(AppxPackageDirWasSpecified)' != 'true'">$(AppxUploadPackageDirInProjectDir)</AppxUploadPackageDir>
      <PlatformSpecificUploadBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDirWasSpecified)' != 'true'">$(PlatformSpecificBundleArtifactsListDirInProjectDir)Upload\</PlatformSpecificUploadBundleArtifactsListDir>
    </PropertyGroup>

    <PropertyGroup>
      <AppxBundlePlatformSpecificArtifactsListPath>$(PlatformSpecificBundleArtifactsListDir)$(PackageArchitecture).txt</AppxBundlePlatformSpecificArtifactsListPath>
    </PropertyGroup>

    <PropertyGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxBundlePlatformSpecificUploadArtifactsListPath>$(PlatformSpecificUploadBundleArtifactsListDir)$(PackageArchitecture).txt</AppxBundlePlatformSpecificUploadArtifactsListPath>
    </PropertyGroup>

  </Target>

  <!-- ====================== -->
  <!-- Project output groups. -->
  <!-- ====================== -->

  <!-- Targets that all output groups defined in this targets depends on. -->
  <PropertyGroup>
    <AllOutputGroupsDependsOn>
      $(AllOutputGroupsDependsOn)
      BuildOnlySettings;
      PrepareForBuild;
      AssignTargetPaths;
      ResolveReferences
    </AllOutputGroupsDependsOn>
  </PropertyGroup>

  <!-- ======================================= -->
  <!-- Output group including CopyLocal files. -->
  <!-- ======================================= -->

  <PropertyGroup>
    <CopyLocalFilesOutputGroupDependsOn>
      $(CopyLocalFilesOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </CopyLocalFilesOutputGroupDependsOn>
  </PropertyGroup>

  <Target Name="CopyLocalFilesOutputGroup"
          DependsOnTargets="$(CopyLocalFilesOutputGroupDependsOn)"
          Returns="@(CopyLocalFilesOutputGroupOutput)">

    <ItemGroup>
      <_CopyLocalFilesOutputGroupOutputFromReferences Include="@(ReferenceCopyLocalPaths)"
                                       Condition="'%(ReferenceCopyLocalPaths.Extension)' != '.xml' or '$(AppxCopyLocalFilesOutputGroupIncludeXmlFiles)' == 'true'">
        <TargetPath>%(ReferenceCopyLocalPaths.DestinationSubDirectory)%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)</TargetPath>
      </_CopyLocalFilesOutputGroupOutputFromReferences>
    </ItemGroup>

    <!-- Sometimes, we get duplicate entries here from NuGet packages which are not normalized -->
    <!-- i.e., one entry will have ..\..-style paths embedded, and other will not.             -->
    <!-- Remove those duplicates first before proceeding to look for WINMD implementations.    -->

    <RemovePayloadDuplicates Inputs="@(_CopyLocalFilesOutputGroupOutputFromReferences)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)"
                             VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="CopyLocalFilesOutputGroupOutput" />
    </RemovePayloadDuplicates>

    <!-- In case of Winmd files, we may not get implementation -->
    <!-- file as separate CopyLocal file (if exist), so we are -->
    <!-- extracting it here.                                   -->

    <ItemGroup>
      <_WinmdWithImplementation
          Include="@(CopyLocalFilesOutputGroupOutput)"
          Condition="'%(CopyLocalFilesOutputGroupOutput.Extension)' == '.winmd'
                       AND '%(CopyLocalFilesOutputGroupOutput.Filename)' != 'platform'
                       AND '%(CopyLocalFilesOutputGroupOutput.Implementation)' != ''"
                />

      <!-- Determine if any existing copy-local item has already -->
      <!-- satisfied the implementation                          -->
      <_WinmdWithImplementationTargetPath Include="@(_WinmdWithImplementation->'%(DestinationSubDirectory)%(Implementation)')">
        <OriginalItemSpec>%(Identity)</OriginalItemSpec>
      </_WinmdWithImplementationTargetPath>
      <_CopyLocalFilesOutputGroupOutputTargetPath Include="@(CopyLocalFilesOutputGroupOutput->'%(TargetPath)')"/>
      <!-- intersect on targetpath -->
      <_WinmdSatifiedImplementation Include="@(_WinmdWithImplementationTargetPath)"
                                  Condition="'@(_WinmdWithImplementationTargetPath)' == '@(_CopyLocalFilesOutputGroupOutputTargetPath)' AND '%(Identity)' != ''"/>
      <_WinmdWithImplementation Remove="@(_WinmdSatifiedImplementation->'%(OriginalItemSpec)')" />
    </ItemGroup>

    <!-- If a WINMD is coming from a NuGet package, the implementation DLL may not be delivered along with WINMD, but as       -->
    <!-- a separate item through CopyLocal or other packaging group. If DLL is not present on constructed location, remove it. -->

    <ItemGroup>
      <CopyLocalFilesOutputGroupOutput Include="%(_WinmdWithImplementation.RootDir)%(_WinmdWithImplementation.Directory)%(_WinmdWithImplementation.Implementation)"
                                       Condition="Exists('%(_WinmdWithImplementation.RootDir)%(_WinmdWithImplementation.Directory)%(_WinmdWithImplementation.Implementation)')">
        <TargetPath>%(_WinmdWithImplementation.DestinationSubDirectory)%(_WinmdWithImplementation.Implementation)</TargetPath>
      </CopyLocalFilesOutputGroupOutput>
    </ItemGroup>

  </Target>

  <!-- ================================================================================= -->
  <!-- Output group including CopyLocal files from target GetCopyToOutputDirectoryItems. -->
  <!-- ================================================================================= -->

  <PropertyGroup>
    <GetCopyToOutputDirectoryItemsOutputGroupDependsOn>
      $(GetCopyToOutputDirectoryItemsOutputGroupDependsOn);
      GetCopyToOutputDirectoryItems;
      $(AllOutputGroupsDependsOn)
    </GetCopyToOutputDirectoryItemsOutputGroupDependsOn>
  </PropertyGroup>

  <Target Name="GetCopyToOutputDirectoryItemsOutputGroup"
          DependsOnTargets="$(GetCopyToOutputDirectoryItemsOutputGroupDependsOn)"
          Returns="@(GetCopyToOutputDirectoryItemsOutputGroupOutput)">

    <ItemGroup>
      <GetCopyToOutputDirectoryItemsOutputGroupOutput Include="@(AllItemsFullPathWithTargetPath)" />
    </ItemGroup>

  </Target>

  <!-- ============================================== -->
  <!-- Output group including OptionalProjects files. -->
  <!-- ============================================== -->

  <PropertyGroup>
    <OptionalProjectsOutputGroupDependsOn>
      $(OptionalProjectsOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </OptionalProjectsOutputGroupDependsOn>
  </PropertyGroup>

  <Target Name="OptionalProjectsOutputGroup"
          DependsOnTargets="$(OptionalProjectsOutputGroupDependsOn)"
          Returns="@(OptionalProjectsOutputGroupOutput)">

    <ItemGroup>
      <OptionalProjectsOutputGroupOutput Include="@(AllBuiltSideloadPackages)">
        <FileType>SideloadPackage</FileType>
        <TargetPath>%(AllBuiltSideloadPackages.Filename)%(AllBuiltSideloadPackages.Extension)</TargetPath>
      </OptionalProjectsOutputGroupOutput>
      <OptionalProjectsOutputGroupOutput Include="@(AllBuiltUploadPackages)">
        <FileType>UploadPackage</FileType>
        <TargetPath>%(AllBuiltUploadPackages.Filename)%(AllBuiltUploadPackages.Extension)</TargetPath>
      </OptionalProjectsOutputGroupOutput>
      <OptionalProjectsOutputGroupOutput Include="@(AllGeneratedManifests)">
        <FileType>Manifest</FileType>
        <TargetPath>%(AllGeneratedManifests.Filename)%(AllGeneratedManifests.Extension)</TargetPath>
      </OptionalProjectsOutputGroupOutput>
      <OptionalProjectsOutputGroupOutput Include="@(AllGeneratedRecipes)">
        <FileType>Recipe</FileType>
        <TargetPath>%(AllGeneratedRecipes.Filename)%(AllGeneratedRecipes.Extension)</TargetPath>
      </OptionalProjectsOutputGroupOutput>
    </ItemGroup>

  </Target>

  <!-- =========================================== -->
  <!-- Output group including COM reference files. -->
  <!-- =========================================== -->

  <PropertyGroup>
    <ComFilesOutputGroupDependsOn>
      $(ComFilesOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </ComFilesOutputGroupDependsOn>
  </PropertyGroup>

  <Target Name="ComFilesOutputGroup"
          DependsOnTargets="$(ComFilesOutputGroupDependsOn)"
          Returns="@(ComFilesOutputGroupOutputs)">

    <ItemGroup>
      <ComFilesOutputGroupOutputs Include="@(ReferenceComWrappersToCopyLocal)" >
        <TargetPath>%(ReferenceComWrappersToCopyLocal.Filename)%(ReferenceComWrappersToCopyLocal.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
      <ComFilesOutputGroupOutputs Include="@(ResolvedIsolatedComModules)" >
        <TargetPath>%(ResolvedIsolatedComModules.Filename)%(ResolvedIsolatedComModules.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
      <ComFilesOutputGroupOutputs Include="@(NativeReferenceFile)" >
        <TargetPath>%(NativeReferenceFile.Filename)%(NativeReferenceFile.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
    </ItemGroup>

  </Target>

  <!-- ============================================ -->
  <!-- Output group including Winmd artifact files. -->
  <!-- ============================================ -->

  <PropertyGroup>
    <CopyWinmdArtifactsOutputGroupDependsOn>
      $(CopyWinmdArtifactsOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </CopyWinmdArtifactsOutputGroupDependsOn>
  </PropertyGroup>

  <Target
      Name="CopyWinmdArtifactsOutputGroup"
      DependsOnTargets="$(CopyWinmdArtifactsOutputGroupDependsOn)"
      Returns="@(CopyWinmdArtifactsOutputGroupOutputs)">

    <ItemGroup>
      <CopyWinmdArtifactsOutputGroupOutputs Include="@(FinalWinmdExpArtifacts ->'%(FullPath)')">
        <TargetPath>%(FinalWinmdExpArtifacts.DestinationSubDirectory)%(FinalWinmdExpArtifacts.Filename)%(FinalWinmdExpArtifacts.Extension)</TargetPath>
      </CopyWinmdArtifactsOutputGroupOutputs>
    </ItemGroup>

  </Target>

  <!-- ===================== -->
  <!-- Prepare layout target -->
  <!-- ===================== -->

  <PropertyGroup>
    <PrepareLayoutDependsOn>
      $(PrepareLayoutDependsOn);
      BeforePrepareLayout;
      _PrepareLayout;
      AfterPrepareLayout
    </PrepareLayoutDependsOn>
  </PropertyGroup>

  <!-- Prepares layout for debbuging/launching. -->
  <Target
      Name="PrepareLayout"
      Condition="'$(AppxPackage)' == 'true'"
      DependsOnTargets="$(PrepareLayoutDependsOn)" />

  <!-- Implement BeforePrepareLayout to influence final APPX layout recipe content.                          -->
  <!-- Here one can specify these additional items:                                                          -->
  <!-- (TODO: final extensibility items list and names - depending how much InternalPrepareLayout recognize) -->
  <!--                                                                                                       -->
  <!--    @(AppxAdditionalPackageContent)                                                                    -->
  <!--    @(AppxAdditionalSDKDependencies)                                                                   -->
  <!--    @(AppxAdditionalPRI)                                                                               -->
  <!--    @(AppxAdditionalWinmd)                                                                             -->
  <!--                                                                                                       -->
  <Target Name="BeforePrepareLayout" />

  <!-- Internal prepare layout target. -->
  <Target
      Name="_PrepareLayout"
      Inputs="$(MSBuildAllProjects);$(AppxPackageRecipe)"
      Outputs="$(FinalAppxPackageRecipe)">

    <!-- TODO: PRI and Winmd merge steps will be moved here -->

    <Copy UseHardlinksIfPossible="false"
          SourceFiles="$(AppxPackageRecipe)"
          DestinationFiles="$(FinalAppxPackageRecipe)"
              />
  </Target>

  <!-- Implement AfterPrepareLayout if needed to modify layout in more custom way. -->
  <!-- Here one can do arbitraty changes to $(FinalAppxPackageRecipe)              -->
  <Target Name="AfterPrepareLayout" />

  <!-- BEGIN APPINSTALLER PREPARATION -->

  <!-- ===================================================================================== -->
  <!-- Locate the .appinstaller file.                                                        -->
  <!-- ===================================================================================== -->

  <PropertyGroup>
    <AppInstallerDependsOn>
      GenerateAppInstallerFileForPackage;
      CreateAppInstallerPublishMeta;
      GeneratePublishHtmlForAppInstaller
    </AppInstallerDependsOn>
  </PropertyGroup>

  <Target Name="GenerateAppInstallerForBundle" Condition="'$(GenerateAppInstallerFile)' == 'true' AND '$(ProduceAppxBundle)' == 'true'" DependsOnTargets="$(AppInstallerDependsOn)" />
  <Target Name="GenerateAppInstallerForPackage" Condition="'$(GenerateAppInstallerFile)' == 'true' AND '$(ProduceAppxBundle)' == 'false'" DependsOnTargets="$(AppInstallerDependsOn)" />

  <Target Name="GeneratePublishHtmlForAppInstaller" DependsOnTargets="CreateAppInstallerPublishMeta">

    <PropertyGroup>
      <PublishLogoPath Condition="'$(PublishLogoPath)' == ''">%(AppInstallerPublishMeta.LogoPath)</PublishLogoPath>
    </PropertyGroup>

    <GenerateLandingPage
       OutputFolder="%(AppInstallerPublishMeta.OutputFolder)"
       AppName="%(AppInstallerPublishMeta.AppName)"
       AppDescription="%(AppInstallerPublishMeta.AppDescription)"
       Version="%(AppInstallerPublishMeta.Version)"
       RequiredOS="%(AppInstallerPublishMeta.RequiredOS)"
       PublisherName="%(AppInstallerPublishMeta.PublisherName)"
       SupportedArchitectures="%(AppInstallerPublishMeta.SupportedArchitectures)"
       AdditionalLinksMap="%(AppInstallerPublishMeta.AdditionalLinks)"
       TileColor="%(AppInstallerPublishMeta.TileColor)"
       ButtonMap="%(AppInstallerPublishMeta.ButtonMap)"
       ImageFile="$(PublishLogoPath)"
       VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="LandingPagePath" PropertyName="LandingPagePath" />

    </GenerateLandingPage>

    <ItemGroup>
      <InstallerFileWrites Include="$(LandingPagePath)" />
    </ItemGroup>
  </Target>

  <Target Name="CreateAppInstallerPublishMeta">
    <CreateAppInstallerPublishMeta
      AppInstallerMetaSearchDirectory="$(PlatformSpecificBundleArtifactsListDirInProjectDir)"
      IsBundle="$(ProduceAppxBundle)"
      AppVersion="$(AppInstallerVersion)"
      VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="AppInstallerPublishMeta" ItemName="AppInstallerPublishMeta" />
    </CreateAppInstallerPublishMeta>
  </Target>

  <Target Name="_FindAppInstallerTemplateFile">

    <ItemGroup Condition="'@(AppInstallerTemplateFile)' == ''">
      <AppInstallerTemplateFile Include="@(Content)" Condition="'%(Identity)' == '$(AppInstallerTemplateFileName)'" />
      <AppInstallerTemplateFile Include="@(None)" Condition="'%(Identity)' == '$(AppInstallerTemplateFileName)' and '$(AppInstallerTemplateFile)' == ''" />
      <None Remove="@(None)" Condition="'%(Identity)' == '$(AppInstallerTemplateFileName)'" />
    </ItemGroup>

  </Target>

  <Target Name="GenerateAppInstallerFileForPackage"
          DependsOnTargets="_FindAppInstallerTemplateFile">

    <PropertyGroup>
      <AppInstallerPackageOutputFile>$(AppxPackageOutput)</AppInstallerPackageOutputFile>
      <AppInstallerPackageOutputFile Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxBundleOutput)</AppInstallerPackageOutputFile>
    </PropertyGroup>

    <GenerateAppInstallerFile
      AppInstallerTemplateFile="@(AppInstallerTemplateFile)"
      FinalAppxManifestFile="$(FinalAppxManifestName)"
      HoursBetweenUpdateChecks ="$(HoursBetweenUpdateChecks)"
      AppInstallerCheckForUpdateFrequency="$(AppInstallerCheckForUpdateFrequency)"
      AppInstallerUpdateFrequency="$(AppInstallerUpdateFrequency)"
      AppInstallerUri="$(AppInstallerUri)"
      BundleArtifactsDir="$(PlatformSpecificBundleArtifactsListDirInProjectDir)"
      ProjectFileDir="$(MSBuildProjectDirectory)"
      AppxBundlePlatforms="$(AppxBundlePlatforms)"
      ProjectName="$(ProjectName)"
      ProduceAppxBundle="$(ProduceAppxBundle)"
      FrameworkSdkPackages="@(FrameworkSdkPackage)"
      AppxPackageDir="$(AppxPackageDir)"
      AppxUri="$(AppInstallerPackageOutputFile)"
      AppxPackagingComponentManifestPath="$(AppxPackagingComponentManifestPath)"
      VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="AppInstallerFileWrites" ItemName="AppInstallerFileWrites" />
      <Output TaskParameter="AppInstallerFilePath" ItemName="AppInstallerFilePath" />
      <Output TaskParameter="AppInstallerVersion" PropertyName="AppInstallerVersion" />
    </GenerateAppInstallerFile>

    <ItemGroup>
      <FileWrites Include="@(AppInstallerFileWrites)" />
      <InstallerFileWrites Include="@(AppInstallerFilePath)" />
    </ItemGroup>
  </Target>

  <!-- Adjusting SDK payload. -->

  <PropertyGroup>
    <SDKRedistOutputGroupDependsOn>
      $(SDKRedistOutputGroupDependsOn);
      _ProcessPriFilesFromSdkPayload
    </SDKRedistOutputGroupDependsOn>
  </PropertyGroup>

  <Target Name="_ProcessPriFilesFromSdkPayload"
          Condition="'$(AppxProcessPriFilesFromSdkPayload)' == 'true'"
          DependsOnTargets="ExpandSDKReferences;_GetSdkToolPaths">

    <RemoveRedundantXamlFilesFromSdkPayload SdkPayload="@(ResolvedRedistFiles)"
                                            MrmSupportLibraryPath="$(MrmSupportLibraryPath)"
                                            VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FilesToRemove" ItemName="_RedistFilesToRemove" />
    </RemoveRedundantXamlFilesFromSdkPayload>

    <ItemGroup>
      <ResolvedRedistFiles Remove="@(_RedistFilesToRemove)" />
    </ItemGroup>

  </Target>

  <Target Name="_ContinuousStoreSubmission"
          Condition="'$(BuildingInsideVisualStudio)' != 'true' and $(AppxStoreContainer) != '' and '$(Configuration)' != 'Debug' and '@(StoreAssociationFile)' != ''"
          DependsOnTargets="_FindStoreAssociationFile">

    <StoreSubmission StoreAssociationFile="@(StoreAssociationFile)"
                     AppxUploadPackage="$(AppxStoreContainer)"
                     VsTelemetrySession="$(VsTelemetrySession)"
                     EnableDirectStoreSubmission="$(EnableDirectStoreSubmission)"
                     OverwritePendingSubmission="$(OverwritePendingSubmission)" />
  </Target>

  <Target Name="_ValidateConfiguration">
    <ValidateConfiguration
      TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
      TargetPlatformVersion="$(TargetPlatformVersion)"
      ProjectLanguage="$(Language)"
      VsTelemetrySession="$(VsTelemetrySession)"
      TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
      Platform="$(Platform)">
    </ValidateConfiguration>
  </Target>
</Project>
